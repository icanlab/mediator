# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_interfaces_ietf_routing__routing_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network-layer interfaces used for routing.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /routing/interfaces/interface (if:interface-ref)

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /routing/interfaces/interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

  interface = __builtin__.property(_get_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_distance_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_distance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/distance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Administrative distance (or preference) assigned to
routes received from different sources
(external, internal, and local).
  """
  __slots__ = ('_path_helper', '_extmethods', '__external','__internal',)

  _yang_name = 'distance'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__external = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="external", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    self.__internal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="internal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'distance']

  def _get_external(self):
    """
    Getter method for external, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/distance/external (uint8)

    YANG Description: Administrative distance for routes learned from
external BGP (eBGP).
    """
    return self.__external
      
  def _set_external(self, v, load=False):
    """
    Setter method for external, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/distance/external (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external() directly.

    YANG Description: Administrative distance for routes learned from
external BGP (eBGP).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="external", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """external must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="external", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__external = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_external(self):
    self.__external = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="external", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)


  def _get_internal(self):
    """
    Getter method for internal, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/distance/internal (uint8)

    YANG Description: Administrative distance for routes learned from
internal BGP (iBGP).
    """
    return self.__internal
      
  def _set_internal(self, v, load=False):
    """
    Setter method for internal, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/distance/internal (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_internal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_internal() directly.

    YANG Description: Administrative distance for routes learned from
internal BGP (iBGP).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="internal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """internal must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="internal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__internal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_internal(self):
    self.__internal = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="internal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)

  external = __builtin__.property(_get_external, _set_external)
  internal = __builtin__.property(_get_internal, _set_internal)


  _pyangbind_elements = OrderedDict([('external', external), ('internal', internal), ])


class yc_confederation_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_confederation(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/confederation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration options specifying parameters when the
local router is within an autonomous system which is
part of a BGP confederation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__identifier','__member_as',)

  _yang_name = 'confederation'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__identifier = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    self.__member_as = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="member-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'confederation']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/confederation/enabled (boolean)

    YANG Description: When this leaf is set to true it indicates that
the local-AS is part of a BGP confederation
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/confederation/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When this leaf is set to true it indicates that
the local-AS is part of a BGP confederation
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_identifier(self):
    """
    Getter method for identifier, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/confederation/identifier (inet:as-number)

    YANG Description: Confederation identifier for the autonomous system.
    """
    return self.__identifier
      
  def _set_identifier(self, v, load=False):
    """
    Setter method for identifier, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/confederation/identifier (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_identifier() directly.

    YANG Description: Confederation identifier for the autonomous system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """identifier must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)""",
        })

    self.__identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_identifier(self):
    self.__identifier = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)


  def _get_member_as(self):
    """
    Getter method for member_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/confederation/member_as (inet:as-number)

    YANG Description: Remote autonomous systems that are to be treated
as part of the local confederation.
    """
    return self.__member_as
      
  def _set_member_as(self, v, load=False):
    """
    Setter method for member_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/confederation/member_as (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member_as() directly.

    YANG Description: Remote autonomous systems that are to be treated
as part of the local confederation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="member-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member_as must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="member-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)""",
        })

    self.__member_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member_as(self):
    self.__member_as = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="member-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  identifier = __builtin__.property(_get_identifier, _set_identifier)
  member_as = __builtin__.property(_get_member_as, _set_member_as)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('identifier', identifier), ('member_as', member_as), ])


class yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_graceful_restart(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/graceful-restart. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating the graceful restart mechanism for
BGP
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__restart_time','__stale_routes_time','__helper_only',)

  _yang_name = 'graceful-restart'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__restart_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    self.__stale_routes_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stale-routes-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__helper_only = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="helper-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'graceful-restart']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/graceful_restart/enabled (boolean)

    YANG Description: Enable or disable the graceful-restart capability.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/graceful_restart/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Enable or disable the graceful-restart capability.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_restart_time(self):
    """
    Getter method for restart_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/graceful_restart/restart_time (uint16)

    YANG Description: Estimated time (in seconds) for the local BGP speaker to
restart a session. This value is advertise in the graceful
restart BGP capability.  This is a 12-bit value, referred to
as Restart Time in RFC4724.  Per RFC4724, the suggested
default value is <= the hold-time value.
    """
    return self.__restart_time
      
  def _set_restart_time(self, v, load=False):
    """
    Setter method for restart_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/graceful_restart/restart_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_time() directly.

    YANG Description: Estimated time (in seconds) for the local BGP speaker to
restart a session. This value is advertise in the graceful
restart BGP capability.  This is a 12-bit value, referred to
as Restart Time in RFC4724.  Per RFC4724, the suggested
default value is <= the hold-time value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__restart_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_time(self):
    self.__restart_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)


  def _get_stale_routes_time(self):
    """
    Getter method for stale_routes_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/graceful_restart/stale_routes_time (uint32)

    YANG Description: An upper-bound on the time that stale routes will be
retained by a router after a session is restarted. If an
End-of-RIB (EOR) marker is received prior to this timer
expiring stale-routes will be flushed upon its receipt - if
no EOR is received, then when this timer expires stale paths
will be purged. This timer is referred to as the
Selection_Deferral_Timer in RFC4724
    """
    return self.__stale_routes_time
      
  def _set_stale_routes_time(self, v, load=False):
    """
    Setter method for stale_routes_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/graceful_restart/stale_routes_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stale_routes_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stale_routes_time() directly.

    YANG Description: An upper-bound on the time that stale routes will be
retained by a router after a session is restarted. If an
End-of-RIB (EOR) marker is received prior to this timer
expiring stale-routes will be flushed upon its receipt - if
no EOR is received, then when this timer expires stale paths
will be purged. This timer is referred to as the
Selection_Deferral_Timer in RFC4724
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stale-routes-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stale_routes_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stale-routes-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__stale_routes_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stale_routes_time(self):
    self.__stale_routes_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stale-routes-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_helper_only(self):
    """
    Getter method for helper_only, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/graceful_restart/helper_only (boolean)

    YANG Description: Enable graceful-restart in helper mode only. When this leaf
is set, the local system does not retain forwarding its own
state during a restart, but supports procedures for the
receiving speaker, as defined in RFC4724.
    """
    return self.__helper_only
      
  def _set_helper_only(self, v, load=False):
    """
    Setter method for helper_only, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/graceful_restart/helper_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helper_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helper_only() directly.

    YANG Description: Enable graceful-restart in helper mode only. When this leaf
is set, the local system does not retain forwarding its own
state during a restart, but supports procedures for the
receiving speaker, as defined in RFC4724.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="helper-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """helper_only must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="helper-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__helper_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_helper_only(self):
    self.__helper_only = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="helper-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  restart_time = __builtin__.property(_get_restart_time, _set_restart_time)
  stale_routes_time = __builtin__.property(_get_stale_routes_time, _set_stale_routes_time)
  helper_only = __builtin__.property(_get_helper_only, _set_helper_only)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('restart_time', restart_time), ('stale_routes_time', stale_routes_time), ('helper_only', helper_only), ])


class yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths_ebgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/use-multiple-paths/ebgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multi-Path parameters for eBGP
  """
  __slots__ = ('_path_helper', '_extmethods', '__allow_multiple_as','__maximum_paths',)

  _yang_name = 'ebgp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__allow_multiple_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'use-multiple-paths', 'ebgp']

  def _get_allow_multiple_as(self):
    """
    Getter method for allow_multiple_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/use_multiple_paths/ebgp/allow_multiple_as (boolean)

    YANG Description: Allow multi-path to use paths from different neighboring
ASes.  The default is to only consider multiple paths
from the same neighboring AS.
    """
    return self.__allow_multiple_as
      
  def _set_allow_multiple_as(self, v, load=False):
    """
    Setter method for allow_multiple_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/use_multiple_paths/ebgp/allow_multiple_as (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allow_multiple_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allow_multiple_as() directly.

    YANG Description: Allow multi-path to use paths from different neighboring
ASes.  The default is to only consider multiple paths
from the same neighboring AS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allow_multiple_as must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__allow_multiple_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allow_multiple_as(self):
    self.__allow_multiple_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_maximum_paths(self):
    """
    Getter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/use_multiple_paths/ebgp/maximum_paths (uint32)

    YANG Description: Maximum number of parallel paths to consider when using
BGP multi-path. The default is use a single path.
    """
    return self.__maximum_paths
      
  def _set_maximum_paths(self, v, load=False):
    """
    Setter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/use_multiple_paths/ebgp/maximum_paths (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_paths() directly.

    YANG Description: Maximum number of parallel paths to consider when using
BGP multi-path. The default is use a single path.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_paths must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__maximum_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_paths(self):
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  allow_multiple_as = __builtin__.property(_get_allow_multiple_as, _set_allow_multiple_as)
  maximum_paths = __builtin__.property(_get_maximum_paths, _set_maximum_paths)


  _pyangbind_elements = OrderedDict([('allow_multiple_as', allow_multiple_as), ('maximum_paths', maximum_paths), ])


class yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths_ibgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/use-multiple-paths/ibgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multi-Path parameters for iBGP
  """
  __slots__ = ('_path_helper', '_extmethods', '__maximum_paths',)

  _yang_name = 'ibgp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'use-multiple-paths', 'ibgp']

  def _get_maximum_paths(self):
    """
    Getter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/use_multiple_paths/ibgp/maximum_paths (uint32)

    YANG Description: Maximum number of parallel paths to consider when using
iBGP multi-path. The default is to use a single path
    """
    return self.__maximum_paths
      
  def _set_maximum_paths(self, v, load=False):
    """
    Setter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/use_multiple_paths/ibgp/maximum_paths (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_paths() directly.

    YANG Description: Maximum number of parallel paths to consider when using
iBGP multi-path. The default is to use a single path
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_paths must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__maximum_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_paths(self):
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  maximum_paths = __builtin__.property(_get_maximum_paths, _set_maximum_paths)


  _pyangbind_elements = OrderedDict([('maximum_paths', maximum_paths), ])


class yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/use-multiple-paths. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters related to the use of multiple paths for the
same NLRI
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__ebgp','__ibgp',)

  _yang_name = 'use-multiple-paths'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ebgp = YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ibgp = YANGDynClass(base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'use-multiple-paths']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/use_multiple_paths/enabled (boolean)

    YANG Description: Whether the use of multiple paths for the same NLRI is
enabled for the neighbor. This value is overridden by any
more specific configuration value.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/use_multiple_paths/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Whether the use of multiple paths for the same NLRI is
enabled for the neighbor. This value is overridden by any
more specific configuration value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ebgp(self):
    """
    Getter method for ebgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/use_multiple_paths/ebgp (container)

    YANG Description: Multi-Path parameters for eBGP
    """
    return self.__ebgp
      
  def _set_ebgp(self, v, load=False):
    """
    Setter method for ebgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/use_multiple_paths/ebgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp() directly.

    YANG Description: Multi-Path parameters for eBGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp(self):
    self.__ebgp = YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ibgp(self):
    """
    Getter method for ibgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/use_multiple_paths/ibgp (container)

    YANG Description: Multi-Path parameters for iBGP
    """
    return self.__ibgp
      
  def _set_ibgp(self, v, load=False):
    """
    Setter method for ibgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/use_multiple_paths/ibgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ibgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ibgp() directly.

    YANG Description: Multi-Path parameters for iBGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ibgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ibgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ibgp(self):
    self.__ibgp = YANGDynClass(base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  ebgp = __builtin__.property(_get_ebgp, _set_ebgp) # type: yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths_ebgp
  ibgp = __builtin__.property(_get_ibgp, _set_ibgp) # type: yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths_ibgp


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('ebgp', ebgp), ('ibgp', ibgp), ])


class yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_route_selection_options(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/route-selection-options. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to options for route selection
  """
  __slots__ = ('_path_helper', '_extmethods', '__always_compare_med','__ignore_as_path_length','__external_compare_router_id','__advertise_inactive_routes','__enable_aigp','__ignore_next_hop_igp_metric','__enable_med',)

  _yang_name = 'route-selection-options'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__always_compare_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ignore_as_path_length = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__external_compare_router_id = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__advertise_inactive_routes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__enable_aigp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ignore_next_hop_igp_metric = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__enable_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'route-selection-options']

  def _get_always_compare_med(self):
    """
    Getter method for always_compare_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options/always_compare_med (boolean)

    YANG Description: Compare multi-exit discriminator (MED) value from
different ASes when selecting the best route.  The default
behavior is to only compare MEDs for paths received from
the same AS.
    """
    return self.__always_compare_med
      
  def _set_always_compare_med(self, v, load=False):
    """
    Setter method for always_compare_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options/always_compare_med (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_always_compare_med is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_always_compare_med() directly.

    YANG Description: Compare multi-exit discriminator (MED) value from
different ASes when selecting the best route.  The default
behavior is to only compare MEDs for paths received from
the same AS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """always_compare_med must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__always_compare_med = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_always_compare_med(self):
    self.__always_compare_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ignore_as_path_length(self):
    """
    Getter method for ignore_as_path_length, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options/ignore_as_path_length (boolean)

    YANG Description: Ignore the AS path length when selecting the best path.
The default is to use the AS path length and prefer paths
with shorter length.
    """
    return self.__ignore_as_path_length
      
  def _set_ignore_as_path_length(self, v, load=False):
    """
    Setter method for ignore_as_path_length, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options/ignore_as_path_length (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_as_path_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_as_path_length() directly.

    YANG Description: Ignore the AS path length when selecting the best path.
The default is to use the AS path length and prefer paths
with shorter length.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_as_path_length must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ignore_as_path_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_as_path_length(self):
    self.__ignore_as_path_length = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_external_compare_router_id(self):
    """
    Getter method for external_compare_router_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options/external_compare_router_id (boolean)

    YANG Description: When comparing similar routes received from external BGP
peers, use the router-id as a criterion to select the
active path.
    """
    return self.__external_compare_router_id
      
  def _set_external_compare_router_id(self, v, load=False):
    """
    Setter method for external_compare_router_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options/external_compare_router_id (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external_compare_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external_compare_router_id() directly.

    YANG Description: When comparing similar routes received from external BGP
peers, use the router-id as a criterion to select the
active path.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """external_compare_router_id must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__external_compare_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_external_compare_router_id(self):
    self.__external_compare_router_id = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_advertise_inactive_routes(self):
    """
    Getter method for advertise_inactive_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options/advertise_inactive_routes (boolean)

    YANG Description: Advertise inactive routes to external peers.  The default
is to only advertise active routes.
    """
    return self.__advertise_inactive_routes
      
  def _set_advertise_inactive_routes(self, v, load=False):
    """
    Setter method for advertise_inactive_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options/advertise_inactive_routes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_inactive_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_inactive_routes() directly.

    YANG Description: Advertise inactive routes to external peers.  The default
is to only advertise active routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_inactive_routes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertise_inactive_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_inactive_routes(self):
    self.__advertise_inactive_routes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_enable_aigp(self):
    """
    Getter method for enable_aigp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options/enable_aigp (boolean)

    YANG Description: Flag to enable sending / receiving accumulated IGP
attribute in routing updates
    """
    return self.__enable_aigp
      
  def _set_enable_aigp(self, v, load=False):
    """
    Setter method for enable_aigp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options/enable_aigp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_aigp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_aigp() directly.

    YANG Description: Flag to enable sending / receiving accumulated IGP
attribute in routing updates
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_aigp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enable_aigp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_aigp(self):
    self.__enable_aigp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ignore_next_hop_igp_metric(self):
    """
    Getter method for ignore_next_hop_igp_metric, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options/ignore_next_hop_igp_metric (boolean)

    YANG Description: Ignore the IGP metric to the next-hop when calculating BGP
best-path. The default is to select the route for which
the metric to the next-hop is lowest
    """
    return self.__ignore_next_hop_igp_metric
      
  def _set_ignore_next_hop_igp_metric(self, v, load=False):
    """
    Setter method for ignore_next_hop_igp_metric, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options/ignore_next_hop_igp_metric (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_next_hop_igp_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_next_hop_igp_metric() directly.

    YANG Description: Ignore the IGP metric to the next-hop when calculating BGP
best-path. The default is to select the route for which
the metric to the next-hop is lowest
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_next_hop_igp_metric must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ignore_next_hop_igp_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_next_hop_igp_metric(self):
    self.__ignore_next_hop_igp_metric = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_enable_med(self):
    """
    Getter method for enable_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options/enable_med (boolean)

    YANG Description: Flag to enable sending/receiving of MED metric attribute
       in routing updates.
    """
    return self.__enable_med
      
  def _set_enable_med(self, v, load=False):
    """
    Setter method for enable_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options/enable_med (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_med is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_med() directly.

    YANG Description: Flag to enable sending/receiving of MED metric attribute
       in routing updates.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_med must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enable_med = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_med(self):
    self.__enable_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  always_compare_med = __builtin__.property(_get_always_compare_med, _set_always_compare_med)
  ignore_as_path_length = __builtin__.property(_get_ignore_as_path_length, _set_ignore_as_path_length)
  external_compare_router_id = __builtin__.property(_get_external_compare_router_id, _set_external_compare_router_id)
  advertise_inactive_routes = __builtin__.property(_get_advertise_inactive_routes, _set_advertise_inactive_routes)
  enable_aigp = __builtin__.property(_get_enable_aigp, _set_enable_aigp)
  ignore_next_hop_igp_metric = __builtin__.property(_get_ignore_next_hop_igp_metric, _set_ignore_next_hop_igp_metric)
  enable_med = __builtin__.property(_get_enable_med, _set_enable_med)


  _pyangbind_elements = OrderedDict([('always_compare_med', always_compare_med), ('ignore_as_path_length', ignore_as_path_length), ('external_compare_router_id', external_compare_router_id), ('advertise_inactive_routes', advertise_inactive_routes), ('enable_aigp', enable_aigp), ('ignore_next_hop_igp_metric', ignore_next_hop_igp_metric), ('enable_med', enable_med), ])


class yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_graceful_restart(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/graceful-restart. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to BGP graceful-restart
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'graceful-restart'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'graceful-restart']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/graceful_restart/enabled (boolean)

    YANG Description: This leaf indicates whether graceful-restart is enabled for
this AFI-SAFI
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/graceful_restart/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf indicates whether graceful-restart is enabled for
this AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_route_selection_options(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/route-selection-options. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to options for route selection
  """
  __slots__ = ('_path_helper', '_extmethods', '__always_compare_med','__ignore_as_path_length','__external_compare_router_id','__advertise_inactive_routes','__enable_aigp','__ignore_next_hop_igp_metric','__enable_med',)

  _yang_name = 'route-selection-options'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__always_compare_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ignore_as_path_length = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__external_compare_router_id = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__advertise_inactive_routes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__enable_aigp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ignore_next_hop_igp_metric = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__enable_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'route-selection-options']

  def _get_always_compare_med(self):
    """
    Getter method for always_compare_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options/always_compare_med (boolean)

    YANG Description: Compare multi-exit discriminator (MED) value from
different ASes when selecting the best route.  The default
behavior is to only compare MEDs for paths received from
the same AS.
    """
    return self.__always_compare_med
      
  def _set_always_compare_med(self, v, load=False):
    """
    Setter method for always_compare_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options/always_compare_med (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_always_compare_med is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_always_compare_med() directly.

    YANG Description: Compare multi-exit discriminator (MED) value from
different ASes when selecting the best route.  The default
behavior is to only compare MEDs for paths received from
the same AS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """always_compare_med must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__always_compare_med = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_always_compare_med(self):
    self.__always_compare_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ignore_as_path_length(self):
    """
    Getter method for ignore_as_path_length, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options/ignore_as_path_length (boolean)

    YANG Description: Ignore the AS path length when selecting the best path.
The default is to use the AS path length and prefer paths
with shorter length.
    """
    return self.__ignore_as_path_length
      
  def _set_ignore_as_path_length(self, v, load=False):
    """
    Setter method for ignore_as_path_length, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options/ignore_as_path_length (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_as_path_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_as_path_length() directly.

    YANG Description: Ignore the AS path length when selecting the best path.
The default is to use the AS path length and prefer paths
with shorter length.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_as_path_length must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ignore_as_path_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_as_path_length(self):
    self.__ignore_as_path_length = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_external_compare_router_id(self):
    """
    Getter method for external_compare_router_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options/external_compare_router_id (boolean)

    YANG Description: When comparing similar routes received from external BGP
peers, use the router-id as a criterion to select the
active path.
    """
    return self.__external_compare_router_id
      
  def _set_external_compare_router_id(self, v, load=False):
    """
    Setter method for external_compare_router_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options/external_compare_router_id (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external_compare_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external_compare_router_id() directly.

    YANG Description: When comparing similar routes received from external BGP
peers, use the router-id as a criterion to select the
active path.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """external_compare_router_id must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__external_compare_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_external_compare_router_id(self):
    self.__external_compare_router_id = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_advertise_inactive_routes(self):
    """
    Getter method for advertise_inactive_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options/advertise_inactive_routes (boolean)

    YANG Description: Advertise inactive routes to external peers.  The default
is to only advertise active routes.
    """
    return self.__advertise_inactive_routes
      
  def _set_advertise_inactive_routes(self, v, load=False):
    """
    Setter method for advertise_inactive_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options/advertise_inactive_routes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_inactive_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_inactive_routes() directly.

    YANG Description: Advertise inactive routes to external peers.  The default
is to only advertise active routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_inactive_routes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertise_inactive_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_inactive_routes(self):
    self.__advertise_inactive_routes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_enable_aigp(self):
    """
    Getter method for enable_aigp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options/enable_aigp (boolean)

    YANG Description: Flag to enable sending / receiving accumulated IGP
attribute in routing updates
    """
    return self.__enable_aigp
      
  def _set_enable_aigp(self, v, load=False):
    """
    Setter method for enable_aigp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options/enable_aigp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_aigp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_aigp() directly.

    YANG Description: Flag to enable sending / receiving accumulated IGP
attribute in routing updates
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_aigp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enable_aigp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_aigp(self):
    self.__enable_aigp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ignore_next_hop_igp_metric(self):
    """
    Getter method for ignore_next_hop_igp_metric, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options/ignore_next_hop_igp_metric (boolean)

    YANG Description: Ignore the IGP metric to the next-hop when calculating BGP
best-path. The default is to select the route for which
the metric to the next-hop is lowest
    """
    return self.__ignore_next_hop_igp_metric
      
  def _set_ignore_next_hop_igp_metric(self, v, load=False):
    """
    Setter method for ignore_next_hop_igp_metric, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options/ignore_next_hop_igp_metric (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_next_hop_igp_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_next_hop_igp_metric() directly.

    YANG Description: Ignore the IGP metric to the next-hop when calculating BGP
best-path. The default is to select the route for which
the metric to the next-hop is lowest
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_next_hop_igp_metric must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ignore_next_hop_igp_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_next_hop_igp_metric(self):
    self.__ignore_next_hop_igp_metric = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_enable_med(self):
    """
    Getter method for enable_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options/enable_med (boolean)

    YANG Description: Flag to enable sending/receiving of MED metric attribute
       in routing updates.
    """
    return self.__enable_med
      
  def _set_enable_med(self, v, load=False):
    """
    Setter method for enable_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options/enable_med (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_med is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_med() directly.

    YANG Description: Flag to enable sending/receiving of MED metric attribute
       in routing updates.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_med must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enable_med = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_med(self):
    self.__enable_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  always_compare_med = __builtin__.property(_get_always_compare_med, _set_always_compare_med)
  ignore_as_path_length = __builtin__.property(_get_ignore_as_path_length, _set_ignore_as_path_length)
  external_compare_router_id = __builtin__.property(_get_external_compare_router_id, _set_external_compare_router_id)
  advertise_inactive_routes = __builtin__.property(_get_advertise_inactive_routes, _set_advertise_inactive_routes)
  enable_aigp = __builtin__.property(_get_enable_aigp, _set_enable_aigp)
  ignore_next_hop_igp_metric = __builtin__.property(_get_ignore_next_hop_igp_metric, _set_ignore_next_hop_igp_metric)
  enable_med = __builtin__.property(_get_enable_med, _set_enable_med)


  _pyangbind_elements = OrderedDict([('always_compare_med', always_compare_med), ('ignore_as_path_length', ignore_as_path_length), ('external_compare_router_id', external_compare_router_id), ('advertise_inactive_routes', advertise_inactive_routes), ('enable_aigp', enable_aigp), ('ignore_next_hop_igp_metric', ignore_next_hop_igp_metric), ('enable_med', enable_med), ])


class yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths_ebgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/use-multiple-paths/ebgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multi-Path parameters for eBGP
  """
  __slots__ = ('_path_helper', '_extmethods', '__allow_multiple_as','__maximum_paths',)

  _yang_name = 'ebgp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__allow_multiple_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'use-multiple-paths', 'ebgp']

  def _get_allow_multiple_as(self):
    """
    Getter method for allow_multiple_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/ebgp/allow_multiple_as (boolean)

    YANG Description: Allow multi-path to use paths from different neighboring
ASes.  The default is to only consider multiple paths
from the same neighboring AS.
    """
    return self.__allow_multiple_as
      
  def _set_allow_multiple_as(self, v, load=False):
    """
    Setter method for allow_multiple_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/ebgp/allow_multiple_as (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allow_multiple_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allow_multiple_as() directly.

    YANG Description: Allow multi-path to use paths from different neighboring
ASes.  The default is to only consider multiple paths
from the same neighboring AS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allow_multiple_as must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__allow_multiple_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allow_multiple_as(self):
    self.__allow_multiple_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_maximum_paths(self):
    """
    Getter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/ebgp/maximum_paths (uint32)

    YANG Description: Maximum number of parallel paths to consider when using
BGP multi-path. The default is use a single path.
    """
    return self.__maximum_paths
      
  def _set_maximum_paths(self, v, load=False):
    """
    Setter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/ebgp/maximum_paths (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_paths() directly.

    YANG Description: Maximum number of parallel paths to consider when using
BGP multi-path. The default is use a single path.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_paths must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__maximum_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_paths(self):
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  allow_multiple_as = __builtin__.property(_get_allow_multiple_as, _set_allow_multiple_as)
  maximum_paths = __builtin__.property(_get_maximum_paths, _set_maximum_paths)


  _pyangbind_elements = OrderedDict([('allow_multiple_as', allow_multiple_as), ('maximum_paths', maximum_paths), ])


class yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths_ibgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/use-multiple-paths/ibgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multi-Path parameters for iBGP
  """
  __slots__ = ('_path_helper', '_extmethods', '__maximum_paths',)

  _yang_name = 'ibgp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'use-multiple-paths', 'ibgp']

  def _get_maximum_paths(self):
    """
    Getter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/ibgp/maximum_paths (uint32)

    YANG Description: Maximum number of parallel paths to consider when using
iBGP multi-path. The default is to use a single path
    """
    return self.__maximum_paths
      
  def _set_maximum_paths(self, v, load=False):
    """
    Setter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/ibgp/maximum_paths (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_paths() directly.

    YANG Description: Maximum number of parallel paths to consider when using
iBGP multi-path. The default is to use a single path
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_paths must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__maximum_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_paths(self):
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  maximum_paths = __builtin__.property(_get_maximum_paths, _set_maximum_paths)


  _pyangbind_elements = OrderedDict([('maximum_paths', maximum_paths), ])


class yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/use-multiple-paths. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters related to the use of multiple paths for the
same NLRI
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__ebgp','__ibgp',)

  _yang_name = 'use-multiple-paths'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ebgp = YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ibgp = YANGDynClass(base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'use-multiple-paths']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/enabled (boolean)

    YANG Description: Whether the use of multiple paths for the same NLRI is
enabled for the neighbor. This value is overridden by any
more specific configuration value.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Whether the use of multiple paths for the same NLRI is
enabled for the neighbor. This value is overridden by any
more specific configuration value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ebgp(self):
    """
    Getter method for ebgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/ebgp (container)

    YANG Description: Multi-Path parameters for eBGP
    """
    return self.__ebgp
      
  def _set_ebgp(self, v, load=False):
    """
    Setter method for ebgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/ebgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp() directly.

    YANG Description: Multi-Path parameters for eBGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp(self):
    self.__ebgp = YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ibgp(self):
    """
    Getter method for ibgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/ibgp (container)

    YANG Description: Multi-Path parameters for iBGP
    """
    return self.__ibgp
      
  def _set_ibgp(self, v, load=False):
    """
    Setter method for ibgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths/ibgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ibgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ibgp() directly.

    YANG Description: Multi-Path parameters for iBGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ibgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ibgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ibgp(self):
    self.__ibgp = YANGDynClass(base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  ebgp = __builtin__.property(_get_ebgp, _set_ebgp) # type: yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths_ebgp
  ibgp = __builtin__.property(_get_ibgp, _set_ibgp) # type: yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths_ibgp


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('ebgp', ebgp), ('ibgp', ibgp), ])


class yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_apply_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/apply-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
  """
  __slots__ = ('_path_helper', '_extmethods', '__import_policy','__default_import_policy','__export_policy','__default_export_policy',)

  _yang_name = 'apply-policy'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__import_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__default_import_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    self.__export_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__default_export_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'apply-policy']

  def _get_import_policy(self):
    """
    Getter method for import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/apply_policy/import_policy (leafref)

    YANG Description: List of policy names in sequence to be applied on
receiving redistributed routes from another routing protocol
or receiving a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    return self.__import_policy
      
  def _set_import_policy(self, v, load=False):
    """
    Setter method for import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/apply_policy/import_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_policy() directly.

    YANG Description: List of policy names in sequence to be applied on
receiving redistributed routes from another routing protocol
or receiving a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_policy(self):
    self.__import_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_default_import_policy(self):
    """
    Getter method for default_import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/apply_policy/default_import_policy (default-policy-type)

    YANG Description: Explicitly set a default policy if no policy definition
in the import policy chain is satisfied.
    """
    return self.__default_import_policy
      
  def _set_default_import_policy(self, v, load=False):
    """
    Setter method for default_import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/apply_policy/default_import_policy (default-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_import_policy() directly.

    YANG Description: Explicitly set a default policy if no policy definition
in the import policy chain is satisfied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_import_policy must be of a type compatible with default-policy-type""",
          'defined-type': "ietf-bgp:default-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)""",
        })

    self.__default_import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_import_policy(self):
    self.__default_import_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)


  def _get_export_policy(self):
    """
    Getter method for export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/apply_policy/export_policy (leafref)

    YANG Description: List of policy names in sequence to be applied on
redistributing routes from one routing protocol to another
or sending a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    return self.__export_policy
      
  def _set_export_policy(self, v, load=False):
    """
    Setter method for export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/apply_policy/export_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_export_policy() directly.

    YANG Description: List of policy names in sequence to be applied on
redistributing routes from one routing protocol to another
or sending a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """export_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_export_policy(self):
    self.__export_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_default_export_policy(self):
    """
    Getter method for default_export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/apply_policy/default_export_policy (default-policy-type)

    YANG Description: Explicitly set a default policy if no policy definition
in the export policy chain is satisfied.
    """
    return self.__default_export_policy
      
  def _set_default_export_policy(self, v, load=False):
    """
    Setter method for default_export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/apply_policy/default_export_policy (default-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_export_policy() directly.

    YANG Description: Explicitly set a default policy if no policy definition
in the export policy chain is satisfied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_export_policy must be of a type compatible with default-policy-type""",
          'defined-type': "ietf-bgp:default-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)""",
        })

    self.__default_export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_export_policy(self):
    self.__default_export_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)

  import_policy = __builtin__.property(_get_import_policy, _set_import_policy)
  default_import_policy = __builtin__.property(_get_default_import_policy, _set_default_import_policy)
  export_policy = __builtin__.property(_get_export_policy, _set_export_policy)
  default_export_policy = __builtin__.property(_get_default_export_policy, _set_default_export_policy)


  _pyangbind_elements = OrderedDict([('import_policy', import_policy), ('default_import_policy', default_import_policy), ('export_policy', export_policy), ('default_export_policy', default_export_policy), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/ipv4-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/ipv4-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv4 unicast configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit','__send_default_route',)

  _yang_name = 'ipv4-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__send_default_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'ipv4-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_send_default_route(self):
    """
    Getter method for send_default_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_unicast/send_default_route (boolean)

    YANG Description: If set to true, send the default-route to the neighbour(s)
    """
    return self.__send_default_route
      
  def _set_send_default_route(self, v, load=False):
    """
    Setter method for send_default_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_unicast/send_default_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_default_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_default_route() directly.

    YANG Description: If set to true, send the default-route to the neighbour(s)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_default_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__send_default_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_default_route(self):
    self.__send_default_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_unicast_prefix_limit
  send_default_route = __builtin__.property(_get_send_default_route, _set_send_default_route)


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ('send_default_route', send_default_route), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/ipv6-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/ipv6-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv6 unicast configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit','__send_default_route',)

  _yang_name = 'ipv6-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__send_default_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'ipv6-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_send_default_route(self):
    """
    Getter method for send_default_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_unicast/send_default_route (boolean)

    YANG Description: If set to true, send the default-route to the neighbour(s)
    """
    return self.__send_default_route
      
  def _set_send_default_route(self, v, load=False):
    """
    Setter method for send_default_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_unicast/send_default_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_default_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_default_route() directly.

    YANG Description: If set to true, send the default-route to the neighbour(s)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_default_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__send_default_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_default_route(self):
    self.__send_default_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_unicast_prefix_limit
  send_default_route = __builtin__.property(_get_send_default_route, _set_send_default_route)


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ('send_default_route', send_default_route), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/ipv4-labeled-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'ipv4-labeled-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_labeled_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/ipv4-labeled-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv4 Labeled Unicast configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'ipv4-labeled-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'ipv4-labeled-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/ipv6-labeled-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'ipv6-labeled-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_labeled_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/ipv6-labeled-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv6 Labeled Unicast configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'ipv6-labeled-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'ipv6-labeled-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/l3vpn-ipv4-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'l3vpn-ipv4-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/l3vpn-ipv4-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unicast IPv4 L3VPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l3vpn-ipv4-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'l3vpn-ipv4-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/l3vpn-ipv6-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'l3vpn-ipv6-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/l3vpn-ipv6-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unicast IPv6 L3VPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l3vpn-ipv6-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'l3vpn-ipv6-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/l3vpn-ipv4-multicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'l3vpn-ipv4-multicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_multicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/l3vpn-ipv4-multicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multicast IPv4 L3VPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l3vpn-ipv4-multicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'l3vpn-ipv4-multicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/l3vpn-ipv6-multicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'l3vpn-ipv6-multicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_multicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/l3vpn-ipv6-multicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multicast IPv6 L3VPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l3vpn-ipv6-multicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'l3vpn-ipv6-multicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_vpls_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/l2vpn-vpls/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'l2vpn-vpls', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_vpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/l2vpn-vpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BGP-signalled VPLS configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l2vpn-vpls'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_vpls_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'l2vpn-vpls']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_vpls/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_vpls/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_vpls_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_vpls_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_vpls_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_vpls_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_evpn_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/l2vpn-evpn/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'l2vpn-evpn', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_evpn(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi/l2vpn-evpn. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BGP EVPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l2vpn-evpn'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_evpn_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi', 'l2vpn-evpn']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_evpn/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_evpn/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_evpn_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_evpn_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_evpn_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_evpn_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis/afi-safi. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: AFI,SAFI configuration available for the
neighbour or group
  """
  __slots__ = ('_path_helper', '_extmethods', '__afi_safi_name','__enabled','__total_paths','__total_prefixes','__graceful_restart','__route_selection_options','__use_multiple_paths','__apply_policy','__ipv4_unicast','__ipv6_unicast','__ipv4_labeled_unicast','__ipv6_labeled_unicast','__l3vpn_ipv4_unicast','__l3vpn_ipv6_unicast','__l3vpn_ipv4_multicast','__l3vpn_ipv6_multicast','__l2vpn_vpls','__l2vpn_evpn',)

  _yang_name = 'afi-safi'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afi_safi_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__total_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__total_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__graceful_restart = YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__route_selection_options = YANGDynClass(base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__use_multiple_paths = YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__apply_policy = YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ipv4_unicast = YANGDynClass(base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ipv6_unicast = YANGDynClass(base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ipv4_labeled_unicast = YANGDynClass(base=yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_labeled_unicast, is_container='container', yang_name="ipv4-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ipv6_labeled_unicast = YANGDynClass(base=yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_labeled_unicast, is_container='container', yang_name="ipv6-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l3vpn_ipv4_unicast = YANGDynClass(base=yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_unicast, is_container='container', yang_name="l3vpn-ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l3vpn_ipv6_unicast = YANGDynClass(base=yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_unicast, is_container='container', yang_name="l3vpn-ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l3vpn_ipv4_multicast = YANGDynClass(base=yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_multicast, is_container='container', yang_name="l3vpn-ipv4-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l3vpn_ipv6_multicast = YANGDynClass(base=yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_multicast, is_container='container', yang_name="l3vpn-ipv6-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l2vpn_vpls = YANGDynClass(base=yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_vpls, is_container='container', yang_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l2vpn_evpn = YANGDynClass(base=yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_evpn, is_container='container', yang_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis', 'afi-safi']

  def _get_afi_safi_name(self):
    """
    Getter method for afi_safi_name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/afi_safi_name (identityref)

    YANG Description: AFI,SAFI
    """
    return self.__afi_safi_name
      
  def _set_afi_safi_name(self, v, load=False):
    """
    Setter method for afi_safi_name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/afi_safi_name (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safi_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safi_name() directly.

    YANG Description: AFI,SAFI
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safi_name must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=True)""",
        })

    self.__afi_safi_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safi_name(self):
    self.__afi_safi_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/enabled (boolean)

    YANG Description: This leaf indicates whether the IPv4 Unicast AFI,SAFI is
enabled for the neighbour or group
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf indicates whether the IPv4 Unicast AFI,SAFI is
enabled for the neighbour or group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_total_paths(self):
    """
    Getter method for total_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/total_paths (uint32)

    YANG Description: Total number of BGP paths within the context
    """
    return self.__total_paths
      
  def _set_total_paths(self, v, load=False):
    """
    Setter method for total_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/total_paths (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_paths() directly.

    YANG Description: Total number of BGP paths within the context
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_paths must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__total_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_paths(self):
    self.__total_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_total_prefixes(self):
    """
    Getter method for total_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/total_prefixes (uint32)

    YANG Description: Total number of BGP prefixes received within the context
    """
    return self.__total_prefixes
      
  def _set_total_prefixes(self, v, load=False):
    """
    Setter method for total_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/total_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_prefixes() directly.

    YANG Description: Total number of BGP prefixes received within the context
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__total_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_prefixes(self):
    self.__total_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/graceful_restart (container)

    YANG Description: Parameters relating to BGP graceful-restart
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: Parameters relating to BGP graceful-restart
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_route_selection_options(self):
    """
    Getter method for route_selection_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options (container)

    YANG Description: Parameters relating to options for route selection
    """
    return self.__route_selection_options
      
  def _set_route_selection_options(self, v, load=False):
    """
    Setter method for route_selection_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/route_selection_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_selection_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_selection_options() directly.

    YANG Description: Parameters relating to options for route selection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_selection_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_selection_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_selection_options(self):
    self.__route_selection_options = YANGDynClass(base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_use_multiple_paths(self):
    """
    Getter method for use_multiple_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths (container)

    YANG Description: Parameters related to the use of multiple paths for the
same NLRI
    """
    return self.__use_multiple_paths
      
  def _set_use_multiple_paths(self, v, load=False):
    """
    Setter method for use_multiple_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/use_multiple_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_multiple_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_multiple_paths() directly.

    YANG Description: Parameters related to the use of multiple paths for the
same NLRI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_multiple_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__use_multiple_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_multiple_paths(self):
    self.__use_multiple_paths = YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_apply_policy(self):
    """
    Getter method for apply_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/apply_policy (container)

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    return self.__apply_policy
      
  def _set_apply_policy(self, v, load=False):
    """
    Setter method for apply_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/apply_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_policy() directly.

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__apply_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_policy(self):
    self.__apply_policy = YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ipv4_unicast(self):
    """
    Getter method for ipv4_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_unicast (container)

    YANG Description: IPv4 unicast configuration options
    """
    return self.__ipv4_unicast
      
  def _set_ipv4_unicast(self, v, load=False):
    """
    Setter method for ipv4_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_unicast() directly.

    YANG Description: IPv4 unicast configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ipv4_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_unicast(self):
    self.__ipv4_unicast = YANGDynClass(base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ipv6_unicast(self):
    """
    Getter method for ipv6_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_unicast (container)

    YANG Description: IPv6 unicast configuration options
    """
    return self.__ipv6_unicast
      
  def _set_ipv6_unicast(self, v, load=False):
    """
    Setter method for ipv6_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_unicast() directly.

    YANG Description: IPv6 unicast configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ipv6_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_unicast(self):
    self.__ipv6_unicast = YANGDynClass(base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ipv4_labeled_unicast(self):
    """
    Getter method for ipv4_labeled_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_labeled_unicast (container)

    YANG Description: IPv4 Labeled Unicast configuration options
    """
    return self.__ipv4_labeled_unicast
      
  def _set_ipv4_labeled_unicast(self, v, load=False):
    """
    Setter method for ipv4_labeled_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv4_labeled_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_labeled_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_labeled_unicast() directly.

    YANG Description: IPv4 Labeled Unicast configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_labeled_unicast, is_container='container', yang_name="ipv4-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_labeled_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_labeled_unicast, is_container='container', yang_name="ipv4-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ipv4_labeled_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_labeled_unicast(self):
    self.__ipv4_labeled_unicast = YANGDynClass(base=yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_labeled_unicast, is_container='container', yang_name="ipv4-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ipv6_labeled_unicast(self):
    """
    Getter method for ipv6_labeled_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_labeled_unicast (container)

    YANG Description: IPv6 Labeled Unicast configuration options
    """
    return self.__ipv6_labeled_unicast
      
  def _set_ipv6_labeled_unicast(self, v, load=False):
    """
    Setter method for ipv6_labeled_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/ipv6_labeled_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_labeled_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_labeled_unicast() directly.

    YANG Description: IPv6 Labeled Unicast configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_labeled_unicast, is_container='container', yang_name="ipv6-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_labeled_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_labeled_unicast, is_container='container', yang_name="ipv6-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ipv6_labeled_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_labeled_unicast(self):
    self.__ipv6_labeled_unicast = YANGDynClass(base=yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_labeled_unicast, is_container='container', yang_name="ipv6-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l3vpn_ipv4_unicast(self):
    """
    Getter method for l3vpn_ipv4_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_unicast (container)

    YANG Description: Unicast IPv4 L3VPN configuration options
    """
    return self.__l3vpn_ipv4_unicast
      
  def _set_l3vpn_ipv4_unicast(self, v, load=False):
    """
    Setter method for l3vpn_ipv4_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3vpn_ipv4_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3vpn_ipv4_unicast() directly.

    YANG Description: Unicast IPv4 L3VPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_unicast, is_container='container', yang_name="l3vpn-ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3vpn_ipv4_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_unicast, is_container='container', yang_name="l3vpn-ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l3vpn_ipv4_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3vpn_ipv4_unicast(self):
    self.__l3vpn_ipv4_unicast = YANGDynClass(base=yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_unicast, is_container='container', yang_name="l3vpn-ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l3vpn_ipv6_unicast(self):
    """
    Getter method for l3vpn_ipv6_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_unicast (container)

    YANG Description: Unicast IPv6 L3VPN configuration options
    """
    return self.__l3vpn_ipv6_unicast
      
  def _set_l3vpn_ipv6_unicast(self, v, load=False):
    """
    Setter method for l3vpn_ipv6_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3vpn_ipv6_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3vpn_ipv6_unicast() directly.

    YANG Description: Unicast IPv6 L3VPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_unicast, is_container='container', yang_name="l3vpn-ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3vpn_ipv6_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_unicast, is_container='container', yang_name="l3vpn-ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l3vpn_ipv6_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3vpn_ipv6_unicast(self):
    self.__l3vpn_ipv6_unicast = YANGDynClass(base=yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_unicast, is_container='container', yang_name="l3vpn-ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l3vpn_ipv4_multicast(self):
    """
    Getter method for l3vpn_ipv4_multicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_multicast (container)

    YANG Description: Multicast IPv4 L3VPN configuration options
    """
    return self.__l3vpn_ipv4_multicast
      
  def _set_l3vpn_ipv4_multicast(self, v, load=False):
    """
    Setter method for l3vpn_ipv4_multicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv4_multicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3vpn_ipv4_multicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3vpn_ipv4_multicast() directly.

    YANG Description: Multicast IPv4 L3VPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_multicast, is_container='container', yang_name="l3vpn-ipv4-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3vpn_ipv4_multicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_multicast, is_container='container', yang_name="l3vpn-ipv4-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l3vpn_ipv4_multicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3vpn_ipv4_multicast(self):
    self.__l3vpn_ipv4_multicast = YANGDynClass(base=yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_multicast, is_container='container', yang_name="l3vpn-ipv4-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l3vpn_ipv6_multicast(self):
    """
    Getter method for l3vpn_ipv6_multicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_multicast (container)

    YANG Description: Multicast IPv6 L3VPN configuration options
    """
    return self.__l3vpn_ipv6_multicast
      
  def _set_l3vpn_ipv6_multicast(self, v, load=False):
    """
    Setter method for l3vpn_ipv6_multicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l3vpn_ipv6_multicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3vpn_ipv6_multicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3vpn_ipv6_multicast() directly.

    YANG Description: Multicast IPv6 L3VPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_multicast, is_container='container', yang_name="l3vpn-ipv6-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3vpn_ipv6_multicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_multicast, is_container='container', yang_name="l3vpn-ipv6-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l3vpn_ipv6_multicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3vpn_ipv6_multicast(self):
    self.__l3vpn_ipv6_multicast = YANGDynClass(base=yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_multicast, is_container='container', yang_name="l3vpn-ipv6-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l2vpn_vpls(self):
    """
    Getter method for l2vpn_vpls, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_vpls (container)

    YANG Description: BGP-signalled VPLS configuration options
    """
    return self.__l2vpn_vpls
      
  def _set_l2vpn_vpls(self, v, load=False):
    """
    Setter method for l2vpn_vpls, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_vpls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2vpn_vpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2vpn_vpls() directly.

    YANG Description: BGP-signalled VPLS configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_vpls, is_container='container', yang_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2vpn_vpls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_vpls, is_container='container', yang_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l2vpn_vpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2vpn_vpls(self):
    self.__l2vpn_vpls = YANGDynClass(base=yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_vpls, is_container='container', yang_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l2vpn_evpn(self):
    """
    Getter method for l2vpn_evpn, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_evpn (container)

    YANG Description: BGP EVPN configuration options
    """
    return self.__l2vpn_evpn
      
  def _set_l2vpn_evpn(self, v, load=False):
    """
    Setter method for l2vpn_evpn, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi/l2vpn_evpn (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2vpn_evpn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2vpn_evpn() directly.

    YANG Description: BGP EVPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_evpn, is_container='container', yang_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2vpn_evpn must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_evpn, is_container='container', yang_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l2vpn_evpn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2vpn_evpn(self):
    self.__l2vpn_evpn = YANGDynClass(base=yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_evpn, is_container='container', yang_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  afi_safi_name = __builtin__.property(_get_afi_safi_name, _set_afi_safi_name)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  total_paths = __builtin__.property(_get_total_paths)
  total_prefixes = __builtin__.property(_get_total_prefixes)
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart) # type: yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_graceful_restart
  route_selection_options = __builtin__.property(_get_route_selection_options, _set_route_selection_options) # type: yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_route_selection_options
  use_multiple_paths = __builtin__.property(_get_use_multiple_paths, _set_use_multiple_paths) # type: yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_use_multiple_paths
  apply_policy = __builtin__.property(_get_apply_policy, _set_apply_policy) # type: yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_apply_policy
  ipv4_unicast = __builtin__.property(_get_ipv4_unicast, _set_ipv4_unicast) # type: yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_unicast
  ipv6_unicast = __builtin__.property(_get_ipv6_unicast, _set_ipv6_unicast) # type: yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_unicast
  ipv4_labeled_unicast = __builtin__.property(_get_ipv4_labeled_unicast, _set_ipv4_labeled_unicast) # type: yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv4_labeled_unicast
  ipv6_labeled_unicast = __builtin__.property(_get_ipv6_labeled_unicast, _set_ipv6_labeled_unicast) # type: yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_ipv6_labeled_unicast
  l3vpn_ipv4_unicast = __builtin__.property(_get_l3vpn_ipv4_unicast, _set_l3vpn_ipv4_unicast) # type: yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_unicast
  l3vpn_ipv6_unicast = __builtin__.property(_get_l3vpn_ipv6_unicast, _set_l3vpn_ipv6_unicast) # type: yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_unicast
  l3vpn_ipv4_multicast = __builtin__.property(_get_l3vpn_ipv4_multicast, _set_l3vpn_ipv4_multicast) # type: yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv4_multicast
  l3vpn_ipv6_multicast = __builtin__.property(_get_l3vpn_ipv6_multicast, _set_l3vpn_ipv6_multicast) # type: yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l3vpn_ipv6_multicast
  l2vpn_vpls = __builtin__.property(_get_l2vpn_vpls, _set_l2vpn_vpls) # type: yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_vpls
  l2vpn_evpn = __builtin__.property(_get_l2vpn_evpn, _set_l2vpn_evpn) # type: yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi_l2vpn_evpn


  _pyangbind_elements = OrderedDict([('afi_safi_name', afi_safi_name), ('enabled', enabled), ('total_paths', total_paths), ('total_prefixes', total_prefixes), ('graceful_restart', graceful_restart), ('route_selection_options', route_selection_options), ('use_multiple_paths', use_multiple_paths), ('apply_policy', apply_policy), ('ipv4_unicast', ipv4_unicast), ('ipv6_unicast', ipv6_unicast), ('ipv4_labeled_unicast', ipv4_labeled_unicast), ('ipv6_labeled_unicast', ipv6_labeled_unicast), ('l3vpn_ipv4_unicast', l3vpn_ipv4_unicast), ('l3vpn_ipv6_unicast', l3vpn_ipv6_unicast), ('l3vpn_ipv4_multicast', l3vpn_ipv4_multicast), ('l3vpn_ipv6_multicast', l3vpn_ipv6_multicast), ('l2vpn_vpls', l2vpn_vpls), ('l2vpn_evpn', l2vpn_evpn), ])


class yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/afi-safis. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of address-families associated with the BGP
instance
  """
  __slots__ = ('_path_helper', '_extmethods', '__afi_safi',)

  _yang_name = 'afi-safis'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afi_safi = YANGDynClass(base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'afi-safis']

  def _get_afi_safi(self):
    """
    Getter method for afi_safi, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi (list)

    YANG Description: AFI,SAFI configuration available for the
neighbour or group
    """
    return self.__afi_safi
      
  def _set_afi_safi(self, v, load=False):
    """
    Setter method for afi_safi, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis/afi_safi (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safi() directly.

    YANG Description: AFI,SAFI configuration available for the
neighbour or group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safi must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)""",
        })

    self.__afi_safi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safi(self):
    self.__afi_safi = YANGDynClass(base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)

  afi_safi = __builtin__.property(_get_afi_safi, _set_afi_safi) # type: yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis_afi_safi


  _pyangbind_elements = OrderedDict([('afi_safi', afi_safi), ])


class yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_apply_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global/apply-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
  """
  __slots__ = ('_path_helper', '_extmethods', '__import_policy','__default_import_policy','__export_policy','__default_export_policy',)

  _yang_name = 'apply-policy'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__import_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__default_import_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    self.__export_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__default_export_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global', 'apply-policy']

  def _get_import_policy(self):
    """
    Getter method for import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/apply_policy/import_policy (leafref)

    YANG Description: List of policy names in sequence to be applied on
receiving redistributed routes from another routing protocol
or receiving a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    return self.__import_policy
      
  def _set_import_policy(self, v, load=False):
    """
    Setter method for import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/apply_policy/import_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_policy() directly.

    YANG Description: List of policy names in sequence to be applied on
receiving redistributed routes from another routing protocol
or receiving a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_policy(self):
    self.__import_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_default_import_policy(self):
    """
    Getter method for default_import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/apply_policy/default_import_policy (default-policy-type)

    YANG Description: Explicitly set a default policy if no policy definition
in the import policy chain is satisfied.
    """
    return self.__default_import_policy
      
  def _set_default_import_policy(self, v, load=False):
    """
    Setter method for default_import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/apply_policy/default_import_policy (default-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_import_policy() directly.

    YANG Description: Explicitly set a default policy if no policy definition
in the import policy chain is satisfied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_import_policy must be of a type compatible with default-policy-type""",
          'defined-type': "ietf-bgp:default-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)""",
        })

    self.__default_import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_import_policy(self):
    self.__default_import_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)


  def _get_export_policy(self):
    """
    Getter method for export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/apply_policy/export_policy (leafref)

    YANG Description: List of policy names in sequence to be applied on
redistributing routes from one routing protocol to another
or sending a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    return self.__export_policy
      
  def _set_export_policy(self, v, load=False):
    """
    Setter method for export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/apply_policy/export_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_export_policy() directly.

    YANG Description: List of policy names in sequence to be applied on
redistributing routes from one routing protocol to another
or sending a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """export_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_export_policy(self):
    self.__export_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_default_export_policy(self):
    """
    Getter method for default_export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/apply_policy/default_export_policy (default-policy-type)

    YANG Description: Explicitly set a default policy if no policy definition
in the export policy chain is satisfied.
    """
    return self.__default_export_policy
      
  def _set_default_export_policy(self, v, load=False):
    """
    Setter method for default_export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/apply_policy/default_export_policy (default-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_export_policy() directly.

    YANG Description: Explicitly set a default policy if no policy definition
in the export policy chain is satisfied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_export_policy must be of a type compatible with default-policy-type""",
          'defined-type': "ietf-bgp:default-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)""",
        })

    self.__default_export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_export_policy(self):
    self.__default_export_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)

  import_policy = __builtin__.property(_get_import_policy, _set_import_policy)
  default_import_policy = __builtin__.property(_get_default_import_policy, _set_default_import_policy)
  export_policy = __builtin__.property(_get_export_policy, _set_export_policy)
  default_export_policy = __builtin__.property(_get_default_export_policy, _set_default_export_policy)


  _pyangbind_elements = OrderedDict([('import_policy', import_policy), ('default_import_policy', default_import_policy), ('export_policy', export_policy), ('default_export_policy', default_export_policy), ])


class yc_global__ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Global configuration for the BGP router
  """
  __slots__ = ('_path_helper', '_extmethods', '__as_','__identifier','__distance','__confederation','__graceful_restart','__use_multiple_paths','__route_selection_options','__afi_safis','__apply_policy','__total_paths','__total_prefixes',)

  _yang_name = 'global'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__as_ = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    self.__identifier = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=True)
    self.__distance = YANGDynClass(base=yc_distance_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_distance, is_container='container', yang_name="distance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__confederation = YANGDynClass(base=yc_confederation_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_confederation, is_container='container', yang_name="confederation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__graceful_restart = YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__use_multiple_paths = YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__route_selection_options = YANGDynClass(base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__afi_safis = YANGDynClass(base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__apply_policy = YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__total_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__total_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'global']

  def _get_as_(self):
    """
    Getter method for as_, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/as (inet:as-number)

    YANG Description: Local autonomous system number of the router.  Uses
the 32-bit as-number type from the model in RFC 6991.
    """
    return self.__as_
      
  def _set_as_(self, v, load=False):
    """
    Setter method for as_, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/as (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_() directly.

    YANG Description: Local autonomous system number of the router.  Uses
the 32-bit as-number type from the model in RFC 6991.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_ must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)""",
        })

    self.__as_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_(self):
    self.__as_ = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)


  def _get_identifier(self):
    """
    Getter method for identifier, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/identifier (yang:dotted-quad)

    YANG Description: BGP Identifier of the router - an unsigned 32-bit,
non-zero integer that should be unique within an AS.
The value of the BGP Identifier for a BGP speaker is
determined upon startup and is the same for every local
interface and BGP peer.
    """
    return self.__identifier
      
  def _set_identifier(self, v, load=False):
    """
    Setter method for identifier, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/identifier (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_identifier() directly.

    YANG Description: BGP Identifier of the router - an unsigned 32-bit,
non-zero integer that should be unique within an AS.
The value of the BGP Identifier for a BGP speaker is
determined upon startup and is the same for every local
interface and BGP peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """identifier must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=True)""",
        })

    self.__identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_identifier(self):
    self.__identifier = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=True)


  def _get_distance(self):
    """
    Getter method for distance, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/distance (container)

    YANG Description: Administrative distance (or preference) assigned to
routes received from different sources
(external, internal, and local).
    """
    return self.__distance
      
  def _set_distance(self, v, load=False):
    """
    Setter method for distance, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/distance (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_distance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_distance() directly.

    YANG Description: Administrative distance (or preference) assigned to
routes received from different sources
(external, internal, and local).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_distance_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_distance, is_container='container', yang_name="distance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """distance must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_distance_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_distance, is_container='container', yang_name="distance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__distance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_distance(self):
    self.__distance = YANGDynClass(base=yc_distance_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_distance, is_container='container', yang_name="distance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_confederation(self):
    """
    Getter method for confederation, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/confederation (container)

    YANG Description: Configuration options specifying parameters when the
local router is within an autonomous system which is
part of a BGP confederation.
    """
    return self.__confederation
      
  def _set_confederation(self, v, load=False):
    """
    Setter method for confederation, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/confederation (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_confederation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_confederation() directly.

    YANG Description: Configuration options specifying parameters when the
local router is within an autonomous system which is
part of a BGP confederation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_confederation_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_confederation, is_container='container', yang_name="confederation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """confederation must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_confederation_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_confederation, is_container='container', yang_name="confederation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__confederation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_confederation(self):
    self.__confederation = YANGDynClass(base=yc_confederation_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_confederation, is_container='container', yang_name="confederation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/graceful_restart (container)

    YANG Description: Parameters relating the graceful restart mechanism for
BGP
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: Parameters relating the graceful restart mechanism for
BGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_use_multiple_paths(self):
    """
    Getter method for use_multiple_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/use_multiple_paths (container)

    YANG Description: Parameters related to the use of multiple paths for the
same NLRI
    """
    return self.__use_multiple_paths
      
  def _set_use_multiple_paths(self, v, load=False):
    """
    Setter method for use_multiple_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/use_multiple_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_multiple_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_multiple_paths() directly.

    YANG Description: Parameters related to the use of multiple paths for the
same NLRI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_multiple_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__use_multiple_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_multiple_paths(self):
    self.__use_multiple_paths = YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_route_selection_options(self):
    """
    Getter method for route_selection_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options (container)

    YANG Description: Parameters relating to options for route selection
    """
    return self.__route_selection_options
      
  def _set_route_selection_options(self, v, load=False):
    """
    Setter method for route_selection_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/route_selection_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_selection_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_selection_options() directly.

    YANG Description: Parameters relating to options for route selection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_selection_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_selection_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_selection_options(self):
    self.__route_selection_options = YANGDynClass(base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_afi_safis(self):
    """
    Getter method for afi_safis, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis (container)

    YANG Description: List of address-families associated with the BGP
instance
    """
    return self.__afi_safis
      
  def _set_afi_safis(self, v, load=False):
    """
    Setter method for afi_safis, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/afi_safis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safis() directly.

    YANG Description: List of address-families associated with the BGP
instance
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__afi_safis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safis(self):
    self.__afi_safis = YANGDynClass(base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_apply_policy(self):
    """
    Getter method for apply_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/apply_policy (container)

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    return self.__apply_policy
      
  def _set_apply_policy(self, v, load=False):
    """
    Setter method for apply_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/apply_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_policy() directly.

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__apply_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_policy(self):
    self.__apply_policy = YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_total_paths(self):
    """
    Getter method for total_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/total_paths (uint32)

    YANG Description: Total number of BGP paths within the context
    """
    return self.__total_paths
      
  def _set_total_paths(self, v, load=False):
    """
    Setter method for total_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/total_paths (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_paths() directly.

    YANG Description: Total number of BGP paths within the context
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_paths must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__total_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_paths(self):
    self.__total_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_total_prefixes(self):
    """
    Getter method for total_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/total_prefixes (uint32)

    YANG Description: Total number of BGP prefixes received within the context
    """
    return self.__total_prefixes
      
  def _set_total_prefixes(self, v, load=False):
    """
    Setter method for total_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global/total_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_total_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_total_prefixes() directly.

    YANG Description: Total number of BGP prefixes received within the context
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """total_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__total_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_total_prefixes(self):
    self.__total_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="total-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)

  as_ = __builtin__.property(_get_as_, _set_as_)
  identifier = __builtin__.property(_get_identifier, _set_identifier)
  distance = __builtin__.property(_get_distance, _set_distance) # type: yc_distance_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_distance
  confederation = __builtin__.property(_get_confederation, _set_confederation) # type: yc_confederation_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_confederation
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart) # type: yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_graceful_restart
  use_multiple_paths = __builtin__.property(_get_use_multiple_paths, _set_use_multiple_paths) # type: yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_use_multiple_paths
  route_selection_options = __builtin__.property(_get_route_selection_options, _set_route_selection_options) # type: yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_route_selection_options
  afi_safis = __builtin__.property(_get_afi_safis, _set_afi_safis) # type: yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_afi_safis
  apply_policy = __builtin__.property(_get_apply_policy, _set_apply_policy) # type: yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global_apply_policy
  total_paths = __builtin__.property(_get_total_paths)
  total_prefixes = __builtin__.property(_get_total_prefixes)


  _pyangbind_elements = OrderedDict([('as_', as_), ('identifier', identifier), ('distance', distance), ('confederation', confederation), ('graceful_restart', graceful_restart), ('use_multiple_paths', use_multiple_paths), ('route_selection_options', route_selection_options), ('afi_safis', afi_safis), ('apply_policy', apply_policy), ('total_paths', total_paths), ('total_prefixes', total_prefixes), ])


class yc_secure_session_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_secure_session(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/secure-session. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for describing how a particular BGP session
is to be secured.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable_ao','__send_id','__recv_id','__include_tcp_options','__accept_ao_mismatch','__ao_keychain','__enable_md5','__md5_keychain','__sa',)

  _yang_name = 'secure-session'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable_ao = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-ao", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__send_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="send-id", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    self.__recv_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="recv-id", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    self.__include_tcp_options = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="include-tcp-options", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__accept_ao_mismatch = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="accept-ao-mismatch", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ao_keychain = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ao-keychain", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='kc:key-chain-ref', is_config=True)
    self.__enable_md5 = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-md5", parent=self, choice=('option', 'md5'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__md5_keychain = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="md5-keychain", parent=self, choice=('option', 'md5'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='kc:key-chain-ref', is_config=True)
    self.__sa = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sa", parent=self, choice=('option', 'ipsec'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'secure-session']

  def _get_enable_ao(self):
    """
    Getter method for enable_ao, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/enable_ao (boolean)

    YANG Description: Enable support of TCP-Authentication Option (TCP-AO).
    """
    return self.__enable_ao
      
  def _set_enable_ao(self, v, load=False):
    """
    Setter method for enable_ao, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/enable_ao (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_ao is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_ao() directly.

    YANG Description: Enable support of TCP-Authentication Option (TCP-AO).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-ao", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_ao must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-ao", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enable_ao = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_ao(self):
    self.__enable_ao = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-ao", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_send_id(self):
    """
    Getter method for send_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/send_id (uint8)

    YANG Description: The SendID is inserted as the KeyID of the TCP-AO option
of outgoing segments.
    """
    return self.__send_id
      
  def _set_send_id(self, v, load=False):
    """
    Setter method for send_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/send_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_id() directly.

    YANG Description: The SendID is inserted as the KeyID of the TCP-AO option
of outgoing segments.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="send-id", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="send-id", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__send_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_id(self):
    self.__send_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="send-id", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)


  def _get_recv_id(self):
    """
    Getter method for recv_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/recv_id (uint8)

    YANG Description: The RecvID is matched against the TCP-AO KeyID of incoming
segments.
    """
    return self.__recv_id
      
  def _set_recv_id(self, v, load=False):
    """
    Setter method for recv_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/recv_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_recv_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_recv_id() directly.

    YANG Description: The RecvID is matched against the TCP-AO KeyID of incoming
segments.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="recv-id", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """recv_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="recv-id", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__recv_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_recv_id(self):
    self.__recv_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="recv-id", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)


  def _get_include_tcp_options(self):
    """
    Getter method for include_tcp_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/include_tcp_options (boolean)

    YANG Description: Include TCP options in HMAC calculation.
    """
    return self.__include_tcp_options
      
  def _set_include_tcp_options(self, v, load=False):
    """
    Setter method for include_tcp_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/include_tcp_options (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_tcp_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_tcp_options() directly.

    YANG Description: Include TCP options in HMAC calculation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="include-tcp-options", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_tcp_options must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="include-tcp-options", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__include_tcp_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_tcp_options(self):
    self.__include_tcp_options = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="include-tcp-options", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_accept_ao_mismatch(self):
    """
    Getter method for accept_ao_mismatch, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/accept_ao_mismatch (boolean)

    YANG Description: Accept packets with HMAC mismatch.
    """
    return self.__accept_ao_mismatch
      
  def _set_accept_ao_mismatch(self, v, load=False):
    """
    Setter method for accept_ao_mismatch, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/accept_ao_mismatch (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_accept_ao_mismatch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_accept_ao_mismatch() directly.

    YANG Description: Accept packets with HMAC mismatch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="accept-ao-mismatch", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """accept_ao_mismatch must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="accept-ao-mismatch", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__accept_ao_mismatch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_accept_ao_mismatch(self):
    self.__accept_ao_mismatch = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="accept-ao-mismatch", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ao_keychain(self):
    """
    Getter method for ao_keychain, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/ao_keychain (kc:key-chain-ref)

    YANG Description: Reference to the key chain that will be used by
this model. Applicable for TCP-AO and TCP-MD5
only
    """
    return self.__ao_keychain
      
  def _set_ao_keychain(self, v, load=False):
    """
    Setter method for ao_keychain, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/ao_keychain (kc:key-chain-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ao_keychain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ao_keychain() directly.

    YANG Description: Reference to the key chain that will be used by
this model. Applicable for TCP-AO and TCP-MD5
only
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ao-keychain", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='kc:key-chain-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ao_keychain must be of a type compatible with kc:key-chain-ref""",
          'defined-type': "kc:key-chain-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ao-keychain", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='kc:key-chain-ref', is_config=True)""",
        })

    self.__ao_keychain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ao_keychain(self):
    self.__ao_keychain = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ao-keychain", parent=self, choice=('option', 'ao'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='kc:key-chain-ref', is_config=True)


  def _get_enable_md5(self):
    """
    Getter method for enable_md5, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/enable_md5 (boolean)

    YANG Description: Enable support of MD5 to authenticate a TCP session.
    """
    return self.__enable_md5
      
  def _set_enable_md5(self, v, load=False):
    """
    Setter method for enable_md5, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/enable_md5 (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_md5 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_md5() directly.

    YANG Description: Enable support of MD5 to authenticate a TCP session.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-md5", parent=self, choice=('option', 'md5'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_md5 must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-md5", parent=self, choice=('option', 'md5'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enable_md5 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_md5(self):
    self.__enable_md5 = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-md5", parent=self, choice=('option', 'md5'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_md5_keychain(self):
    """
    Getter method for md5_keychain, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/md5_keychain (kc:key-chain-ref)

    YANG Description: Reference to the key chain that will be used by
this model. Applicable for TCP-AO and TCP-MD5
only
    """
    return self.__md5_keychain
      
  def _set_md5_keychain(self, v, load=False):
    """
    Setter method for md5_keychain, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/md5_keychain (kc:key-chain-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_md5_keychain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_md5_keychain() directly.

    YANG Description: Reference to the key chain that will be used by
this model. Applicable for TCP-AO and TCP-MD5
only
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="md5-keychain", parent=self, choice=('option', 'md5'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='kc:key-chain-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """md5_keychain must be of a type compatible with kc:key-chain-ref""",
          'defined-type': "kc:key-chain-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="md5-keychain", parent=self, choice=('option', 'md5'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='kc:key-chain-ref', is_config=True)""",
        })

    self.__md5_keychain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_md5_keychain(self):
    self.__md5_keychain = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="md5-keychain", parent=self, choice=('option', 'md5'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='kc:key-chain-ref', is_config=True)


  def _get_sa(self):
    """
    Getter method for sa, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/sa (string)

    YANG Description: Security Association (SA) name.
    """
    return self.__sa
      
  def _set_sa(self, v, load=False):
    """
    Setter method for sa, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session/sa (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sa() directly.

    YANG Description: Security Association (SA) name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="sa", parent=self, choice=('option', 'ipsec'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sa must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sa", parent=self, choice=('option', 'ipsec'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)""",
        })

    self.__sa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sa(self):
    self.__sa = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sa", parent=self, choice=('option', 'ipsec'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)

  enable_ao = __builtin__.property(_get_enable_ao, _set_enable_ao)
  send_id = __builtin__.property(_get_send_id, _set_send_id)
  recv_id = __builtin__.property(_get_recv_id, _set_recv_id)
  include_tcp_options = __builtin__.property(_get_include_tcp_options, _set_include_tcp_options)
  accept_ao_mismatch = __builtin__.property(_get_accept_ao_mismatch, _set_accept_ao_mismatch)
  ao_keychain = __builtin__.property(_get_ao_keychain, _set_ao_keychain)
  enable_md5 = __builtin__.property(_get_enable_md5, _set_enable_md5)
  md5_keychain = __builtin__.property(_get_md5_keychain, _set_md5_keychain)
  sa = __builtin__.property(_get_sa, _set_sa)

  __choices__ = {'option': {'ao': ['enable_ao', 'send_id', 'recv_id', 'include_tcp_options', 'accept_ao_mismatch', 'ao_keychain'], 'md5': ['enable_md5', 'md5_keychain'], 'ipsec': ['sa']}}
  _pyangbind_elements = OrderedDict([('enable_ao', enable_ao), ('send_id', send_id), ('recv_id', recv_id), ('include_tcp_options', include_tcp_options), ('accept_ao_mismatch', accept_ao_mismatch), ('ao_keychain', ao_keychain), ('enable_md5', enable_md5), ('md5_keychain', md5_keychain), ('sa', sa), ])


class yc_route_flap_damping_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_flap_damping(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/route-flap-damping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Routes learned via BGP are subject to weighted route
dampening.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__suppress_above','__reuse_above','__max_flap','__reach_decay','__unreach_decay','__keep_history',)

  _yang_name = 'route-flap-damping'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__suppress_above = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(3.0), is_leaf=True, yang_name="suppress-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)
    self.__reuse_above = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(2.0), is_leaf=True, yang_name="reuse-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)
    self.__max_flap = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(16.0), is_leaf=True, yang_name="max-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)
    self.__reach_decay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="reach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)
    self.__unreach_decay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(900), is_leaf=True, yang_name="unreach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)
    self.__keep_history = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1800), is_leaf=True, yang_name="keep-history", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'route-flap-damping']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping/enable (boolean)

    YANG Description: Enable route flap damping.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable route flap damping.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_suppress_above(self):
    """
    Getter method for suppress_above, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping/suppress_above (decimal64)

    YANG Description: This is the value of the instability metric at which
route suppression takes place. A route is not installed
in the forwarding information base (FIB), or announced
even if it is reachable during the period that it is
suppressed.
    """
    return self.__suppress_above
      
  def _set_suppress_above(self, v, load=False):
    """
    Setter method for suppress_above, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping/suppress_above (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_above is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_above() directly.

    YANG Description: This is the value of the instability metric at which
route suppression takes place. A route is not installed
in the forwarding information base (FIB), or announced
even if it is reachable during the period that it is
suppressed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(3.0), is_leaf=True, yang_name="suppress-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_above must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(3.0), is_leaf=True, yang_name="suppress-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)""",
        })

    self.__suppress_above = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_above(self):
    self.__suppress_above = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(3.0), is_leaf=True, yang_name="suppress-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)


  def _get_reuse_above(self):
    """
    Getter method for reuse_above, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping/reuse_above (decimal64)

    YANG Description: This is the value of the instability metric at which a
suppressed route becomes unsuppressed if it is reachable
but currently suppressed. The value assigned to
reuse-below must be less than suppress-above.
    """
    return self.__reuse_above
      
  def _set_reuse_above(self, v, load=False):
    """
    Setter method for reuse_above, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping/reuse_above (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse_above is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse_above() directly.

    YANG Description: This is the value of the instability metric at which a
suppressed route becomes unsuppressed if it is reachable
but currently suppressed. The value assigned to
reuse-below must be less than suppress-above.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(2.0), is_leaf=True, yang_name="reuse-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse_above must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(2.0), is_leaf=True, yang_name="reuse-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)""",
        })

    self.__reuse_above = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse_above(self):
    self.__reuse_above = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(2.0), is_leaf=True, yang_name="reuse-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)


  def _get_max_flap(self):
    """
    Getter method for max_flap, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping/max_flap (decimal64)

    YANG Description: This is the upper limit of the instability metric. This
       value must be greater than the larger of 1 and
       suppress-above.
    """
    return self.__max_flap
      
  def _set_max_flap(self, v, load=False):
    """
    Setter method for max_flap, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping/max_flap (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_flap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_flap() directly.

    YANG Description: This is the upper limit of the instability metric. This
       value must be greater than the larger of 1 and
       suppress-above.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(16.0), is_leaf=True, yang_name="max-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_flap must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(16.0), is_leaf=True, yang_name="max-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)""",
        })

    self.__max_flap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_flap(self):
    self.__max_flap = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(16.0), is_leaf=True, yang_name="max-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)


  def _get_reach_decay(self):
    """
    Getter method for reach_decay, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping/reach_decay (yang:gauge32)

    YANG Description: This value specifies the time desired for the instability
metric value to reach one-half of its current value when
the route is reachable. This half-life value determines
the rate at which the metric value is decayed. A smaller
half-life value makes a suppressed route reusable sooner
than a larger value.
    """
    return self.__reach_decay
      
  def _set_reach_decay(self, v, load=False):
    """
    Setter method for reach_decay, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping/reach_decay (yang:gauge32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reach_decay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reach_decay() directly.

    YANG Description: This value specifies the time desired for the instability
metric value to reach one-half of its current value when
the route is reachable. This half-life value determines
the rate at which the metric value is decayed. A smaller
half-life value makes a suppressed route reusable sooner
than a larger value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="reach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reach_decay must be of a type compatible with yang:gauge32""",
          'defined-type': "yang:gauge32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="reach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)""",
        })

    self.__reach_decay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reach_decay(self):
    self.__reach_decay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="reach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)


  def _get_unreach_decay(self):
    """
    Getter method for unreach_decay, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping/unreach_decay (yang:gauge32)

    YANG Description: This value acts the same as reach-decay except that it
specifies the rate at which the instability metric is
decayed when a route is unreachable. It should have a
value greater than or equal to reach-decay.
    """
    return self.__unreach_decay
      
  def _set_unreach_decay(self, v, load=False):
    """
    Setter method for unreach_decay, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping/unreach_decay (yang:gauge32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unreach_decay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unreach_decay() directly.

    YANG Description: This value acts the same as reach-decay except that it
specifies the rate at which the instability metric is
decayed when a route is unreachable. It should have a
value greater than or equal to reach-decay.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(900), is_leaf=True, yang_name="unreach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unreach_decay must be of a type compatible with yang:gauge32""",
          'defined-type': "yang:gauge32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(900), is_leaf=True, yang_name="unreach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)""",
        })

    self.__unreach_decay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unreach_decay(self):
    self.__unreach_decay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(900), is_leaf=True, yang_name="unreach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)


  def _get_keep_history(self):
    """
    Getter method for keep_history, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping/keep_history (yang:gauge32)

    YANG Description: This value specifies the period over which the route
flapping history is to be maintained for a given route.
The size of the configuration arrays described below is
directly affected by this value.
    """
    return self.__keep_history
      
  def _set_keep_history(self, v, load=False):
    """
    Setter method for keep_history, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping/keep_history (yang:gauge32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keep_history is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keep_history() directly.

    YANG Description: This value specifies the period over which the route
flapping history is to be maintained for a given route.
The size of the configuration arrays described below is
directly affected by this value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1800), is_leaf=True, yang_name="keep-history", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keep_history must be of a type compatible with yang:gauge32""",
          'defined-type': "yang:gauge32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1800), is_leaf=True, yang_name="keep-history", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)""",
        })

    self.__keep_history = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keep_history(self):
    self.__keep_history = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1800), is_leaf=True, yang_name="keep-history", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  suppress_above = __builtin__.property(_get_suppress_above, _set_suppress_above)
  reuse_above = __builtin__.property(_get_reuse_above, _set_reuse_above)
  max_flap = __builtin__.property(_get_max_flap, _set_max_flap)
  reach_decay = __builtin__.property(_get_reach_decay, _set_reach_decay)
  unreach_decay = __builtin__.property(_get_unreach_decay, _set_unreach_decay)
  keep_history = __builtin__.property(_get_keep_history, _set_keep_history)


  _pyangbind_elements = OrderedDict([('enable', enable), ('suppress_above', suppress_above), ('reuse_above', reuse_above), ('max_flap', max_flap), ('reach_decay', reach_decay), ('unreach_decay', unreach_decay), ('keep_history', keep_history), ])


class yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_selection_options(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/route-selection-options. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to options for route selection
  """
  __slots__ = ('_path_helper', '_extmethods', '__always_compare_med','__ignore_as_path_length','__external_compare_router_id','__advertise_inactive_routes','__enable_aigp','__ignore_next_hop_igp_metric','__enable_med',)

  _yang_name = 'route-selection-options'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__always_compare_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ignore_as_path_length = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__external_compare_router_id = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__advertise_inactive_routes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__enable_aigp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ignore_next_hop_igp_metric = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__enable_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'route-selection-options']

  def _get_always_compare_med(self):
    """
    Getter method for always_compare_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options/always_compare_med (boolean)

    YANG Description: Compare multi-exit discriminator (MED) value from
different ASes when selecting the best route.  The default
behavior is to only compare MEDs for paths received from
the same AS.
    """
    return self.__always_compare_med
      
  def _set_always_compare_med(self, v, load=False):
    """
    Setter method for always_compare_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options/always_compare_med (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_always_compare_med is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_always_compare_med() directly.

    YANG Description: Compare multi-exit discriminator (MED) value from
different ASes when selecting the best route.  The default
behavior is to only compare MEDs for paths received from
the same AS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """always_compare_med must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__always_compare_med = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_always_compare_med(self):
    self.__always_compare_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ignore_as_path_length(self):
    """
    Getter method for ignore_as_path_length, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options/ignore_as_path_length (boolean)

    YANG Description: Ignore the AS path length when selecting the best path.
The default is to use the AS path length and prefer paths
with shorter length.
    """
    return self.__ignore_as_path_length
      
  def _set_ignore_as_path_length(self, v, load=False):
    """
    Setter method for ignore_as_path_length, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options/ignore_as_path_length (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_as_path_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_as_path_length() directly.

    YANG Description: Ignore the AS path length when selecting the best path.
The default is to use the AS path length and prefer paths
with shorter length.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_as_path_length must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ignore_as_path_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_as_path_length(self):
    self.__ignore_as_path_length = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_external_compare_router_id(self):
    """
    Getter method for external_compare_router_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options/external_compare_router_id (boolean)

    YANG Description: When comparing similar routes received from external BGP
peers, use the router-id as a criterion to select the
active path.
    """
    return self.__external_compare_router_id
      
  def _set_external_compare_router_id(self, v, load=False):
    """
    Setter method for external_compare_router_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options/external_compare_router_id (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external_compare_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external_compare_router_id() directly.

    YANG Description: When comparing similar routes received from external BGP
peers, use the router-id as a criterion to select the
active path.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """external_compare_router_id must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__external_compare_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_external_compare_router_id(self):
    self.__external_compare_router_id = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_advertise_inactive_routes(self):
    """
    Getter method for advertise_inactive_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options/advertise_inactive_routes (boolean)

    YANG Description: Advertise inactive routes to external peers.  The default
is to only advertise active routes.
    """
    return self.__advertise_inactive_routes
      
  def _set_advertise_inactive_routes(self, v, load=False):
    """
    Setter method for advertise_inactive_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options/advertise_inactive_routes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_inactive_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_inactive_routes() directly.

    YANG Description: Advertise inactive routes to external peers.  The default
is to only advertise active routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_inactive_routes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertise_inactive_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_inactive_routes(self):
    self.__advertise_inactive_routes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_enable_aigp(self):
    """
    Getter method for enable_aigp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options/enable_aigp (boolean)

    YANG Description: Flag to enable sending / receiving accumulated IGP
attribute in routing updates
    """
    return self.__enable_aigp
      
  def _set_enable_aigp(self, v, load=False):
    """
    Setter method for enable_aigp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options/enable_aigp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_aigp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_aigp() directly.

    YANG Description: Flag to enable sending / receiving accumulated IGP
attribute in routing updates
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_aigp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enable_aigp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_aigp(self):
    self.__enable_aigp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ignore_next_hop_igp_metric(self):
    """
    Getter method for ignore_next_hop_igp_metric, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options/ignore_next_hop_igp_metric (boolean)

    YANG Description: Ignore the IGP metric to the next-hop when calculating BGP
best-path. The default is to select the route for which
the metric to the next-hop is lowest
    """
    return self.__ignore_next_hop_igp_metric
      
  def _set_ignore_next_hop_igp_metric(self, v, load=False):
    """
    Setter method for ignore_next_hop_igp_metric, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options/ignore_next_hop_igp_metric (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_next_hop_igp_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_next_hop_igp_metric() directly.

    YANG Description: Ignore the IGP metric to the next-hop when calculating BGP
best-path. The default is to select the route for which
the metric to the next-hop is lowest
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_next_hop_igp_metric must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ignore_next_hop_igp_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_next_hop_igp_metric(self):
    self.__ignore_next_hop_igp_metric = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_enable_med(self):
    """
    Getter method for enable_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options/enable_med (boolean)

    YANG Description: Flag to enable sending/receiving of MED metric attribute
       in routing updates.
    """
    return self.__enable_med
      
  def _set_enable_med(self, v, load=False):
    """
    Setter method for enable_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options/enable_med (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_med is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_med() directly.

    YANG Description: Flag to enable sending/receiving of MED metric attribute
       in routing updates.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_med must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enable_med = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_med(self):
    self.__enable_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  always_compare_med = __builtin__.property(_get_always_compare_med, _set_always_compare_med)
  ignore_as_path_length = __builtin__.property(_get_ignore_as_path_length, _set_ignore_as_path_length)
  external_compare_router_id = __builtin__.property(_get_external_compare_router_id, _set_external_compare_router_id)
  advertise_inactive_routes = __builtin__.property(_get_advertise_inactive_routes, _set_advertise_inactive_routes)
  enable_aigp = __builtin__.property(_get_enable_aigp, _set_enable_aigp)
  ignore_next_hop_igp_metric = __builtin__.property(_get_ignore_next_hop_igp_metric, _set_ignore_next_hop_igp_metric)
  enable_med = __builtin__.property(_get_enable_med, _set_enable_med)


  _pyangbind_elements = OrderedDict([('always_compare_med', always_compare_med), ('ignore_as_path_length', ignore_as_path_length), ('external_compare_router_id', external_compare_router_id), ('advertise_inactive_routes', advertise_inactive_routes), ('enable_aigp', enable_aigp), ('ignore_next_hop_igp_metric', ignore_next_hop_igp_metric), ('enable_med', enable_med), ])


class yc_timers_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_timers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/timers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Timers related to a BGP neighbor
  """
  __slots__ = ('_path_helper', '_extmethods', '__connect_retry_interval','__hold_time','__keepalive','__min_as_origination_interval','__min_route_advertisement_interval',)

  _yang_name = 'timers'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__connect_retry_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(120), is_leaf=True, yang_name="connect-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    self.__hold_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0', '3..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(90), is_leaf=True, yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    self.__keepalive = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(30), is_leaf=True, yang_name="keepalive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    self.__min_as_origination_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(15), is_leaf=True, yang_name="min-as-origination-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    self.__min_route_advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="min-route-advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'timers']

  def _get_connect_retry_interval(self):
    """
    Getter method for connect_retry_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/timers/connect_retry_interval (uint16)

    YANG Description: Time interval (in seconds) for the ConnectRetryTimer. The
suggested value for this timer is 120 seconds.
    """
    return self.__connect_retry_interval
      
  def _set_connect_retry_interval(self, v, load=False):
    """
    Setter method for connect_retry_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/timers/connect_retry_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connect_retry_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connect_retry_interval() directly.

    YANG Description: Time interval (in seconds) for the ConnectRetryTimer. The
suggested value for this timer is 120 seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(120), is_leaf=True, yang_name="connect-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connect_retry_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(120), is_leaf=True, yang_name="connect-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__connect_retry_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connect_retry_interval(self):
    self.__connect_retry_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(120), is_leaf=True, yang_name="connect-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)


  def _get_hold_time(self):
    """
    Getter method for hold_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/timers/hold_time (uint16)

    YANG Description: Time interval (in seconds) for the HoldTimer established
with the peer.  When read as operational data (ro), the
value of this object is calculated by this BGP speaker,
using the smaller of the values in hold-time that was
configured (rw) in the running datastore and the Hold Time
received in the OPEN message.

This value must be at least three seconds
if it is not zero (0).

If the Hold Timer has not been established
with the peer this object MUST have a value
of zero (0).

If the configured value of hold-time object was
a value of (0), then when read this object MUST have a
value of (0) also.
    """
    return self.__hold_time
      
  def _set_hold_time(self, v, load=False):
    """
    Setter method for hold_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/timers/hold_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time() directly.

    YANG Description: Time interval (in seconds) for the HoldTimer established
with the peer.  When read as operational data (ro), the
value of this object is calculated by this BGP speaker,
using the smaller of the values in hold-time that was
configured (rw) in the running datastore and the Hold Time
received in the OPEN message.

This value must be at least three seconds
if it is not zero (0).

If the Hold Timer has not been established
with the peer this object MUST have a value
of zero (0).

If the configured value of hold-time object was
a value of (0), then when read this object MUST have a
value of (0) also.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0', '3..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(90), is_leaf=True, yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0', '3..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(90), is_leaf=True, yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__hold_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time(self):
    self.__hold_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0', '3..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(90), is_leaf=True, yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)


  def _get_keepalive(self):
    """
    Getter method for keepalive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/timers/keepalive (uint16)

    YANG Description: When used as a configuration (rw) value, this Time interval
(in seconds) for the KeepAlive timer configured for this BGP
speaker with this peer. The value of this object will only
determine the KEEPALIVE messages' frequency relative to
the value specified in configured value for hold-time.

If the value of this object is zero (0), no periodical
KEEPALIVE messages are sent to the peer after the BGP
connection has been established.  The suggested value for
this timer is 30 seconds.;

The actual time interval for the KEEPALIVE messages is
indicated by operational value of keepalive. That value
of this object is calculated by this BGP speaker such that,
when compared with hold-time, it has the same proportion
that keepalive has, compared with hold-time. A
reasonable maximum value for this timer would be one third
of that of hold-time.
    """
    return self.__keepalive
      
  def _set_keepalive(self, v, load=False):
    """
    Setter method for keepalive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/timers/keepalive (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepalive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepalive() directly.

    YANG Description: When used as a configuration (rw) value, this Time interval
(in seconds) for the KeepAlive timer configured for this BGP
speaker with this peer. The value of this object will only
determine the KEEPALIVE messages' frequency relative to
the value specified in configured value for hold-time.

If the value of this object is zero (0), no periodical
KEEPALIVE messages are sent to the peer after the BGP
connection has been established.  The suggested value for
this timer is 30 seconds.;

The actual time interval for the KEEPALIVE messages is
indicated by operational value of keepalive. That value
of this object is calculated by this BGP speaker such that,
when compared with hold-time, it has the same proportion
that keepalive has, compared with hold-time. A
reasonable maximum value for this timer would be one third
of that of hold-time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(30), is_leaf=True, yang_name="keepalive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepalive must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(30), is_leaf=True, yang_name="keepalive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__keepalive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepalive(self):
    self.__keepalive = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(30), is_leaf=True, yang_name="keepalive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)


  def _get_min_as_origination_interval(self):
    """
    Getter method for min_as_origination_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/timers/min_as_origination_interval (uint16)

    YANG Description: Time interval (in seconds) for the MinASOriginationInterval
timer. The suggested value for this timer is 15 seconds.
    """
    return self.__min_as_origination_interval
      
  def _set_min_as_origination_interval(self, v, load=False):
    """
    Setter method for min_as_origination_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/timers/min_as_origination_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_as_origination_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_as_origination_interval() directly.

    YANG Description: Time interval (in seconds) for the MinASOriginationInterval
timer. The suggested value for this timer is 15 seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(15), is_leaf=True, yang_name="min-as-origination-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_as_origination_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(15), is_leaf=True, yang_name="min-as-origination-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__min_as_origination_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_as_origination_interval(self):
    self.__min_as_origination_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(15), is_leaf=True, yang_name="min-as-origination-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)


  def _get_min_route_advertisement_interval(self):
    """
    Getter method for min_route_advertisement_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/timers/min_route_advertisement_interval (uint16)

    YANG Description: Time interval (in seconds) for the
MinRouteAdvertisementInterval timer.
The suggested value for this timer is 30
seconds for EBGP connections and 5
seconds for IBGP connections.
    """
    return self.__min_route_advertisement_interval
      
  def _set_min_route_advertisement_interval(self, v, load=False):
    """
    Setter method for min_route_advertisement_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/timers/min_route_advertisement_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_route_advertisement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_route_advertisement_interval() directly.

    YANG Description: Time interval (in seconds) for the
MinRouteAdvertisementInterval timer.
The suggested value for this timer is 30
seconds for EBGP connections and 5
seconds for IBGP connections.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="min-route-advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_route_advertisement_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="min-route-advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__min_route_advertisement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_route_advertisement_interval(self):
    self.__min_route_advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="min-route-advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)

  connect_retry_interval = __builtin__.property(_get_connect_retry_interval, _set_connect_retry_interval)
  hold_time = __builtin__.property(_get_hold_time, _set_hold_time)
  keepalive = __builtin__.property(_get_keepalive, _set_keepalive)
  min_as_origination_interval = __builtin__.property(_get_min_as_origination_interval, _set_min_as_origination_interval)
  min_route_advertisement_interval = __builtin__.property(_get_min_route_advertisement_interval, _set_min_route_advertisement_interval)


  _pyangbind_elements = OrderedDict([('connect_retry_interval', connect_retry_interval), ('hold_time', hold_time), ('keepalive', keepalive), ('min_as_origination_interval', min_as_origination_interval), ('min_route_advertisement_interval', min_route_advertisement_interval), ])


class yc_transport_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_transport(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/transport. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Transport session parameters for the BGP neighbor
  """
  __slots__ = ('_path_helper', '_extmethods', '__tcp_mss','__mtu_discovery','__passive_mode','__local_address','__auth_password',)

  _yang_name = 'transport'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tcp_mss = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tcp-mss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    self.__mtu_discovery = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__passive_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="passive-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__local_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),six.text_type,], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=True)
    self.__auth_password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="auth-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'transport']

  def _get_tcp_mss(self):
    """
    Getter method for tcp_mss, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/transport/tcp_mss (uint16)

    YANG Description: Sets the max segment size for BGP TCP sessions.
    """
    return self.__tcp_mss
      
  def _set_tcp_mss(self, v, load=False):
    """
    Setter method for tcp_mss, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/transport/tcp_mss (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcp_mss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcp_mss() directly.

    YANG Description: Sets the max segment size for BGP TCP sessions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tcp-mss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcp_mss must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tcp-mss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__tcp_mss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcp_mss(self):
    self.__tcp_mss = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tcp-mss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)


  def _get_mtu_discovery(self):
    """
    Getter method for mtu_discovery, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/transport/mtu_discovery (boolean)

    YANG Description: Turns path mtu discovery for BGP TCP sessions on (true) or
off (false)
    """
    return self.__mtu_discovery
      
  def _set_mtu_discovery(self, v, load=False):
    """
    Setter method for mtu_discovery, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/transport/mtu_discovery (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu_discovery is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu_discovery() directly.

    YANG Description: Turns path mtu discovery for BGP TCP sessions on (true) or
off (false)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu_discovery must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__mtu_discovery = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu_discovery(self):
    self.__mtu_discovery = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_passive_mode(self):
    """
    Getter method for passive_mode, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/transport/passive_mode (boolean)

    YANG Description: Wait for peers to issue requests to open a BGP session,
rather than initiating sessions from the local router.
    """
    return self.__passive_mode
      
  def _set_passive_mode(self, v, load=False):
    """
    Setter method for passive_mode, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/transport/passive_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_passive_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_passive_mode() directly.

    YANG Description: Wait for peers to issue requests to open a BGP session,
rather than initiating sessions from the local router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="passive-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """passive_mode must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="passive-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__passive_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_passive_mode(self):
    self.__passive_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="passive-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_local_address(self):
    """
    Getter method for local_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/transport/local_address (union)

    YANG Description: Set the local IP (either IPv4 or IPv6) address to use for
the session when sending BGP update messages.  This may be
expressed as either an IP address or reference to the name
of an interface.
    """
    return self.__local_address
      
  def _set_local_address(self, v, load=False):
    """
    Setter method for local_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/transport/local_address (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_address() directly.

    YANG Description: Set the local IP (either IPv4 or IPv6) address to use for
the session when sending BGP update messages.  This may be
expressed as either an IP address or reference to the name
of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),six.text_type,], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_address must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),six.text_type,], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=True)""",
        })

    self.__local_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_address(self):
    self.__local_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),six.text_type,], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=True)


  def _get_auth_password(self):
    """
    Getter method for auth_password, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/transport/auth_password (string)

    YANG Description: Configures an MD5 authentication password for use with
neighboring devices.
    """
    return self.__auth_password
      
  def _set_auth_password(self, v, load=False):
    """
    Setter method for auth_password, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/transport/auth_password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_password() directly.

    YANG Description: Configures an MD5 authentication password for use with
neighboring devices.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="auth-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="auth-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)""",
        })

    self.__auth_password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_password(self):
    self.__auth_password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="auth-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)

  tcp_mss = __builtin__.property(_get_tcp_mss, _set_tcp_mss)
  mtu_discovery = __builtin__.property(_get_mtu_discovery, _set_mtu_discovery)
  passive_mode = __builtin__.property(_get_passive_mode, _set_passive_mode)
  local_address = __builtin__.property(_get_local_address, _set_local_address)
  auth_password = __builtin__.property(_get_auth_password, _set_auth_password)


  _pyangbind_elements = OrderedDict([('tcp_mss', tcp_mss), ('mtu_discovery', mtu_discovery), ('passive_mode', passive_mode), ('local_address', local_address), ('auth_password', auth_password), ])


class yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_graceful_restart(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/graceful-restart. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating the graceful restart mechanism for
BGP
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__restart_time','__stale_routes_time','__helper_only','__peer_restart_time','__peer_restarting','__local_restarting','__mode',)

  _yang_name = 'graceful-restart'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__restart_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    self.__stale_routes_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stale-routes-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__helper_only = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="helper-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__peer_restart_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="peer-restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    self.__peer_restarting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="peer-restarting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__local_restarting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-restarting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'helper-only': {}, 'bilateral': {}, 'remote-helper': {}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'graceful-restart']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/enabled (boolean)

    YANG Description: Enable or disable the graceful-restart capability.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Enable or disable the graceful-restart capability.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_restart_time(self):
    """
    Getter method for restart_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/restart_time (uint16)

    YANG Description: Estimated time (in seconds) for the local BGP speaker to
restart a session. This value is advertise in the graceful
restart BGP capability.  This is a 12-bit value, referred to
as Restart Time in RFC4724.  Per RFC4724, the suggested
default value is <= the hold-time value.
    """
    return self.__restart_time
      
  def _set_restart_time(self, v, load=False):
    """
    Setter method for restart_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/restart_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_time() directly.

    YANG Description: Estimated time (in seconds) for the local BGP speaker to
restart a session. This value is advertise in the graceful
restart BGP capability.  This is a 12-bit value, referred to
as Restart Time in RFC4724.  Per RFC4724, the suggested
default value is <= the hold-time value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__restart_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_time(self):
    self.__restart_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)


  def _get_stale_routes_time(self):
    """
    Getter method for stale_routes_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/stale_routes_time (uint32)

    YANG Description: An upper-bound on the time that stale routes will be
retained by a router after a session is restarted. If an
End-of-RIB (EOR) marker is received prior to this timer
expiring stale-routes will be flushed upon its receipt - if
no EOR is received, then when this timer expires stale paths
will be purged. This timer is referred to as the
Selection_Deferral_Timer in RFC4724
    """
    return self.__stale_routes_time
      
  def _set_stale_routes_time(self, v, load=False):
    """
    Setter method for stale_routes_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/stale_routes_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stale_routes_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stale_routes_time() directly.

    YANG Description: An upper-bound on the time that stale routes will be
retained by a router after a session is restarted. If an
End-of-RIB (EOR) marker is received prior to this timer
expiring stale-routes will be flushed upon its receipt - if
no EOR is received, then when this timer expires stale paths
will be purged. This timer is referred to as the
Selection_Deferral_Timer in RFC4724
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stale-routes-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stale_routes_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stale-routes-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__stale_routes_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stale_routes_time(self):
    self.__stale_routes_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stale-routes-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_helper_only(self):
    """
    Getter method for helper_only, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/helper_only (boolean)

    YANG Description: Enable graceful-restart in helper mode only. When this leaf
is set, the local system does not retain forwarding its own
state during a restart, but supports procedures for the
receiving speaker, as defined in RFC4724.
    """
    return self.__helper_only
      
  def _set_helper_only(self, v, load=False):
    """
    Setter method for helper_only, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/helper_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helper_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helper_only() directly.

    YANG Description: Enable graceful-restart in helper mode only. When this leaf
is set, the local system does not retain forwarding its own
state during a restart, but supports procedures for the
receiving speaker, as defined in RFC4724.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="helper-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """helper_only must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="helper-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__helper_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_helper_only(self):
    self.__helper_only = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="helper-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_peer_restart_time(self):
    """
    Getter method for peer_restart_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/peer_restart_time (uint16)

    YANG Description: The period of time (advertised by the peer) that the
peer expects a restart of a BGP session to take
    """
    return self.__peer_restart_time
      
  def _set_peer_restart_time(self, v, load=False):
    """
    Setter method for peer_restart_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/peer_restart_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_restart_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_restart_time() directly.

    YANG Description: The period of time (advertised by the peer) that the
peer expects a restart of a BGP session to take
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="peer-restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_restart_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="peer-restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)""",
        })

    self.__peer_restart_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_restart_time(self):
    self.__peer_restart_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="peer-restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)


  def _get_peer_restarting(self):
    """
    Getter method for peer_restarting, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/peer_restarting (boolean)

    YANG Description: This flag indicates whether the remote neighbor is
currently in the process of restarting, and hence
received routes are currently stale
    """
    return self.__peer_restarting
      
  def _set_peer_restarting(self, v, load=False):
    """
    Setter method for peer_restarting, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/peer_restarting (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_restarting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_restarting() directly.

    YANG Description: This flag indicates whether the remote neighbor is
currently in the process of restarting, and hence
received routes are currently stale
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="peer-restarting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_restarting must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="peer-restarting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__peer_restarting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_restarting(self):
    self.__peer_restarting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="peer-restarting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_local_restarting(self):
    """
    Getter method for local_restarting, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/local_restarting (boolean)

    YANG Description: This flag indicates whether the local neighbor is
currently restarting. The flag is unset after all NLRI
have been advertised to the peer, and the End-of-RIB
(EOR) marker has been unset
    """
    return self.__local_restarting
      
  def _set_local_restarting(self, v, load=False):
    """
    Setter method for local_restarting, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/local_restarting (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_restarting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_restarting() directly.

    YANG Description: This flag indicates whether the local neighbor is
currently restarting. The flag is unset after all NLRI
have been advertised to the peer, and the End-of-RIB
(EOR) marker has been unset
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="local-restarting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_restarting must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-restarting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__local_restarting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_restarting(self):
    self.__local_restarting = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="local-restarting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/mode (enumeration)

    YANG Description: This leaf indicates the mode of operation of BGP
graceful restart with the peer
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart/mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: This leaf indicates the mode of operation of BGP
graceful restart with the peer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'helper-only': {}, 'bilateral': {}, 'remote-helper': {}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with enumeration""",
          'defined-type': "ietf-bgp:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'helper-only': {}, 'bilateral': {}, 'remote-helper': {}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='enumeration', is_config=False)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'helper-only': {}, 'bilateral': {}, 'remote-helper': {}},), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='enumeration', is_config=False)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  restart_time = __builtin__.property(_get_restart_time, _set_restart_time)
  stale_routes_time = __builtin__.property(_get_stale_routes_time, _set_stale_routes_time)
  helper_only = __builtin__.property(_get_helper_only, _set_helper_only)
  peer_restart_time = __builtin__.property(_get_peer_restart_time)
  peer_restarting = __builtin__.property(_get_peer_restarting)
  local_restarting = __builtin__.property(_get_local_restarting)
  mode = __builtin__.property(_get_mode)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('restart_time', restart_time), ('stale_routes_time', stale_routes_time), ('helper_only', helper_only), ('peer_restart_time', peer_restart_time), ('peer_restarting', peer_restarting), ('local_restarting', local_restarting), ('mode', mode), ])


class yc_logging_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_logging_options(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/logging-options. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Logging options for events related to the BGP neighbor or
group
  """
  __slots__ = ('_path_helper', '_extmethods', '__log_neighbor_state_changes',)

  _yang_name = 'logging-options'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__log_neighbor_state_changes = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="log-neighbor-state-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'logging-options']

  def _get_log_neighbor_state_changes(self):
    """
    Getter method for log_neighbor_state_changes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/logging_options/log_neighbor_state_changes (boolean)

    YANG Description: Configure logging of peer state changes.  Default is to
enable logging of peer state changes.

Note: Documenting out of ESTABLISHED state is desirable,
      but documenting all backward transitions is
      problematic, and should be avoided.
    """
    return self.__log_neighbor_state_changes
      
  def _set_log_neighbor_state_changes(self, v, load=False):
    """
    Setter method for log_neighbor_state_changes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/logging_options/log_neighbor_state_changes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_neighbor_state_changes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_neighbor_state_changes() directly.

    YANG Description: Configure logging of peer state changes.  Default is to
enable logging of peer state changes.

Note: Documenting out of ESTABLISHED state is desirable,
      but documenting all backward transitions is
      problematic, and should be avoided.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="log-neighbor-state-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_neighbor_state_changes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="log-neighbor-state-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__log_neighbor_state_changes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_neighbor_state_changes(self):
    self.__log_neighbor_state_changes = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="log-neighbor-state-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  log_neighbor_state_changes = __builtin__.property(_get_log_neighbor_state_changes, _set_log_neighbor_state_changes)


  _pyangbind_elements = OrderedDict([('log_neighbor_state_changes', log_neighbor_state_changes), ])


class yc_ebgp_multihop_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_ebgp_multihop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/ebgp-multihop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: eBGP multi-hop parameters for the BGPgroup
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__multihop_ttl',)

  _yang_name = 'ebgp-multihop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__multihop_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="multihop-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'ebgp-multihop']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/ebgp_multihop/enabled (boolean)

    YANG Description: When enabled the referenced group or neighbors are
permitted to be indirectly connected - including cases
where the TTL can be decremented between the BGP peers
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/ebgp_multihop/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When enabled the referenced group or neighbors are
permitted to be indirectly connected - including cases
where the TTL can be decremented between the BGP peers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_multihop_ttl(self):
    """
    Getter method for multihop_ttl, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/ebgp_multihop/multihop_ttl (uint8)

    YANG Description: Time-to-live value to use when packets are sent to the
referenced group or neighbors and ebgp-multihop is
enabled
    """
    return self.__multihop_ttl
      
  def _set_multihop_ttl(self, v, load=False):
    """
    Setter method for multihop_ttl, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/ebgp_multihop/multihop_ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multihop_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multihop_ttl() directly.

    YANG Description: Time-to-live value to use when packets are sent to the
referenced group or neighbors and ebgp-multihop is
enabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="multihop-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multihop_ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="multihop-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__multihop_ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multihop_ttl(self):
    self.__multihop_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="multihop-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  multihop_ttl = __builtin__.property(_get_multihop_ttl, _set_multihop_ttl)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('multihop_ttl', multihop_ttl), ])


class yc_route_reflector_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_reflector(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/route-reflector. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route reflector parameters for the BGPgroup
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_reflector_cluster_id','__no_client_reflect','__route_reflector_client',)

  _yang_name = 'route-reflector'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_reflector_cluster_id = YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="route-reflector-cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:rr-cluster-id-type', is_config=True)
    self.__no_client_reflect = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-client-reflect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__route_reflector_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="route-reflector-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'route-reflector']

  def _get_route_reflector_cluster_id(self):
    """
    Getter method for route_reflector_cluster_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_reflector/route_reflector_cluster_id (bt:rr-cluster-id-type)

    YANG Description: Route Reflector cluster id to use when local router is
configured as a route reflector.  Commonly set at the
group level, but allows a different cluster id to be set
for each neighbor.
    """
    return self.__route_reflector_cluster_id
      
  def _set_route_reflector_cluster_id(self, v, load=False):
    """
    Setter method for route_reflector_cluster_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_reflector/route_reflector_cluster_id (bt:rr-cluster-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector_cluster_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector_cluster_id() directly.

    YANG Description: Route Reflector cluster id to use when local router is
configured as a route reflector.  Commonly set at the
group level, but allows a different cluster id to be set
for each neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="route-reflector-cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:rr-cluster-id-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector_cluster_id must be of a type compatible with bt:rr-cluster-id-type""",
          'defined-type': "bt:rr-cluster-id-type",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="route-reflector-cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:rr-cluster-id-type', is_config=True)""",
        })

    self.__route_reflector_cluster_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector_cluster_id(self):
    self.__route_reflector_cluster_id = YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="route-reflector-cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:rr-cluster-id-type', is_config=True)


  def _get_no_client_reflect(self):
    """
    Getter method for no_client_reflect, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_reflector/no_client_reflect (boolean)

    YANG Description: When set to 'true', this disables route redistribution
by the Route Reflector. It is set 'true' when the client is
fully meshed to prevent sending of redundant route
advertisements.
    """
    return self.__no_client_reflect
      
  def _set_no_client_reflect(self, v, load=False):
    """
    Setter method for no_client_reflect, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_reflector/no_client_reflect (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_client_reflect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_client_reflect() directly.

    YANG Description: When set to 'true', this disables route redistribution
by the Route Reflector. It is set 'true' when the client is
fully meshed to prevent sending of redundant route
advertisements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-client-reflect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_client_reflect must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-client-reflect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__no_client_reflect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_client_reflect(self):
    self.__no_client_reflect = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-client-reflect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_route_reflector_client(self):
    """
    Getter method for route_reflector_client, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_reflector/route_reflector_client (boolean)

    YANG Description: Configure the neighbor as a route reflector client.
    """
    return self.__route_reflector_client
      
  def _set_route_reflector_client(self, v, load=False):
    """
    Setter method for route_reflector_client, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_reflector/route_reflector_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector_client() directly.

    YANG Description: Configure the neighbor as a route reflector client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="route-reflector-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="route-reflector-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__route_reflector_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector_client(self):
    self.__route_reflector_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="route-reflector-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  route_reflector_cluster_id = __builtin__.property(_get_route_reflector_cluster_id, _set_route_reflector_cluster_id)
  no_client_reflect = __builtin__.property(_get_no_client_reflect, _set_no_client_reflect)
  route_reflector_client = __builtin__.property(_get_route_reflector_client, _set_route_reflector_client)


  _pyangbind_elements = OrderedDict([('route_reflector_cluster_id', route_reflector_cluster_id), ('no_client_reflect', no_client_reflect), ('route_reflector_client', route_reflector_client), ])


class yc_as_path_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_as_path_options(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/as-path-options. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
  """
  __slots__ = ('_path_helper', '_extmethods', '__allow_own_as','__replace_peer_as',)

  _yang_name = 'as-path-options'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__allow_own_as = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="allow-own-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    self.__replace_peer_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="replace-peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'as-path-options']

  def _get_allow_own_as(self):
    """
    Getter method for allow_own_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/as_path_options/allow_own_as (uint8)

    YANG Description: Specify the number of occurrences of the local BGP
speaker's AS that can occur within the AS_PATH before it
is rejected.
    """
    return self.__allow_own_as
      
  def _set_allow_own_as(self, v, load=False):
    """
    Setter method for allow_own_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/as_path_options/allow_own_as (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allow_own_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allow_own_as() directly.

    YANG Description: Specify the number of occurrences of the local BGP
speaker's AS that can occur within the AS_PATH before it
is rejected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="allow-own-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allow_own_as must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="allow-own-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__allow_own_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allow_own_as(self):
    self.__allow_own_as = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="allow-own-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)


  def _get_replace_peer_as(self):
    """
    Getter method for replace_peer_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/as_path_options/replace_peer_as (boolean)

    YANG Description: Replace occurrences of the peer's AS in the AS_PATH with
the local autonomous system number
    """
    return self.__replace_peer_as
      
  def _set_replace_peer_as(self, v, load=False):
    """
    Setter method for replace_peer_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/as_path_options/replace_peer_as (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_replace_peer_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_replace_peer_as() directly.

    YANG Description: Replace occurrences of the peer's AS in the AS_PATH with
the local autonomous system number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="replace-peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """replace_peer_as must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="replace-peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__replace_peer_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_replace_peer_as(self):
    self.__replace_peer_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="replace-peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  allow_own_as = __builtin__.property(_get_allow_own_as, _set_allow_own_as)
  replace_peer_as = __builtin__.property(_get_replace_peer_as, _set_replace_peer_as)


  _pyangbind_elements = OrderedDict([('allow_own_as', allow_own_as), ('replace_peer_as', replace_peer_as), ])


class yc_add_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_add_paths(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/add-paths. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the advertisement and receipt of
multiple paths for a single NLRI (add-paths)
  """
  __slots__ = ('_path_helper', '_extmethods', '__receive','__max_','__all','__eligible_prefix_policy',)

  _yang_name = 'add-paths'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__receive = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max", parent=self, choice=('send', 'max'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    self.__all = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="all", parent=self, choice=('send', 'all'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='empty', is_config=True)
    self.__eligible_prefix_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="eligible-prefix-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'add-paths']

  def _get_receive(self):
    """
    Getter method for receive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/add_paths/receive (boolean)

    YANG Description: Enable ability to receive multiple path advertisements for
an NLRI from the neighbor or group
    """
    return self.__receive
      
  def _set_receive(self, v, load=False):
    """
    Setter method for receive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/add_paths/receive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive() directly.

    YANG Description: Enable ability to receive multiple path advertisements for
an NLRI from the neighbor or group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__receive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive(self):
    self.__receive = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/add_paths/max (uint8)

    YANG Description: The maximum number of paths to advertise to neighbors
for a single NLRI
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/add_paths/max (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum number of paths to advertise to neighbors
for a single NLRI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max", parent=self, choice=('send', 'max'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max", parent=self, choice=('send', 'max'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max", parent=self, choice=('send', 'max'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)


  def _get_all(self):
    """
    Getter method for all, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/add_paths/all (empty)

    YANG Description: Send all the path advertisements to neighbors for a
single NLRI.
    """
    return self.__all
      
  def _set_all(self, v, load=False):
    """
    Setter method for all, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/add_paths/all (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_all is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_all() directly.

    YANG Description: Send all the path advertisements to neighbors for a
single NLRI.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="all", parent=self, choice=('send', 'all'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """all must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="all", parent=self, choice=('send', 'all'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='empty', is_config=True)""",
        })

    self.__all = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_all(self):
    self.__all = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="all", parent=self, choice=('send', 'all'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='empty', is_config=True)


  def _get_eligible_prefix_policy(self):
    """
    Getter method for eligible_prefix_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/add_paths/eligible_prefix_policy (leafref)

    YANG Description: A reference to a routing policy which can be used to
restrict the prefixes for which add-paths is enabled
    """
    return self.__eligible_prefix_policy
      
  def _set_eligible_prefix_policy(self, v, load=False):
    """
    Setter method for eligible_prefix_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/add_paths/eligible_prefix_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eligible_prefix_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eligible_prefix_policy() directly.

    YANG Description: A reference to a routing policy which can be used to
restrict the prefixes for which add-paths is enabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="eligible-prefix-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eligible_prefix_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="eligible-prefix-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__eligible_prefix_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eligible_prefix_policy(self):
    self.__eligible_prefix_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="eligible-prefix-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)

  receive = __builtin__.property(_get_receive, _set_receive)
  max_ = __builtin__.property(_get_max_, _set_max_)
  all = __builtin__.property(_get_all, _set_all)
  eligible_prefix_policy = __builtin__.property(_get_eligible_prefix_policy, _set_eligible_prefix_policy)

  __choices__ = {'send': {'max': ['max_'], 'all': ['all']}}
  _pyangbind_elements = OrderedDict([('receive', receive), ('max_', max_), ('all', all), ('eligible_prefix_policy', eligible_prefix_policy), ])


class yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_use_multiple_paths_ebgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/use-multiple-paths/ebgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multi-path configuration for eBGP
  """
  __slots__ = ('_path_helper', '_extmethods', '__allow_multiple_as',)

  _yang_name = 'ebgp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__allow_multiple_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'use-multiple-paths', 'ebgp']

  def _get_allow_multiple_as(self):
    """
    Getter method for allow_multiple_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/use_multiple_paths/ebgp/allow_multiple_as (boolean)

    YANG Description: Allow multi-path to use paths from different neighboring
ASes. The default is to only consider multiple paths
from the same neighboring AS.
    """
    return self.__allow_multiple_as
      
  def _set_allow_multiple_as(self, v, load=False):
    """
    Setter method for allow_multiple_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/use_multiple_paths/ebgp/allow_multiple_as (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allow_multiple_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allow_multiple_as() directly.

    YANG Description: Allow multi-path to use paths from different neighboring
ASes. The default is to only consider multiple paths
from the same neighboring AS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allow_multiple_as must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__allow_multiple_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allow_multiple_as(self):
    self.__allow_multiple_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  allow_multiple_as = __builtin__.property(_get_allow_multiple_as, _set_allow_multiple_as)


  _pyangbind_elements = OrderedDict([('allow_multiple_as', allow_multiple_as), ])


class yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_use_multiple_paths(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/use-multiple-paths. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__ebgp',)

  _yang_name = 'use-multiple-paths'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ebgp = YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'use-multiple-paths']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/use_multiple_paths/enabled (boolean)

    YANG Description: Whether the use of multiple paths for the same NLRI is
enabled for the neighbor. This value is overridden by any
more specific configuration value.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/use_multiple_paths/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Whether the use of multiple paths for the same NLRI is
enabled for the neighbor. This value is overridden by any
more specific configuration value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ebgp(self):
    """
    Getter method for ebgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/use_multiple_paths/ebgp (container)

    YANG Description: Multi-path configuration for eBGP
    """
    return self.__ebgp
      
  def _set_ebgp(self, v, load=False):
    """
    Setter method for ebgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/use_multiple_paths/ebgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp() directly.

    YANG Description: Multi-path configuration for eBGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp(self):
    self.__ebgp = YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  ebgp = __builtin__.property(_get_ebgp, _set_ebgp) # type: yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_use_multiple_paths_ebgp


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('ebgp', ebgp), ])


class yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_apply_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/apply-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
  """
  __slots__ = ('_path_helper', '_extmethods', '__import_policy','__default_import_policy','__export_policy','__default_export_policy',)

  _yang_name = 'apply-policy'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__import_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__default_import_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    self.__export_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__default_export_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'apply-policy']

  def _get_import_policy(self):
    """
    Getter method for import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/apply_policy/import_policy (leafref)

    YANG Description: List of policy names in sequence to be applied on
receiving redistributed routes from another routing protocol
or receiving a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    return self.__import_policy
      
  def _set_import_policy(self, v, load=False):
    """
    Setter method for import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/apply_policy/import_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_policy() directly.

    YANG Description: List of policy names in sequence to be applied on
receiving redistributed routes from another routing protocol
or receiving a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_policy(self):
    self.__import_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_default_import_policy(self):
    """
    Getter method for default_import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/apply_policy/default_import_policy (default-policy-type)

    YANG Description: Explicitly set a default policy if no policy definition
in the import policy chain is satisfied.
    """
    return self.__default_import_policy
      
  def _set_default_import_policy(self, v, load=False):
    """
    Setter method for default_import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/apply_policy/default_import_policy (default-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_import_policy() directly.

    YANG Description: Explicitly set a default policy if no policy definition
in the import policy chain is satisfied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_import_policy must be of a type compatible with default-policy-type""",
          'defined-type': "ietf-bgp:default-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)""",
        })

    self.__default_import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_import_policy(self):
    self.__default_import_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)


  def _get_export_policy(self):
    """
    Getter method for export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/apply_policy/export_policy (leafref)

    YANG Description: List of policy names in sequence to be applied on
redistributing routes from one routing protocol to another
or sending a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    return self.__export_policy
      
  def _set_export_policy(self, v, load=False):
    """
    Setter method for export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/apply_policy/export_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_export_policy() directly.

    YANG Description: List of policy names in sequence to be applied on
redistributing routes from one routing protocol to another
or sending a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """export_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_export_policy(self):
    self.__export_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_default_export_policy(self):
    """
    Getter method for default_export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/apply_policy/default_export_policy (default-policy-type)

    YANG Description: Explicitly set a default policy if no policy definition
in the export policy chain is satisfied.
    """
    return self.__default_export_policy
      
  def _set_default_export_policy(self, v, load=False):
    """
    Setter method for default_export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/apply_policy/default_export_policy (default-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_export_policy() directly.

    YANG Description: Explicitly set a default policy if no policy definition
in the export policy chain is satisfied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_export_policy must be of a type compatible with default-policy-type""",
          'defined-type': "ietf-bgp:default-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)""",
        })

    self.__default_export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_export_policy(self):
    self.__default_export_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)

  import_policy = __builtin__.property(_get_import_policy, _set_import_policy)
  default_import_policy = __builtin__.property(_get_default_import_policy, _set_default_import_policy)
  export_policy = __builtin__.property(_get_export_policy, _set_export_policy)
  default_export_policy = __builtin__.property(_get_default_export_policy, _set_default_export_policy)


  _pyangbind_elements = OrderedDict([('import_policy', import_policy), ('default_import_policy', default_import_policy), ('export_policy', export_policy), ('default_export_policy', default_export_policy), ])


class yc_prefixes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_prefixes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/prefixes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Prefix counters for the BGP session
  """
  __slots__ = ('_path_helper', '_extmethods', '__received','__sent','__installed',)

  _yang_name = 'prefixes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__installed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'prefixes']

  def _get_received(self):
    """
    Getter method for received, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/prefixes/received (uint32)

    YANG Description: The number of prefixes received from the neighbor
    """
    return self.__received
      
  def _set_received(self, v, load=False):
    """
    Setter method for received, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/prefixes/received (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_received() directly.

    YANG Description: The number of prefixes received from the neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """received must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_received(self):
    self.__received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_sent(self):
    """
    Getter method for sent, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/prefixes/sent (uint32)

    YANG Description: The number of prefixes advertised to the neighbor
    """
    return self.__sent
      
  def _set_sent(self, v, load=False):
    """
    Setter method for sent, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/prefixes/sent (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sent() directly.

    YANG Description: The number of prefixes advertised to the neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sent must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sent(self):
    self.__sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_installed(self):
    """
    Getter method for installed, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/prefixes/installed (uint32)

    YANG Description: The number of advertised prefixes installed in the
Loc-RIB
    """
    return self.__installed
      
  def _set_installed(self, v, load=False):
    """
    Setter method for installed, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/prefixes/installed (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_installed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_installed() directly.

    YANG Description: The number of advertised prefixes installed in the
Loc-RIB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """installed must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__installed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_installed(self):
    self.__installed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="installed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)

  received = __builtin__.property(_get_received)
  sent = __builtin__.property(_get_sent)
  installed = __builtin__.property(_get_installed)


  _pyangbind_elements = OrderedDict([('received', received), ('sent', sent), ('installed', installed), ])


class yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_graceful_restart(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/graceful-restart. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to BGP graceful-restart
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__received','__advertised',)

  _yang_name = 'graceful-restart'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__received = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__advertised = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertised", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'graceful-restart']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/graceful_restart/enabled (boolean)

    YANG Description: This leaf indicates whether graceful-restart is enabled for
this AFI-SAFI
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/graceful_restart/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf indicates whether graceful-restart is enabled for
this AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_received(self):
    """
    Getter method for received, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/graceful_restart/received (boolean)

    YANG Description: This leaf indicates whether the neighbor advertised the
ability to support graceful-restart for this AFI-SAFI
    """
    return self.__received
      
  def _set_received(self, v, load=False):
    """
    Setter method for received, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/graceful_restart/received (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_received() directly.

    YANG Description: This leaf indicates whether the neighbor advertised the
ability to support graceful-restart for this AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """received must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_received(self):
    self.__received = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_advertised(self):
    """
    Getter method for advertised, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/graceful_restart/advertised (boolean)

    YANG Description: This leaf indicates whether the ability to support
graceful-restart has been advertised to the peer
    """
    return self.__advertised
      
  def _set_advertised(self, v, load=False):
    """
    Setter method for advertised, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/graceful_restart/advertised (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertised is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertised() directly.

    YANG Description: This leaf indicates whether the ability to support
graceful-restart has been advertised to the peer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="advertised", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertised must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertised", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__advertised = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertised(self):
    self.__advertised = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="advertised", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  received = __builtin__.property(_get_received)
  advertised = __builtin__.property(_get_advertised)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('received', received), ('advertised', advertised), ])


class yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_apply_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/apply-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
  """
  __slots__ = ('_path_helper', '_extmethods', '__import_policy','__default_import_policy','__export_policy','__default_export_policy',)

  _yang_name = 'apply-policy'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__import_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__default_import_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    self.__export_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__default_export_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'apply-policy']

  def _get_import_policy(self):
    """
    Getter method for import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/apply_policy/import_policy (leafref)

    YANG Description: List of policy names in sequence to be applied on
receiving redistributed routes from another routing protocol
or receiving a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    return self.__import_policy
      
  def _set_import_policy(self, v, load=False):
    """
    Setter method for import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/apply_policy/import_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_policy() directly.

    YANG Description: List of policy names in sequence to be applied on
receiving redistributed routes from another routing protocol
or receiving a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_policy(self):
    self.__import_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_default_import_policy(self):
    """
    Getter method for default_import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/apply_policy/default_import_policy (default-policy-type)

    YANG Description: Explicitly set a default policy if no policy definition
in the import policy chain is satisfied.
    """
    return self.__default_import_policy
      
  def _set_default_import_policy(self, v, load=False):
    """
    Setter method for default_import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/apply_policy/default_import_policy (default-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_import_policy() directly.

    YANG Description: Explicitly set a default policy if no policy definition
in the import policy chain is satisfied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_import_policy must be of a type compatible with default-policy-type""",
          'defined-type': "ietf-bgp:default-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)""",
        })

    self.__default_import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_import_policy(self):
    self.__default_import_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)


  def _get_export_policy(self):
    """
    Getter method for export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/apply_policy/export_policy (leafref)

    YANG Description: List of policy names in sequence to be applied on
redistributing routes from one routing protocol to another
or sending a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    return self.__export_policy
      
  def _set_export_policy(self, v, load=False):
    """
    Setter method for export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/apply_policy/export_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_export_policy() directly.

    YANG Description: List of policy names in sequence to be applied on
redistributing routes from one routing protocol to another
or sending a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """export_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_export_policy(self):
    self.__export_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_default_export_policy(self):
    """
    Getter method for default_export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/apply_policy/default_export_policy (default-policy-type)

    YANG Description: Explicitly set a default policy if no policy definition
in the export policy chain is satisfied.
    """
    return self.__default_export_policy
      
  def _set_default_export_policy(self, v, load=False):
    """
    Setter method for default_export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/apply_policy/default_export_policy (default-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_export_policy() directly.

    YANG Description: Explicitly set a default policy if no policy definition
in the export policy chain is satisfied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_export_policy must be of a type compatible with default-policy-type""",
          'defined-type': "ietf-bgp:default-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)""",
        })

    self.__default_export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_export_policy(self):
    self.__default_export_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)

  import_policy = __builtin__.property(_get_import_policy, _set_import_policy)
  default_import_policy = __builtin__.property(_get_default_import_policy, _set_default_import_policy)
  export_policy = __builtin__.property(_get_export_policy, _set_export_policy)
  default_export_policy = __builtin__.property(_get_default_export_policy, _set_default_export_policy)


  _pyangbind_elements = OrderedDict([('import_policy', import_policy), ('default_import_policy', default_import_policy), ('export_policy', export_policy), ('default_export_policy', default_export_policy), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/ipv4-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/ipv4-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv4 unicast configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit','__send_default_route',)

  _yang_name = 'ipv4-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__send_default_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'ipv4-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_send_default_route(self):
    """
    Getter method for send_default_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_unicast/send_default_route (boolean)

    YANG Description: If set to true, send the default-route to the neighbour(s)
    """
    return self.__send_default_route
      
  def _set_send_default_route(self, v, load=False):
    """
    Setter method for send_default_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_unicast/send_default_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_default_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_default_route() directly.

    YANG Description: If set to true, send the default-route to the neighbour(s)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_default_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__send_default_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_default_route(self):
    self.__send_default_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_unicast_prefix_limit
  send_default_route = __builtin__.property(_get_send_default_route, _set_send_default_route)


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ('send_default_route', send_default_route), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/ipv6-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/ipv6-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv6 unicast configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit','__send_default_route',)

  _yang_name = 'ipv6-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__send_default_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'ipv6-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_send_default_route(self):
    """
    Getter method for send_default_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_unicast/send_default_route (boolean)

    YANG Description: If set to true, send the default-route to the neighbour(s)
    """
    return self.__send_default_route
      
  def _set_send_default_route(self, v, load=False):
    """
    Setter method for send_default_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_unicast/send_default_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_default_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_default_route() directly.

    YANG Description: If set to true, send the default-route to the neighbour(s)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_default_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__send_default_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_default_route(self):
    self.__send_default_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_unicast_prefix_limit
  send_default_route = __builtin__.property(_get_send_default_route, _set_send_default_route)


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ('send_default_route', send_default_route), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/ipv4-labeled-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'ipv4-labeled-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_labeled_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/ipv4-labeled-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv4 Labeled Unicast configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'ipv4-labeled-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'ipv4-labeled-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/ipv6-labeled-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'ipv6-labeled-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_labeled_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/ipv6-labeled-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv6 Labeled Unicast configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'ipv6-labeled-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'ipv6-labeled-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/l3vpn-ipv4-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'l3vpn-ipv4-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/l3vpn-ipv4-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unicast IPv4 L3VPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l3vpn-ipv4-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'l3vpn-ipv4-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/l3vpn-ipv6-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'l3vpn-ipv6-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/l3vpn-ipv6-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unicast IPv6 L3VPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l3vpn-ipv6-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'l3vpn-ipv6-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/l3vpn-ipv4-multicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'l3vpn-ipv4-multicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_multicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/l3vpn-ipv4-multicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multicast IPv4 L3VPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l3vpn-ipv4-multicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'l3vpn-ipv4-multicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/l3vpn-ipv6-multicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'l3vpn-ipv6-multicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_multicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/l3vpn-ipv6-multicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multicast IPv6 L3VPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l3vpn-ipv6-multicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'l3vpn-ipv6-multicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_vpls_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/l2vpn-vpls/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'l2vpn-vpls', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_vpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/l2vpn-vpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BGP-signalled VPLS configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l2vpn-vpls'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_vpls_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'l2vpn-vpls']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_vpls/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_vpls/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_vpls_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_vpls_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_vpls_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_vpls_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_evpn_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/l2vpn-evpn/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'l2vpn-evpn', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_evpn(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/l2vpn-evpn. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BGP EVPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l2vpn-evpn'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_evpn_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'l2vpn-evpn']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_evpn/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_evpn/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_evpn_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_evpn_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_evpn_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_evpn_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_use_multiple_paths_ebgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/use-multiple-paths/ebgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multi-path configuration for eBGP
  """
  __slots__ = ('_path_helper', '_extmethods', '__allow_multiple_as',)

  _yang_name = 'ebgp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__allow_multiple_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'use-multiple-paths', 'ebgp']

  def _get_allow_multiple_as(self):
    """
    Getter method for allow_multiple_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/use_multiple_paths/ebgp/allow_multiple_as (boolean)

    YANG Description: Allow multi-path to use paths from different neighboring
ASes. The default is to only consider multiple paths
from the same neighboring AS.
    """
    return self.__allow_multiple_as
      
  def _set_allow_multiple_as(self, v, load=False):
    """
    Setter method for allow_multiple_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/use_multiple_paths/ebgp/allow_multiple_as (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allow_multiple_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allow_multiple_as() directly.

    YANG Description: Allow multi-path to use paths from different neighboring
ASes. The default is to only consider multiple paths
from the same neighboring AS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allow_multiple_as must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__allow_multiple_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allow_multiple_as(self):
    self.__allow_multiple_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  allow_multiple_as = __builtin__.property(_get_allow_multiple_as, _set_allow_multiple_as)


  _pyangbind_elements = OrderedDict([('allow_multiple_as', allow_multiple_as), ])


class yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_use_multiple_paths(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi/use-multiple-paths. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__ebgp',)

  _yang_name = 'use-multiple-paths'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ebgp = YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi', 'use-multiple-paths']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/use_multiple_paths/enabled (boolean)

    YANG Description: Whether the use of multiple paths for the same NLRI is
enabled for the neighbor. This value is overridden by any
more specific configuration value.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/use_multiple_paths/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Whether the use of multiple paths for the same NLRI is
enabled for the neighbor. This value is overridden by any
more specific configuration value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ebgp(self):
    """
    Getter method for ebgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/use_multiple_paths/ebgp (container)

    YANG Description: Multi-path configuration for eBGP
    """
    return self.__ebgp
      
  def _set_ebgp(self, v, load=False):
    """
    Setter method for ebgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/use_multiple_paths/ebgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp() directly.

    YANG Description: Multi-path configuration for eBGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp(self):
    self.__ebgp = YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  ebgp = __builtin__.property(_get_ebgp, _set_ebgp) # type: yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_use_multiple_paths_ebgp


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('ebgp', ebgp), ])


class yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis/afi-safi. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: AFI, SAFI configuration available for the neighbor or
group
  """
  __slots__ = ('_path_helper', '_extmethods', '__afi_safi_name','__enabled','__active','__prefixes','__graceful_restart','__apply_policy','__ipv4_unicast','__ipv6_unicast','__ipv4_labeled_unicast','__ipv6_labeled_unicast','__l3vpn_ipv4_unicast','__l3vpn_ipv6_unicast','__l3vpn_ipv4_multicast','__l3vpn_ipv6_multicast','__l2vpn_vpls','__l2vpn_evpn','__use_multiple_paths',)

  _yang_name = 'afi-safi'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afi_safi_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__prefixes = YANGDynClass(base=yc_prefixes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__graceful_restart = YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__apply_policy = YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ipv4_unicast = YANGDynClass(base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ipv6_unicast = YANGDynClass(base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ipv4_labeled_unicast = YANGDynClass(base=yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_labeled_unicast, is_container='container', yang_name="ipv4-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ipv6_labeled_unicast = YANGDynClass(base=yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_labeled_unicast, is_container='container', yang_name="ipv6-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l3vpn_ipv4_unicast = YANGDynClass(base=yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_unicast, is_container='container', yang_name="l3vpn-ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l3vpn_ipv6_unicast = YANGDynClass(base=yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_unicast, is_container='container', yang_name="l3vpn-ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l3vpn_ipv4_multicast = YANGDynClass(base=yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_multicast, is_container='container', yang_name="l3vpn-ipv4-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l3vpn_ipv6_multicast = YANGDynClass(base=yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_multicast, is_container='container', yang_name="l3vpn-ipv6-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l2vpn_vpls = YANGDynClass(base=yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_vpls, is_container='container', yang_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l2vpn_evpn = YANGDynClass(base=yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_evpn, is_container='container', yang_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__use_multiple_paths = YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis', 'afi-safi']

  def _get_afi_safi_name(self):
    """
    Getter method for afi_safi_name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/afi_safi_name (identityref)

    YANG Description: AFI,SAFI
    """
    return self.__afi_safi_name
      
  def _set_afi_safi_name(self, v, load=False):
    """
    Setter method for afi_safi_name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/afi_safi_name (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safi_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safi_name() directly.

    YANG Description: AFI,SAFI
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safi_name must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=True)""",
        })

    self.__afi_safi_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safi_name(self):
    self.__afi_safi_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/enabled (boolean)

    YANG Description: This leaf indicates whether the IPv4 Unicast AFI,SAFI is
enabled for the neighbour or group
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf indicates whether the IPv4 Unicast AFI,SAFI is
enabled for the neighbour or group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/active (boolean)

    YANG Description: This value indicates whether a particular AFI-SAFI has
been successfully negotiated with the peer. An AFI-SAFI may
be enabled in the current running configuration, but a
session restart may be required in order to negotiate the
new capability.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/active (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: This value indicates whether a particular AFI-SAFI has
been successfully negotiated with the peer. An AFI-SAFI may
be enabled in the current running configuration, but a
session restart may be required in order to negotiate the
new capability.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_prefixes(self):
    """
    Getter method for prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/prefixes (container)

    YANG Description: Prefix counters for the BGP session
    """
    return self.__prefixes
      
  def _set_prefixes(self, v, load=False):
    """
    Setter method for prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/prefixes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefixes() directly.

    YANG Description: Prefix counters for the BGP session
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefixes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefixes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefixes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefixes(self):
    self.__prefixes = YANGDynClass(base=yc_prefixes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_prefixes, is_container='container', yang_name="prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/graceful_restart (container)

    YANG Description: Parameters relating to BGP graceful-restart
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: Parameters relating to BGP graceful-restart
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_apply_policy(self):
    """
    Getter method for apply_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/apply_policy (container)

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    return self.__apply_policy
      
  def _set_apply_policy(self, v, load=False):
    """
    Setter method for apply_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/apply_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_policy() directly.

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__apply_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_policy(self):
    self.__apply_policy = YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ipv4_unicast(self):
    """
    Getter method for ipv4_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_unicast (container)

    YANG Description: IPv4 unicast configuration options
    """
    return self.__ipv4_unicast
      
  def _set_ipv4_unicast(self, v, load=False):
    """
    Setter method for ipv4_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_unicast() directly.

    YANG Description: IPv4 unicast configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ipv4_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_unicast(self):
    self.__ipv4_unicast = YANGDynClass(base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ipv6_unicast(self):
    """
    Getter method for ipv6_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_unicast (container)

    YANG Description: IPv6 unicast configuration options
    """
    return self.__ipv6_unicast
      
  def _set_ipv6_unicast(self, v, load=False):
    """
    Setter method for ipv6_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_unicast() directly.

    YANG Description: IPv6 unicast configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ipv6_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_unicast(self):
    self.__ipv6_unicast = YANGDynClass(base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ipv4_labeled_unicast(self):
    """
    Getter method for ipv4_labeled_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_labeled_unicast (container)

    YANG Description: IPv4 Labeled Unicast configuration options
    """
    return self.__ipv4_labeled_unicast
      
  def _set_ipv4_labeled_unicast(self, v, load=False):
    """
    Setter method for ipv4_labeled_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv4_labeled_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_labeled_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_labeled_unicast() directly.

    YANG Description: IPv4 Labeled Unicast configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_labeled_unicast, is_container='container', yang_name="ipv4-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_labeled_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_labeled_unicast, is_container='container', yang_name="ipv4-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ipv4_labeled_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_labeled_unicast(self):
    self.__ipv4_labeled_unicast = YANGDynClass(base=yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_labeled_unicast, is_container='container', yang_name="ipv4-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ipv6_labeled_unicast(self):
    """
    Getter method for ipv6_labeled_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_labeled_unicast (container)

    YANG Description: IPv6 Labeled Unicast configuration options
    """
    return self.__ipv6_labeled_unicast
      
  def _set_ipv6_labeled_unicast(self, v, load=False):
    """
    Setter method for ipv6_labeled_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/ipv6_labeled_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_labeled_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_labeled_unicast() directly.

    YANG Description: IPv6 Labeled Unicast configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_labeled_unicast, is_container='container', yang_name="ipv6-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_labeled_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_labeled_unicast, is_container='container', yang_name="ipv6-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ipv6_labeled_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_labeled_unicast(self):
    self.__ipv6_labeled_unicast = YANGDynClass(base=yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_labeled_unicast, is_container='container', yang_name="ipv6-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l3vpn_ipv4_unicast(self):
    """
    Getter method for l3vpn_ipv4_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_unicast (container)

    YANG Description: Unicast IPv4 L3VPN configuration options
    """
    return self.__l3vpn_ipv4_unicast
      
  def _set_l3vpn_ipv4_unicast(self, v, load=False):
    """
    Setter method for l3vpn_ipv4_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3vpn_ipv4_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3vpn_ipv4_unicast() directly.

    YANG Description: Unicast IPv4 L3VPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_unicast, is_container='container', yang_name="l3vpn-ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3vpn_ipv4_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_unicast, is_container='container', yang_name="l3vpn-ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l3vpn_ipv4_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3vpn_ipv4_unicast(self):
    self.__l3vpn_ipv4_unicast = YANGDynClass(base=yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_unicast, is_container='container', yang_name="l3vpn-ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l3vpn_ipv6_unicast(self):
    """
    Getter method for l3vpn_ipv6_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_unicast (container)

    YANG Description: Unicast IPv6 L3VPN configuration options
    """
    return self.__l3vpn_ipv6_unicast
      
  def _set_l3vpn_ipv6_unicast(self, v, load=False):
    """
    Setter method for l3vpn_ipv6_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3vpn_ipv6_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3vpn_ipv6_unicast() directly.

    YANG Description: Unicast IPv6 L3VPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_unicast, is_container='container', yang_name="l3vpn-ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3vpn_ipv6_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_unicast, is_container='container', yang_name="l3vpn-ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l3vpn_ipv6_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3vpn_ipv6_unicast(self):
    self.__l3vpn_ipv6_unicast = YANGDynClass(base=yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_unicast, is_container='container', yang_name="l3vpn-ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l3vpn_ipv4_multicast(self):
    """
    Getter method for l3vpn_ipv4_multicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_multicast (container)

    YANG Description: Multicast IPv4 L3VPN configuration options
    """
    return self.__l3vpn_ipv4_multicast
      
  def _set_l3vpn_ipv4_multicast(self, v, load=False):
    """
    Setter method for l3vpn_ipv4_multicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv4_multicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3vpn_ipv4_multicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3vpn_ipv4_multicast() directly.

    YANG Description: Multicast IPv4 L3VPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_multicast, is_container='container', yang_name="l3vpn-ipv4-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3vpn_ipv4_multicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_multicast, is_container='container', yang_name="l3vpn-ipv4-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l3vpn_ipv4_multicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3vpn_ipv4_multicast(self):
    self.__l3vpn_ipv4_multicast = YANGDynClass(base=yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_multicast, is_container='container', yang_name="l3vpn-ipv4-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l3vpn_ipv6_multicast(self):
    """
    Getter method for l3vpn_ipv6_multicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_multicast (container)

    YANG Description: Multicast IPv6 L3VPN configuration options
    """
    return self.__l3vpn_ipv6_multicast
      
  def _set_l3vpn_ipv6_multicast(self, v, load=False):
    """
    Setter method for l3vpn_ipv6_multicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l3vpn_ipv6_multicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3vpn_ipv6_multicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3vpn_ipv6_multicast() directly.

    YANG Description: Multicast IPv6 L3VPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_multicast, is_container='container', yang_name="l3vpn-ipv6-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3vpn_ipv6_multicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_multicast, is_container='container', yang_name="l3vpn-ipv6-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l3vpn_ipv6_multicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3vpn_ipv6_multicast(self):
    self.__l3vpn_ipv6_multicast = YANGDynClass(base=yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_multicast, is_container='container', yang_name="l3vpn-ipv6-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l2vpn_vpls(self):
    """
    Getter method for l2vpn_vpls, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_vpls (container)

    YANG Description: BGP-signalled VPLS configuration options
    """
    return self.__l2vpn_vpls
      
  def _set_l2vpn_vpls(self, v, load=False):
    """
    Setter method for l2vpn_vpls, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_vpls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2vpn_vpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2vpn_vpls() directly.

    YANG Description: BGP-signalled VPLS configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_vpls, is_container='container', yang_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2vpn_vpls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_vpls, is_container='container', yang_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l2vpn_vpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2vpn_vpls(self):
    self.__l2vpn_vpls = YANGDynClass(base=yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_vpls, is_container='container', yang_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l2vpn_evpn(self):
    """
    Getter method for l2vpn_evpn, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_evpn (container)

    YANG Description: BGP EVPN configuration options
    """
    return self.__l2vpn_evpn
      
  def _set_l2vpn_evpn(self, v, load=False):
    """
    Setter method for l2vpn_evpn, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/l2vpn_evpn (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2vpn_evpn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2vpn_evpn() directly.

    YANG Description: BGP EVPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_evpn, is_container='container', yang_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2vpn_evpn must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_evpn, is_container='container', yang_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l2vpn_evpn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2vpn_evpn(self):
    self.__l2vpn_evpn = YANGDynClass(base=yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_evpn, is_container='container', yang_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_use_multiple_paths(self):
    """
    Getter method for use_multiple_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/use_multiple_paths (container)

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    return self.__use_multiple_paths
      
  def _set_use_multiple_paths(self, v, load=False):
    """
    Setter method for use_multiple_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi/use_multiple_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_multiple_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_multiple_paths() directly.

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_multiple_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__use_multiple_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_multiple_paths(self):
    self.__use_multiple_paths = YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  afi_safi_name = __builtin__.property(_get_afi_safi_name, _set_afi_safi_name)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  active = __builtin__.property(_get_active)
  prefixes = __builtin__.property(_get_prefixes, _set_prefixes) # type: yc_prefixes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_prefixes
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart) # type: yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_graceful_restart
  apply_policy = __builtin__.property(_get_apply_policy, _set_apply_policy) # type: yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_apply_policy
  ipv4_unicast = __builtin__.property(_get_ipv4_unicast, _set_ipv4_unicast) # type: yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_unicast
  ipv6_unicast = __builtin__.property(_get_ipv6_unicast, _set_ipv6_unicast) # type: yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_unicast
  ipv4_labeled_unicast = __builtin__.property(_get_ipv4_labeled_unicast, _set_ipv4_labeled_unicast) # type: yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv4_labeled_unicast
  ipv6_labeled_unicast = __builtin__.property(_get_ipv6_labeled_unicast, _set_ipv6_labeled_unicast) # type: yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_ipv6_labeled_unicast
  l3vpn_ipv4_unicast = __builtin__.property(_get_l3vpn_ipv4_unicast, _set_l3vpn_ipv4_unicast) # type: yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_unicast
  l3vpn_ipv6_unicast = __builtin__.property(_get_l3vpn_ipv6_unicast, _set_l3vpn_ipv6_unicast) # type: yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_unicast
  l3vpn_ipv4_multicast = __builtin__.property(_get_l3vpn_ipv4_multicast, _set_l3vpn_ipv4_multicast) # type: yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv4_multicast
  l3vpn_ipv6_multicast = __builtin__.property(_get_l3vpn_ipv6_multicast, _set_l3vpn_ipv6_multicast) # type: yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l3vpn_ipv6_multicast
  l2vpn_vpls = __builtin__.property(_get_l2vpn_vpls, _set_l2vpn_vpls) # type: yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_vpls
  l2vpn_evpn = __builtin__.property(_get_l2vpn_evpn, _set_l2vpn_evpn) # type: yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_l2vpn_evpn
  use_multiple_paths = __builtin__.property(_get_use_multiple_paths, _set_use_multiple_paths) # type: yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi_use_multiple_paths


  _pyangbind_elements = OrderedDict([('afi_safi_name', afi_safi_name), ('enabled', enabled), ('active', active), ('prefixes', prefixes), ('graceful_restart', graceful_restart), ('apply_policy', apply_policy), ('ipv4_unicast', ipv4_unicast), ('ipv6_unicast', ipv6_unicast), ('ipv4_labeled_unicast', ipv4_labeled_unicast), ('ipv6_labeled_unicast', ipv6_labeled_unicast), ('l3vpn_ipv4_unicast', l3vpn_ipv4_unicast), ('l3vpn_ipv6_unicast', l3vpn_ipv6_unicast), ('l3vpn_ipv4_multicast', l3vpn_ipv4_multicast), ('l3vpn_ipv6_multicast', l3vpn_ipv6_multicast), ('l2vpn_vpls', l2vpn_vpls), ('l2vpn_evpn', l2vpn_evpn), ('use_multiple_paths', use_multiple_paths), ])


class yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/afi-safis. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-address-family configuration parameters associated
with the neighbor
  """
  __slots__ = ('_path_helper', '_extmethods', '__afi_safi',)

  _yang_name = 'afi-safis'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afi_safi = YANGDynClass(base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'afi-safis']

  def _get_afi_safi(self):
    """
    Getter method for afi_safi, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi (list)

    YANG Description: AFI, SAFI configuration available for the neighbor or
group
    """
    return self.__afi_safi
      
  def _set_afi_safi(self, v, load=False):
    """
    Setter method for afi_safi, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis/afi_safi (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safi() directly.

    YANG Description: AFI, SAFI configuration available for the neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safi must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)""",
        })

    self.__afi_safi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safi(self):
    self.__afi_safi = YANGDynClass(base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)

  afi_safi = __builtin__.property(_get_afi_safi, _set_afi_safi) # type: yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis_afi_safi


  _pyangbind_elements = OrderedDict([('afi_safi', afi_safi), ])


class yc_sent_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages_sent(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/statistics/messages/sent. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Counters relating to BGP messages sent to the
neighbor
  """
  __slots__ = ('_path_helper', '_extmethods', '__updates_received','__updates_sent','__messages_received','__messages_sent','__notification',)

  _yang_name = 'sent'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__updates_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    self.__updates_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    self.__messages_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    self.__messages_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    self.__notification = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'statistics', 'messages', 'sent']

  def _get_updates_received(self):
    """
    Getter method for updates_received, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/sent/updates_received (uint64)

    YANG Description: Number of BGP UPDATE messages received from this neighbor.
    """
    return self.__updates_received
      
  def _set_updates_received(self, v, load=False):
    """
    Setter method for updates_received, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/sent/updates_received (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_updates_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_updates_received() directly.

    YANG Description: Number of BGP UPDATE messages received from this neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """updates_received must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__updates_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_updates_received(self):
    self.__updates_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)


  def _get_updates_sent(self):
    """
    Getter method for updates_sent, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/sent/updates_sent (uint64)

    YANG Description: Number of BGP UPDATE messages sent to this neighbor
    """
    return self.__updates_sent
      
  def _set_updates_sent(self, v, load=False):
    """
    Setter method for updates_sent, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/sent/updates_sent (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_updates_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_updates_sent() directly.

    YANG Description: Number of BGP UPDATE messages sent to this neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """updates_sent must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__updates_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_updates_sent(self):
    self.__updates_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)


  def _get_messages_received(self):
    """
    Getter method for messages_received, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/sent/messages_received (uint64)

    YANG Description: Number of BGP messages received from thsi neighbor
    """
    return self.__messages_received
      
  def _set_messages_received(self, v, load=False):
    """
    Setter method for messages_received, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/sent/messages_received (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_messages_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_messages_received() directly.

    YANG Description: Number of BGP messages received from thsi neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """messages_received must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__messages_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_messages_received(self):
    self.__messages_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)


  def _get_messages_sent(self):
    """
    Getter method for messages_sent, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/sent/messages_sent (uint64)

    YANG Description: Number of BGP messages received from thsi neighbor
    """
    return self.__messages_sent
      
  def _set_messages_sent(self, v, load=False):
    """
    Setter method for messages_sent, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/sent/messages_sent (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_messages_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_messages_sent() directly.

    YANG Description: Number of BGP messages received from thsi neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """messages_sent must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__messages_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_messages_sent(self):
    self.__messages_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)


  def _get_notification(self):
    """
    Getter method for notification, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/sent/notification (uint64)

    YANG Description: Number of BGP NOTIFICATION messages indicating an error
condition has occurred exchanged.
    """
    return self.__notification
      
  def _set_notification(self, v, load=False):
    """
    Setter method for notification, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/sent/notification (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_notification is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_notification() directly.

    YANG Description: Number of BGP NOTIFICATION messages indicating an error
condition has occurred exchanged.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """notification must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__notification = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_notification(self):
    self.__notification = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)

  updates_received = __builtin__.property(_get_updates_received)
  updates_sent = __builtin__.property(_get_updates_sent)
  messages_received = __builtin__.property(_get_messages_received)
  messages_sent = __builtin__.property(_get_messages_sent)
  notification = __builtin__.property(_get_notification)


  _pyangbind_elements = OrderedDict([('updates_received', updates_received), ('updates_sent', updates_sent), ('messages_received', messages_received), ('messages_sent', messages_sent), ('notification', notification), ])


class yc_received_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages_received(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/statistics/messages/received. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Counters for BGP messages received from the
neighbor
  """
  __slots__ = ('_path_helper', '_extmethods', '__updates_received','__updates_sent','__messages_received','__messages_sent','__notification',)

  _yang_name = 'received'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__updates_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    self.__updates_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    self.__messages_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    self.__messages_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    self.__notification = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'statistics', 'messages', 'received']

  def _get_updates_received(self):
    """
    Getter method for updates_received, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/received/updates_received (uint64)

    YANG Description: Number of BGP UPDATE messages received from this neighbor.
    """
    return self.__updates_received
      
  def _set_updates_received(self, v, load=False):
    """
    Setter method for updates_received, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/received/updates_received (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_updates_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_updates_received() directly.

    YANG Description: Number of BGP UPDATE messages received from this neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """updates_received must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__updates_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_updates_received(self):
    self.__updates_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)


  def _get_updates_sent(self):
    """
    Getter method for updates_sent, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/received/updates_sent (uint64)

    YANG Description: Number of BGP UPDATE messages sent to this neighbor
    """
    return self.__updates_sent
      
  def _set_updates_sent(self, v, load=False):
    """
    Setter method for updates_sent, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/received/updates_sent (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_updates_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_updates_sent() directly.

    YANG Description: Number of BGP UPDATE messages sent to this neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """updates_sent must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__updates_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_updates_sent(self):
    self.__updates_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="updates-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)


  def _get_messages_received(self):
    """
    Getter method for messages_received, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/received/messages_received (uint64)

    YANG Description: Number of BGP messages received from thsi neighbor
    """
    return self.__messages_received
      
  def _set_messages_received(self, v, load=False):
    """
    Setter method for messages_received, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/received/messages_received (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_messages_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_messages_received() directly.

    YANG Description: Number of BGP messages received from thsi neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """messages_received must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__messages_received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_messages_received(self):
    self.__messages_received = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)


  def _get_messages_sent(self):
    """
    Getter method for messages_sent, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/received/messages_sent (uint64)

    YANG Description: Number of BGP messages received from thsi neighbor
    """
    return self.__messages_sent
      
  def _set_messages_sent(self, v, load=False):
    """
    Setter method for messages_sent, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/received/messages_sent (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_messages_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_messages_sent() directly.

    YANG Description: Number of BGP messages received from thsi neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """messages_sent must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__messages_sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_messages_sent(self):
    self.__messages_sent = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="messages-sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)


  def _get_notification(self):
    """
    Getter method for notification, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/received/notification (uint64)

    YANG Description: Number of BGP NOTIFICATION messages indicating an error
condition has occurred exchanged.
    """
    return self.__notification
      
  def _set_notification(self, v, load=False):
    """
    Setter method for notification, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/received/notification (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_notification is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_notification() directly.

    YANG Description: Number of BGP NOTIFICATION messages indicating an error
condition has occurred exchanged.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """notification must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__notification = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_notification(self):
    self.__notification = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="notification", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)

  updates_received = __builtin__.property(_get_updates_received)
  updates_sent = __builtin__.property(_get_updates_sent)
  messages_received = __builtin__.property(_get_messages_received)
  messages_sent = __builtin__.property(_get_messages_sent)
  notification = __builtin__.property(_get_notification)


  _pyangbind_elements = OrderedDict([('updates_received', updates_received), ('updates_sent', updates_sent), ('messages_received', messages_received), ('messages_sent', messages_sent), ('notification', notification), ])


class yc_messages_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/statistics/messages. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Counters for BGP messages sent and received from the
neighbor
  """
  __slots__ = ('_path_helper', '_extmethods', '__in_total_messages','__out_total_messages','__in_update_elapsed_time','__sent','__received',)

  _yang_name = 'messages'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__in_total_messages = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-total-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter32', is_config=False)
    self.__out_total_messages = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-total-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter32', is_config=False)
    self.__in_update_elapsed_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-update-elapsed-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=False)
    self.__sent = YANGDynClass(base=yc_sent_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages_sent, is_container='container', yang_name="sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__received = YANGDynClass(base=yc_received_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages_received, is_container='container', yang_name="received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'statistics', 'messages']

  def _get_in_total_messages(self):
    """
    Getter method for in_total_messages, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/in_total_messages (yang:counter32)

    YANG Description: The total number of messages received
from the remote peer on this connection.
    """
    return self.__in_total_messages
      
  def _set_in_total_messages(self, v, load=False):
    """
    Setter method for in_total_messages, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/in_total_messages (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_total_messages is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_total_messages() directly.

    YANG Description: The total number of messages received
from the remote peer on this connection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-total-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_total_messages must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-total-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter32', is_config=False)""",
        })

    self.__in_total_messages = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_total_messages(self):
    self.__in_total_messages = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-total-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter32', is_config=False)


  def _get_out_total_messages(self):
    """
    Getter method for out_total_messages, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/out_total_messages (yang:counter32)

    YANG Description: The total number of messages transmitted to
the remote peer on this connection.
    """
    return self.__out_total_messages
      
  def _set_out_total_messages(self, v, load=False):
    """
    Setter method for out_total_messages, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/out_total_messages (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_total_messages is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_total_messages() directly.

    YANG Description: The total number of messages transmitted to
the remote peer on this connection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-total-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_total_messages must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-total-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter32', is_config=False)""",
        })

    self.__out_total_messages = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_total_messages(self):
    self.__out_total_messages = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="out-total-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter32', is_config=False)


  def _get_in_update_elapsed_time(self):
    """
    Getter method for in_update_elapsed_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/in_update_elapsed_time (yang:gauge32)

    YANG Description: Elapsed time (in seconds) since the last BGP
UPDATE message was received from the peer.
Each time in-updates is incremented,
the value of this object is set to zero (0).
    """
    return self.__in_update_elapsed_time
      
  def _set_in_update_elapsed_time(self, v, load=False):
    """
    Setter method for in_update_elapsed_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/in_update_elapsed_time (yang:gauge32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_update_elapsed_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_update_elapsed_time() directly.

    YANG Description: Elapsed time (in seconds) since the last BGP
UPDATE message was received from the peer.
Each time in-updates is incremented,
the value of this object is set to zero (0).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-update-elapsed-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_update_elapsed_time must be of a type compatible with yang:gauge32""",
          'defined-type': "yang:gauge32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-update-elapsed-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=False)""",
        })

    self.__in_update_elapsed_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_update_elapsed_time(self):
    self.__in_update_elapsed_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="in-update-elapsed-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=False)


  def _get_sent(self):
    """
    Getter method for sent, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/sent (container)

    YANG Description: Counters relating to BGP messages sent to the
neighbor
    """
    return self.__sent
      
  def _set_sent(self, v, load=False):
    """
    Setter method for sent, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/sent (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sent() directly.

    YANG Description: Counters relating to BGP messages sent to the
neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sent_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages_sent, is_container='container', yang_name="sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sent must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sent_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages_sent, is_container='container', yang_name="sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__sent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sent(self):
    self.__sent = YANGDynClass(base=yc_sent_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages_sent, is_container='container', yang_name="sent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_received(self):
    """
    Getter method for received, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/received (container)

    YANG Description: Counters for BGP messages received from the
neighbor
    """
    return self.__received
      
  def _set_received(self, v, load=False):
    """
    Setter method for received, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages/received (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_received is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_received() directly.

    YANG Description: Counters for BGP messages received from the
neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_received_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages_received, is_container='container', yang_name="received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """received must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_received_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages_received, is_container='container', yang_name="received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__received = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_received(self):
    self.__received = YANGDynClass(base=yc_received_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages_received, is_container='container', yang_name="received", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  in_total_messages = __builtin__.property(_get_in_total_messages)
  out_total_messages = __builtin__.property(_get_out_total_messages)
  in_update_elapsed_time = __builtin__.property(_get_in_update_elapsed_time)
  sent = __builtin__.property(_get_sent) # type: yc_sent_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages_sent
  received = __builtin__.property(_get_received) # type: yc_received_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages_received


  _pyangbind_elements = OrderedDict([('in_total_messages', in_total_messages), ('out_total_messages', out_total_messages), ('in_update_elapsed_time', in_update_elapsed_time), ('sent', sent), ('received', received), ])


class yc_queues_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_queues(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/statistics/queues. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Counters related to queued messages associated with
the BGP neighbor
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__output',)

  _yang_name = 'queues'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__output = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'statistics', 'queues']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/queues/input (uint32)

    YANG Description: The number of messages received from the peer
currently queued
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/queues/input (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.

    YANG Description: The number of messages received from the peer
currently queued
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/queues/output (uint32)

    YANG Description: The number of messages queued to be sent to the
peer
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/queues/output (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.

    YANG Description: The number of messages queued to be sent to the
peer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)

  input = __builtin__.property(_get_input)
  output = __builtin__.property(_get_output)


  _pyangbind_elements = OrderedDict([('input', input), ('output', output), ])


class yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/statistics/clear/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_at',)

  _yang_name = 'input'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'statistics', 'clear', 'input']

  def _get_clear_at(self):
    """
    Getter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/clear/input/clear_at (yang:date-and-time)

    YANG Description: Time when the clear action needs to be
executed.
    """
    return self.__clear_at
      
  def _set_clear_at(self, v, load=False):
    """
    Setter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/clear/input/clear_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_at() directly.

    YANG Description: Time when the clear action needs to be
executed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__clear_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_at(self):
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)

  clear_at = __builtin__.property(_get_clear_at, _set_clear_at)


  _pyangbind_elements = OrderedDict([('clear_at', clear_at), ])


class yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/statistics/clear/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_finished_at',)

  _yang_name = 'output'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'statistics', 'clear', 'output']

  def _get_clear_finished_at(self):
    """
    Getter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/clear/output/clear_finished_at (yang:date-and-time)

    YANG Description: Time when the clear action command completed.
    """
    return self.__clear_finished_at
      
  def _set_clear_finished_at(self, v, load=False):
    """
    Setter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/clear/output/clear_finished_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_finished_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_finished_at() directly.

    YANG Description: Time when the clear action command completed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_finished_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__clear_finished_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_finished_at(self):
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)

  clear_finished_at = __builtin__.property(_get_clear_finished_at, _set_clear_finished_at)


  _pyangbind_elements = OrderedDict([('clear_finished_at', clear_finished_at), ])


class yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/statistics/clear. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Clear statistics action command.

Execution of this command should result in all the
counters to be cleared and set to 0.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__output',)

  _yang_name = 'clear'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=True)
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'statistics', 'clear']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/clear/input (input)
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/clear/input (input)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with input""",
          'defined-type': "ietf-bgp:input",
          'generated-type': """YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=True)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=True)


  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/clear/output (output)
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/clear/output (output)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with output""",
          'defined-type': "ietf-bgp:output",
          'generated-type': """YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=True)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=True)

  input = __builtin__.property(_get_input, _set_input)
  output = __builtin__.property(_get_output, _set_output)


  _pyangbind_elements = OrderedDict([('input', input), ('output', output), ])


class yc_statistics_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor/statistics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics per neighbor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__established_transitions','__fsm_established_transitions','__messages','__queues','__clear',)

  _yang_name = 'statistics'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__established_transitions = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="established-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter64', is_config=False)
    self.__fsm_established_transitions = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="fsm-established-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter32', is_config=False)
    self.__messages = YANGDynClass(base=yc_messages_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages, is_container='container', yang_name="messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__queues = YANGDynClass(base=yc_queues_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_queues, is_container='container', yang_name="queues", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor', 'statistics']

  def _get_established_transitions(self):
    """
    Getter method for established_transitions, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/established_transitions (yang:counter64)

    YANG Description: Number of transitions to the Established state for
the neighbor session. This value is analogous to the
bgpPeerFsmEstablishedTransitions object from the
standard BGP-4 MIB
    """
    return self.__established_transitions
      
  def _set_established_transitions(self, v, load=False):
    """
    Setter method for established_transitions, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/established_transitions (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_established_transitions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_established_transitions() directly.

    YANG Description: Number of transitions to the Established state for
the neighbor session. This value is analogous to the
bgpPeerFsmEstablishedTransitions object from the
standard BGP-4 MIB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="established-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """established_transitions must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="established-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter64', is_config=False)""",
        })

    self.__established_transitions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_established_transitions(self):
    self.__established_transitions = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="established-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter64', is_config=False)


  def _get_fsm_established_transitions(self):
    """
    Getter method for fsm_established_transitions, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/fsm_established_transitions (yang:counter32)

    YANG Description: The total number of times the BGP FSM
transitioned into the established state
for this peer.
    """
    return self.__fsm_established_transitions
      
  def _set_fsm_established_transitions(self, v, load=False):
    """
    Setter method for fsm_established_transitions, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/fsm_established_transitions (yang:counter32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fsm_established_transitions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fsm_established_transitions() directly.

    YANG Description: The total number of times the BGP FSM
transitioned into the established state
for this peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="fsm-established-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fsm_established_transitions must be of a type compatible with yang:counter32""",
          'defined-type': "yang:counter32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="fsm-established-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter32', is_config=False)""",
        })

    self.__fsm_established_transitions = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fsm_established_transitions(self):
    self.__fsm_established_transitions = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="fsm-established-transitions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:counter32', is_config=False)


  def _get_messages(self):
    """
    Getter method for messages, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages (container)

    YANG Description: Counters for BGP messages sent and received from the
neighbor
    """
    return self.__messages
      
  def _set_messages(self, v, load=False):
    """
    Setter method for messages, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/messages (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_messages is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_messages() directly.

    YANG Description: Counters for BGP messages sent and received from the
neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_messages_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages, is_container='container', yang_name="messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """messages must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_messages_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages, is_container='container', yang_name="messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__messages = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_messages(self):
    self.__messages = YANGDynClass(base=yc_messages_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages, is_container='container', yang_name="messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_queues(self):
    """
    Getter method for queues, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/queues (container)

    YANG Description: Counters related to queued messages associated with
the BGP neighbor
    """
    return self.__queues
      
  def _set_queues(self, v, load=False):
    """
    Setter method for queues, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/queues (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_queues is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_queues() directly.

    YANG Description: Counters related to queued messages associated with
the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_queues_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_queues, is_container='container', yang_name="queues", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """queues must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_queues_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_queues, is_container='container', yang_name="queues", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__queues = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_queues(self):
    self.__queues = YANGDynClass(base=yc_queues_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_queues, is_container='container', yang_name="queues", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_clear(self):
    """
    Getter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/clear (action)

    YANG Description: Clear statistics action command.

Execution of this command should result in all the
counters to be cleared and set to 0.
    """
    return self.__clear
      
  def _set_clear(self, v, load=False):
    """
    Setter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics/clear (action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear() directly.

    YANG Description: Clear statistics action command.

Execution of this command should result in all the
counters to be cleared and set to 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear must be of a type compatible with action""",
          'defined-type': "ietf-bgp:action",
          'generated-type': """YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=True)""",
        })

    self.__clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear(self):
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=True)

  established_transitions = __builtin__.property(_get_established_transitions)
  fsm_established_transitions = __builtin__.property(_get_fsm_established_transitions)
  messages = __builtin__.property(_get_messages, _set_messages) # type: yc_messages_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_messages
  queues = __builtin__.property(_get_queues, _set_queues) # type: yc_queues_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics_queues
  clear = __builtin__.property(_get_clear, _set_clear)


  _pyangbind_elements = OrderedDict([('established_transitions', established_transitions), ('fsm_established_transitions', fsm_established_transitions), ('messages', messages), ('queues', queues), ('clear', clear), ])


class yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP neighbors configured on the local system,
uniquely identified by remote IPv[46] address
  """
  __slots__ = ('_path_helper', '_extmethods', '__local_address','__local_port','__peer_type','__peer_group','__identifier','__remote_address','__remote_port','__enabled','__secure_session_enable','__secure_session','__ttl_security','__remote_as','__peer_as','__local_as','__remove_private_as','__route_flap_damping','__send_community','__description','__route_selection_options','__session_state','__last_established','__supported_capabilities','__negotiated_hold_time','__last_error','__fsm_established_time','__timers','__transport','__treat_as_withdraw','__erroneous_update_messages','__graceful_restart','__logging_options','__ebgp_multihop','__route_reflector','__as_path_options','__add_paths','__use_multiple_paths','__apply_policy','__afi_safis','__statistics',)

  _yang_name = 'neighbor'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__local_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)
    self.__local_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="local-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:port-number', is_config=False)
    self.__peer_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'internal': {}, 'external': {}, 'confederation': {}},), is_leaf=True, yang_name="peer-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:peer-type', is_config=False)
    self.__peer_group = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peer-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__identifier = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=False)
    self.__remote_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=True)
    self.__remote_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="remote-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:port-number', is_config=False)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__secure_session_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="secure-session-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__secure_session = YANGDynClass(base=yc_secure_session_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_secure_session, is_container='container', yang_name="secure-session", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ttl_security = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="ttl-security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    self.__remote_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    self.__peer_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    self.__local_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    self.__remove_private_as = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="remove-private-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:remove-private-as-option', is_config=True)
    self.__route_flap_damping = YANGDynClass(base=yc_route_flap_damping_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_flap_damping, is_container='container', yang_name="route-flap-damping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__send_community = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="send-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:community-type', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)
    self.__route_selection_options = YANGDynClass(base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__session_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'idle': {}, 'connect': {}, 'active': {}, 'opensent': {}, 'openconfirm': {}, 'established': {}},), is_leaf=True, yang_name="session-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='enumeration', is_config=True)
    self.__last_established = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-established", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    self.__supported_capabilities = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'mp-bgp': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:mp-bgp': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:mp-bgp': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'route-refresh': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:route-refresh': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:route-refresh': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'asn32': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:asn32': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:asn32': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'graceful-restart': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:graceful-restart': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:graceful-restart': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'add-paths': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:add-paths': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:add-paths': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},)), is_leaf=False, yang_name="supported-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    self.__negotiated_hold_time = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="negotiated-hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=False)
    self.__last_error = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['2']}), is_leaf=True, yang_name="last-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=True)
    self.__fsm_established_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="fsm-established-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=False)
    self.__timers = YANGDynClass(base=yc_timers_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__transport = YANGDynClass(base=yc_transport_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__treat_as_withdraw = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="treat-as-withdraw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__erroneous_update_messages = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="erroneous-update-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__graceful_restart = YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__logging_options = YANGDynClass(base=yc_logging_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ebgp_multihop = YANGDynClass(base=yc_ebgp_multihop_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__route_reflector = YANGDynClass(base=yc_route_reflector_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__as_path_options = YANGDynClass(base=yc_as_path_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__add_paths = YANGDynClass(base=yc_add_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_add_paths, is_container='container', yang_name="add-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__use_multiple_paths = YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__apply_policy = YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__afi_safis = YANGDynClass(base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__statistics = YANGDynClass(base=yc_statistics_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'neighbor']

  def _get_local_address(self):
    """
    Getter method for local_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/local_address (inet:ip-address)

    YANG Description: The local IP address of this entry's BGP connection.
    """
    return self.__local_address
      
  def _set_local_address(self, v, load=False):
    """
    Setter method for local_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/local_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_address() directly.

    YANG Description: The local IP address of this entry's BGP connection.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)""",
        })

    self.__local_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_address(self):
    self.__local_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)


  def _get_local_port(self):
    """
    Getter method for local_port, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/local_port (inet:port-number)

    YANG Description: The local port for the TCP connection between
the BGP peers.
    """
    return self.__local_port
      
  def _set_local_port(self, v, load=False):
    """
    Setter method for local_port, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/local_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_port() directly.

    YANG Description: The local port for the TCP connection between
the BGP peers.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="local-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:port-number', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="local-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:port-number', is_config=False)""",
        })

    self.__local_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_port(self):
    self.__local_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="local-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:port-number', is_config=False)


  def _get_peer_type(self):
    """
    Getter method for peer_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/peer_type (bt:peer-type)

    YANG Description: The type of peering session associated with this
neighbor.
    """
    return self.__peer_type
      
  def _set_peer_type(self, v, load=False):
    """
    Setter method for peer_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/peer_type (bt:peer-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_type() directly.

    YANG Description: The type of peering session associated with this
neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'internal': {}, 'external': {}, 'confederation': {}},), is_leaf=True, yang_name="peer-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:peer-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_type must be of a type compatible with bt:peer-type""",
          'defined-type': "bt:peer-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'internal': {}, 'external': {}, 'confederation': {}},), is_leaf=True, yang_name="peer-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:peer-type', is_config=False)""",
        })

    self.__peer_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_type(self):
    self.__peer_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'internal': {}, 'external': {}, 'confederation': {}},), is_leaf=True, yang_name="peer-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:peer-type', is_config=False)


  def _get_peer_group(self):
    """
    Getter method for peer_group, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/peer_group (leafref)

    YANG Description: The peer-group with which this neighbor is associated
    """
    return self.__peer_group
      
  def _set_peer_group(self, v, load=False):
    """
    Setter method for peer_group, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/peer_group (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_group() directly.

    YANG Description: The peer-group with which this neighbor is associated
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="peer-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_group must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peer-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__peer_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_group(self):
    self.__peer_group = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peer-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_identifier(self):
    """
    Getter method for identifier, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/identifier (yang:dotted-quad)

    YANG Description: The BGP Identifier of this entry's BGP peer.
This entry MUST be 0.0.0.0 unless the
sessionstate is in the openconfirm or the
established state.
    """
    return self.__identifier
      
  def _set_identifier(self, v, load=False):
    """
    Setter method for identifier, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/identifier (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_identifier() directly.

    YANG Description: The BGP Identifier of this entry's BGP peer.
This entry MUST be 0.0.0.0 unless the
sessionstate is in the openconfirm or the
established state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """identifier must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=False)""",
        })

    self.__identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_identifier(self):
    self.__identifier = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=False)


  def _get_remote_address(self):
    """
    Getter method for remote_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/remote_address (inet:ip-address)

    YANG Description: The remote IP address of this entry's BGP peer.
    """
    return self.__remote_address
      
  def _set_remote_address(self, v, load=False):
    """
    Setter method for remote_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/remote_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_address() directly.

    YANG Description: The remote IP address of this entry's BGP peer.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__remote_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_address(self):
    self.__remote_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=True)


  def _get_remote_port(self):
    """
    Getter method for remote_port, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/remote_port (inet:port-number)

    YANG Description: The remote port for the TCP connection
between the BGP peers.  Note that the
objects local-addr, local-port, remote-addr, and
reemote-port provide the appropriate
reference to the standard MIB TCP
connection table.
    """
    return self.__remote_port
      
  def _set_remote_port(self, v, load=False):
    """
    Setter method for remote_port, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/remote_port (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_port() directly.

    YANG Description: The remote port for the TCP connection
between the BGP peers.  Note that the
objects local-addr, local-port, remote-addr, and
reemote-port provide the appropriate
reference to the standard MIB TCP
connection table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="remote-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:port-number', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_port must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="remote-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:port-number', is_config=False)""",
        })

    self.__remote_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_port(self):
    self.__remote_port = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="remote-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:port-number', is_config=False)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/enabled (boolean)

    YANG Description: Whether the BGP peer is enabled. In cases where the
enabled leaf is set to false, the local system should
not initiate connections to the neighbor, and should
not respond to TCP connections attempts from the
neighbor. If the state of the BGP session is
ESTABLISHED at the time that this leaf is set to false,
the BGP session should be ceased.

A transition from 'false' to 'true' will cause
the BGP Manual Start Event to be generated.
A transition from 'true' to 'false' will cause
the BGP Manual Stop Event to be generated.
This parameter can be used to restart BGP peer
connections. Care should be used in providing
write access to this object without adequate
authentication.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Whether the BGP peer is enabled. In cases where the
enabled leaf is set to false, the local system should
not initiate connections to the neighbor, and should
not respond to TCP connections attempts from the
neighbor. If the state of the BGP session is
ESTABLISHED at the time that this leaf is set to false,
the BGP session should be ceased.

A transition from 'false' to 'true' will cause
the BGP Manual Start Event to be generated.
A transition from 'true' to 'false' will cause
the BGP Manual Stop Event to be generated.
This parameter can be used to restart BGP peer
connections. Care should be used in providing
write access to this object without adequate
authentication.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_secure_session_enable(self):
    """
    Getter method for secure_session_enable, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session_enable (boolean)

    YANG Description: Does this session need to be secured?
    """
    return self.__secure_session_enable
      
  def _set_secure_session_enable(self, v, load=False):
    """
    Setter method for secure_session_enable, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secure_session_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secure_session_enable() directly.

    YANG Description: Does this session need to be secured?
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="secure-session-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secure_session_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="secure-session-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__secure_session_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secure_session_enable(self):
    self.__secure_session_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="secure-session-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_secure_session(self):
    """
    Getter method for secure_session, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session (container)

    YANG Description: Container for describing how a particular BGP session
is to be secured.
    """
    return self.__secure_session
      
  def _set_secure_session(self, v, load=False):
    """
    Setter method for secure_session, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/secure_session (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secure_session is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secure_session() directly.

    YANG Description: Container for describing how a particular BGP session
is to be secured.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_secure_session_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_secure_session, is_container='container', yang_name="secure-session", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secure_session must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_secure_session_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_secure_session, is_container='container', yang_name="secure-session", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__secure_session = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secure_session(self):
    self.__secure_session = YANGDynClass(base=yc_secure_session_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_secure_session, is_container='container', yang_name="secure-session", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ttl_security(self):
    """
    Getter method for ttl_security, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/ttl_security (uint8)

    YANG Description: BGP Time To Live (TTL) security check.
    """
    return self.__ttl_security
      
  def _set_ttl_security(self, v, load=False):
    """
    Setter method for ttl_security, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/ttl_security (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ttl_security is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ttl_security() directly.

    YANG Description: BGP Time To Live (TTL) security check.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="ttl-security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ttl_security must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="ttl-security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__ttl_security = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ttl_security(self):
    self.__ttl_security = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(255), is_leaf=True, yang_name="ttl-security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)


  def _get_remote_as(self):
    """
    Getter method for remote_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/remote_as (inet:as-number)

    YANG Description: The remote autonomous system number received in
the BGP OPEN message.
    """
    return self.__remote_as
      
  def _set_remote_as(self, v, load=False):
    """
    Setter method for remote_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/remote_as (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_as() directly.

    YANG Description: The remote autonomous system number received in
the BGP OPEN message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_as must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)""",
        })

    self.__remote_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_as(self):
    self.__remote_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)


  def _get_peer_as(self):
    """
    Getter method for peer_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/peer_as (inet:as-number)

    YANG Description: AS number of the peer.
    """
    return self.__peer_as
      
  def _set_peer_as(self, v, load=False):
    """
    Setter method for peer_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/peer_as (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_as() directly.

    YANG Description: AS number of the peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_as must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)""",
        })

    self.__peer_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_as(self):
    self.__peer_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)


  def _get_local_as(self):
    """
    Getter method for local_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/local_as (inet:as-number)

    YANG Description: The local autonomous system number that is to be used when
establishing sessions with the remote peer or peer group, if
this differs from the global BGP router autonomous system
number.
    """
    return self.__local_as
      
  def _set_local_as(self, v, load=False):
    """
    Setter method for local_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/local_as (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_as() directly.

    YANG Description: The local autonomous system number that is to be used when
establishing sessions with the remote peer or peer group, if
this differs from the global BGP router autonomous system
number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_as must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)""",
        })

    self.__local_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_as(self):
    self.__local_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)


  def _get_remove_private_as(self):
    """
    Getter method for remove_private_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/remove_private_as (bt:remove-private-as-option)

    YANG Description: Remove private AS numbers from updates sent to peers - when
this leaf is not specified, the AS_PATH attribute should be
sent to the peer unchanged
    """
    return self.__remove_private_as
      
  def _set_remove_private_as(self, v, load=False):
    """
    Setter method for remove_private_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/remove_private_as (bt:remove-private-as-option)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remove_private_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remove_private_as() directly.

    YANG Description: Remove private AS numbers from updates sent to peers - when
this leaf is not specified, the AS_PATH attribute should be
sent to the peer unchanged
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="remove-private-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:remove-private-as-option', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remove_private_as must be of a type compatible with bt:remove-private-as-option""",
          'defined-type': "bt:remove-private-as-option",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="remove-private-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:remove-private-as-option', is_config=True)""",
        })

    self.__remove_private_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remove_private_as(self):
    self.__remove_private_as = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="remove-private-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:remove-private-as-option', is_config=True)


  def _get_route_flap_damping(self):
    """
    Getter method for route_flap_damping, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping (container)

    YANG Description: Routes learned via BGP are subject to weighted route
dampening.
    """
    return self.__route_flap_damping
      
  def _set_route_flap_damping(self, v, load=False):
    """
    Setter method for route_flap_damping, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_flap_damping (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_flap_damping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_flap_damping() directly.

    YANG Description: Routes learned via BGP are subject to weighted route
dampening.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_route_flap_damping_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_flap_damping, is_container='container', yang_name="route-flap-damping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_flap_damping must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_route_flap_damping_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_flap_damping, is_container='container', yang_name="route-flap-damping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_flap_damping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_flap_damping(self):
    self.__route_flap_damping = YANGDynClass(base=yc_route_flap_damping_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_flap_damping, is_container='container', yang_name="route-flap-damping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_send_community(self):
    """
    Getter method for send_community, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/send_community (bt:community-type)

    YANG Description: When supported, this tells the router to propogate any
prefixes that are attached to this community. The value
of 0 implies 'none'.
    """
    return self.__send_community
      
  def _set_send_community(self, v, load=False):
    """
    Setter method for send_community, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/send_community (bt:community-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_community() directly.

    YANG Description: When supported, this tells the router to propogate any
prefixes that are attached to this community. The value
of 0 implies 'none'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="send-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:community-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_community must be of a type compatible with bt:community-type""",
          'defined-type': "bt:community-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="send-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:community-type', is_config=True)""",
        })

    self.__send_community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_community(self):
    self.__send_community = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="send-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:community-type', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/description (string)

    YANG Description: An optional textual description (intended primarily for use
with a peer or group
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: An optional textual description (intended primarily for use
with a peer or group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)


  def _get_route_selection_options(self):
    """
    Getter method for route_selection_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options (container)

    YANG Description: Parameters relating to options for route selection
    """
    return self.__route_selection_options
      
  def _set_route_selection_options(self, v, load=False):
    """
    Setter method for route_selection_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_selection_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_selection_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_selection_options() directly.

    YANG Description: Parameters relating to options for route selection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_selection_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_selection_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_selection_options(self):
    self.__route_selection_options = YANGDynClass(base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_session_state(self):
    """
    Getter method for session_state, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/session_state (enumeration)

    YANG Description: The BGP peer connection state.
    """
    return self.__session_state
      
  def _set_session_state(self, v, load=False):
    """
    Setter method for session_state, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/session_state (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_session_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_session_state() directly.

    YANG Description: The BGP peer connection state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'idle': {}, 'connect': {}, 'active': {}, 'opensent': {}, 'openconfirm': {}, 'established': {}},), is_leaf=True, yang_name="session-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """session_state must be of a type compatible with enumeration""",
          'defined-type': "ietf-bgp:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'idle': {}, 'connect': {}, 'active': {}, 'opensent': {}, 'openconfirm': {}, 'established': {}},), is_leaf=True, yang_name="session-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='enumeration', is_config=True)""",
        })

    self.__session_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_session_state(self):
    self.__session_state = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'idle': {}, 'connect': {}, 'active': {}, 'opensent': {}, 'openconfirm': {}, 'established': {}},), is_leaf=True, yang_name="session-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='enumeration', is_config=True)


  def _get_last_established(self):
    """
    Getter method for last_established, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/last_established (uint64)

    YANG Description: This timestamp indicates the time that the BGP session
last transitioned in or out of the Established state.
The value is the timestamp in seconds relative to the
Unix Epoch (Jan 1, 1970 00:00:00 UTC).

The BGP session uptime can be computed by clients as
the difference between this value and the current time
in UTC (assuming the session is in the ESTABLISHED
state, per the session-state leaf).
    """
    return self.__last_established
      
  def _set_last_established(self, v, load=False):
    """
    Setter method for last_established, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/last_established (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_established is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_established() directly.

    YANG Description: This timestamp indicates the time that the BGP session
last transitioned in or out of the Established state.
The value is the timestamp in seconds relative to the
Unix Epoch (Jan 1, 1970 00:00:00 UTC).

The BGP session uptime can be computed by clients as
the difference between this value and the current time
in UTC (assuming the session is in the ESTABLISHED
state, per the session-state leaf).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-established", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_established must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-established", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__last_established = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_established(self):
    self.__last_established = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="last-established", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)


  def _get_supported_capabilities(self):
    """
    Getter method for supported_capabilities, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/supported_capabilities (identityref)

    YANG Description: BGP capabilities negotiated as supported with the peer
    """
    return self.__supported_capabilities
      
  def _set_supported_capabilities(self, v, load=False):
    """
    Setter method for supported_capabilities, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/supported_capabilities (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_capabilities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_capabilities() directly.

    YANG Description: BGP capabilities negotiated as supported with the peer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'mp-bgp': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:mp-bgp': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:mp-bgp': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'route-refresh': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:route-refresh': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:route-refresh': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'asn32': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:asn32': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:asn32': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'graceful-restart': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:graceful-restart': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:graceful-restart': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'add-paths': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:add-paths': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:add-paths': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},)), is_leaf=False, yang_name="supported-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supported_capabilities must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'mp-bgp': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:mp-bgp': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:mp-bgp': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'route-refresh': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:route-refresh': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:route-refresh': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'asn32': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:asn32': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:asn32': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'graceful-restart': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:graceful-restart': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:graceful-restart': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'add-paths': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:add-paths': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:add-paths': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},)), is_leaf=False, yang_name="supported-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)""",
        })

    self.__supported_capabilities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supported_capabilities(self):
    self.__supported_capabilities = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'mp-bgp': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:mp-bgp': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:mp-bgp': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'route-refresh': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:route-refresh': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:route-refresh': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'asn32': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:asn32': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:asn32': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'graceful-restart': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:graceful-restart': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:graceful-restart': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'add-paths': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:add-paths': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:add-paths': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},)), is_leaf=False, yang_name="supported-capabilities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)


  def _get_negotiated_hold_time(self):
    """
    Getter method for negotiated_hold_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/negotiated_hold_time (decimal64)

    YANG Description: The negotiated hold-time for the BGP session
    """
    return self.__negotiated_hold_time
      
  def _set_negotiated_hold_time(self, v, load=False):
    """
    Setter method for negotiated_hold_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/negotiated_hold_time (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_negotiated_hold_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_negotiated_hold_time() directly.

    YANG Description: The negotiated hold-time for the BGP session
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="negotiated-hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """negotiated_hold_time must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="negotiated-hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=False)""",
        })

    self.__negotiated_hold_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_negotiated_hold_time(self):
    self.__negotiated_hold_time = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="negotiated-hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=False)


  def _get_last_error(self):
    """
    Getter method for last_error, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/last_error (binary)

    YANG Description: The last error code and subcode seen by this
peer on this connection.  If no error has
occurred, this field is zero.  Otherwise, the
first byte of this two byte OCTET STRING
contains the error code, and the second byte
contains the subcode.
    """
    return self.__last_error
      
  def _set_last_error(self, v, load=False):
    """
    Setter method for last_error, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/last_error (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_error is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_error() directly.

    YANG Description: The last error code and subcode seen by this
peer on this connection.  If no error has
occurred, this field is zero.  Otherwise, the
first byte of this two byte OCTET STRING
contains the error code, and the second byte
contains the subcode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['2']}), is_leaf=True, yang_name="last-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_error must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['2']}), is_leaf=True, yang_name="last-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=True)""",
        })

    self.__last_error = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_error(self):
    self.__last_error = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['2']}), is_leaf=True, yang_name="last-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=True)


  def _get_fsm_established_time(self):
    """
    Getter method for fsm_established_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/fsm_established_time (yang:gauge32)

    YANG Description: This timer indicates how long (in
seconds) this peer has been in the
established state or how long
since this peer was last in the
established state.  It is set to zero when
a new peer is configured or when the router is
booted.
    """
    return self.__fsm_established_time
      
  def _set_fsm_established_time(self, v, load=False):
    """
    Setter method for fsm_established_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/fsm_established_time (yang:gauge32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fsm_established_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fsm_established_time() directly.

    YANG Description: This timer indicates how long (in
seconds) this peer has been in the
established state or how long
since this peer was last in the
established state.  It is set to zero when
a new peer is configured or when the router is
booted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="fsm-established-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fsm_established_time must be of a type compatible with yang:gauge32""",
          'defined-type': "yang:gauge32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="fsm-established-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=False)""",
        })

    self.__fsm_established_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fsm_established_time(self):
    self.__fsm_established_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="fsm-established-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=False)


  def _get_timers(self):
    """
    Getter method for timers, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/timers (container)

    YANG Description: Timers related to a BGP neighbor
    """
    return self.__timers
      
  def _set_timers(self, v, load=False):
    """
    Setter method for timers, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timers() directly.

    YANG Description: Timers related to a BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_timers_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_timers_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timers(self):
    self.__timers = YANGDynClass(base=yc_timers_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/transport (container)

    YANG Description: Transport session parameters for the BGP neighbor
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Transport session parameters for the BGP neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_transport_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_transport_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=yc_transport_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_treat_as_withdraw(self):
    """
    Getter method for treat_as_withdraw, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/treat_as_withdraw (boolean)

    YANG Description: Specify whether erroneous UPDATE messages for which
the NLRI can be extracted are treated as though the
NLRI is withdrawn - avoiding session reset
    """
    return self.__treat_as_withdraw
      
  def _set_treat_as_withdraw(self, v, load=False):
    """
    Setter method for treat_as_withdraw, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/treat_as_withdraw (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_treat_as_withdraw is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_treat_as_withdraw() directly.

    YANG Description: Specify whether erroneous UPDATE messages for which
the NLRI can be extracted are treated as though the
NLRI is withdrawn - avoiding session reset
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="treat-as-withdraw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """treat_as_withdraw must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="treat-as-withdraw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__treat_as_withdraw = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_treat_as_withdraw(self):
    self.__treat_as_withdraw = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="treat-as-withdraw", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_erroneous_update_messages(self):
    """
    Getter method for erroneous_update_messages, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/erroneous_update_messages (uint32)

    YANG Description: The number of BGP UPDATE messages for which the
treat-as-withdraw mechanism has been applied based on
erroneous message contents
    """
    return self.__erroneous_update_messages
      
  def _set_erroneous_update_messages(self, v, load=False):
    """
    Setter method for erroneous_update_messages, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/erroneous_update_messages (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_erroneous_update_messages is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_erroneous_update_messages() directly.

    YANG Description: The number of BGP UPDATE messages for which the
treat-as-withdraw mechanism has been applied based on
erroneous message contents
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="erroneous-update-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """erroneous_update_messages must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="erroneous-update-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__erroneous_update_messages = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_erroneous_update_messages(self):
    self.__erroneous_update_messages = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="erroneous-update-messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart (container)

    YANG Description: Parameters relating the graceful restart mechanism for
BGP
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: Parameters relating the graceful restart mechanism for
BGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_logging_options(self):
    """
    Getter method for logging_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/logging_options (container)

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    return self.__logging_options
      
  def _set_logging_options(self, v, load=False):
    """
    Setter method for logging_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/logging_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging_options() directly.

    YANG Description: Logging options for events related to the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_logging_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_logging_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__logging_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging_options(self):
    self.__logging_options = YANGDynClass(base=yc_logging_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_logging_options, is_container='container', yang_name="logging-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ebgp_multihop(self):
    """
    Getter method for ebgp_multihop, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/ebgp_multihop (container)

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    return self.__ebgp_multihop
      
  def _set_ebgp_multihop(self, v, load=False):
    """
    Setter method for ebgp_multihop, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/ebgp_multihop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp_multihop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp_multihop() directly.

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ebgp_multihop_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp_multihop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ebgp_multihop_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp_multihop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp_multihop(self):
    self.__ebgp_multihop = YANGDynClass(base=yc_ebgp_multihop_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_route_reflector(self):
    """
    Getter method for route_reflector, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_reflector (container)

    YANG Description: Route reflector parameters for the BGPgroup
    """
    return self.__route_reflector
      
  def _set_route_reflector(self, v, load=False):
    """
    Setter method for route_reflector, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/route_reflector (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector() directly.

    YANG Description: Route reflector parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_route_reflector_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_route_reflector_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_reflector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector(self):
    self.__route_reflector = YANGDynClass(base=yc_route_reflector_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_as_path_options(self):
    """
    Getter method for as_path_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/as_path_options (container)

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    return self.__as_path_options
      
  def _set_as_path_options(self, v, load=False):
    """
    Setter method for as_path_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/as_path_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_path_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_path_options() directly.

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_as_path_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_path_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_as_path_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__as_path_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_path_options(self):
    self.__as_path_options = YANGDynClass(base=yc_as_path_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_add_paths(self):
    """
    Getter method for add_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/add_paths (container)

    YANG Description: Parameters relating to the advertisement and receipt of
multiple paths for a single NLRI (add-paths)
    """
    return self.__add_paths
      
  def _set_add_paths(self, v, load=False):
    """
    Setter method for add_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/add_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_add_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_add_paths() directly.

    YANG Description: Parameters relating to the advertisement and receipt of
multiple paths for a single NLRI (add-paths)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_add_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_add_paths, is_container='container', yang_name="add-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """add_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_add_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_add_paths, is_container='container', yang_name="add-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__add_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_add_paths(self):
    self.__add_paths = YANGDynClass(base=yc_add_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_add_paths, is_container='container', yang_name="add-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_use_multiple_paths(self):
    """
    Getter method for use_multiple_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/use_multiple_paths (container)

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    return self.__use_multiple_paths
      
  def _set_use_multiple_paths(self, v, load=False):
    """
    Setter method for use_multiple_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/use_multiple_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_multiple_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_multiple_paths() directly.

    YANG Description: Parameters related to the use of multiple-paths for the same
NLRI when they are received only from this neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_multiple_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__use_multiple_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_multiple_paths(self):
    self.__use_multiple_paths = YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_apply_policy(self):
    """
    Getter method for apply_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/apply_policy (container)

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    return self.__apply_policy
      
  def _set_apply_policy(self, v, load=False):
    """
    Setter method for apply_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/apply_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_policy() directly.

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__apply_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_policy(self):
    self.__apply_policy = YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_afi_safis(self):
    """
    Getter method for afi_safis, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis (container)

    YANG Description: Per-address-family configuration parameters associated
with the neighbor
    """
    return self.__afi_safis
      
  def _set_afi_safis(self, v, load=False):
    """
    Setter method for afi_safis, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/afi_safis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safis() directly.

    YANG Description: Per-address-family configuration parameters associated
with the neighbor
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__afi_safis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safis(self):
    self.__afi_safis = YANGDynClass(base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_statistics(self):
    """
    Getter method for statistics, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics (container)

    YANG Description: Statistics per neighbor.
    """
    return self.__statistics
      
  def _set_statistics(self, v, load=False):
    """
    Setter method for statistics, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor/statistics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistics() directly.

    YANG Description: Statistics per neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_statistics_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_statistics_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistics(self):
    self.__statistics = YANGDynClass(base=yc_statistics_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics, is_container='container', yang_name="statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  local_address = __builtin__.property(_get_local_address)
  local_port = __builtin__.property(_get_local_port)
  peer_type = __builtin__.property(_get_peer_type)
  peer_group = __builtin__.property(_get_peer_group, _set_peer_group)
  identifier = __builtin__.property(_get_identifier)
  remote_address = __builtin__.property(_get_remote_address, _set_remote_address)
  remote_port = __builtin__.property(_get_remote_port)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  secure_session_enable = __builtin__.property(_get_secure_session_enable, _set_secure_session_enable)
  secure_session = __builtin__.property(_get_secure_session, _set_secure_session) # type: yc_secure_session_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_secure_session
  ttl_security = __builtin__.property(_get_ttl_security, _set_ttl_security)
  remote_as = __builtin__.property(_get_remote_as, _set_remote_as)
  peer_as = __builtin__.property(_get_peer_as, _set_peer_as)
  local_as = __builtin__.property(_get_local_as, _set_local_as)
  remove_private_as = __builtin__.property(_get_remove_private_as, _set_remove_private_as)
  route_flap_damping = __builtin__.property(_get_route_flap_damping, _set_route_flap_damping) # type: yc_route_flap_damping_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_flap_damping
  send_community = __builtin__.property(_get_send_community, _set_send_community)
  description = __builtin__.property(_get_description, _set_description)
  route_selection_options = __builtin__.property(_get_route_selection_options, _set_route_selection_options) # type: yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_selection_options
  session_state = __builtin__.property(_get_session_state, _set_session_state)
  last_established = __builtin__.property(_get_last_established)
  supported_capabilities = __builtin__.property(_get_supported_capabilities)
  negotiated_hold_time = __builtin__.property(_get_negotiated_hold_time)
  last_error = __builtin__.property(_get_last_error, _set_last_error)
  fsm_established_time = __builtin__.property(_get_fsm_established_time)
  timers = __builtin__.property(_get_timers, _set_timers) # type: yc_timers_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_timers
  transport = __builtin__.property(_get_transport, _set_transport) # type: yc_transport_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_transport
  treat_as_withdraw = __builtin__.property(_get_treat_as_withdraw, _set_treat_as_withdraw)
  erroneous_update_messages = __builtin__.property(_get_erroneous_update_messages)
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart) # type: yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_graceful_restart
  logging_options = __builtin__.property(_get_logging_options, _set_logging_options) # type: yc_logging_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_logging_options
  ebgp_multihop = __builtin__.property(_get_ebgp_multihop, _set_ebgp_multihop) # type: yc_ebgp_multihop_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_ebgp_multihop
  route_reflector = __builtin__.property(_get_route_reflector, _set_route_reflector) # type: yc_route_reflector_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_route_reflector
  as_path_options = __builtin__.property(_get_as_path_options, _set_as_path_options) # type: yc_as_path_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_as_path_options
  add_paths = __builtin__.property(_get_add_paths, _set_add_paths) # type: yc_add_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_add_paths
  use_multiple_paths = __builtin__.property(_get_use_multiple_paths, _set_use_multiple_paths) # type: yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_use_multiple_paths
  apply_policy = __builtin__.property(_get_apply_policy, _set_apply_policy) # type: yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_apply_policy
  afi_safis = __builtin__.property(_get_afi_safis, _set_afi_safis) # type: yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_afi_safis
  statistics = __builtin__.property(_get_statistics, _set_statistics) # type: yc_statistics_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor_statistics


  _pyangbind_elements = OrderedDict([('local_address', local_address), ('local_port', local_port), ('peer_type', peer_type), ('peer_group', peer_group), ('identifier', identifier), ('remote_address', remote_address), ('remote_port', remote_port), ('enabled', enabled), ('secure_session_enable', secure_session_enable), ('secure_session', secure_session), ('ttl_security', ttl_security), ('remote_as', remote_as), ('peer_as', peer_as), ('local_as', local_as), ('remove_private_as', remove_private_as), ('route_flap_damping', route_flap_damping), ('send_community', send_community), ('description', description), ('route_selection_options', route_selection_options), ('session_state', session_state), ('last_established', last_established), ('supported_capabilities', supported_capabilities), ('negotiated_hold_time', negotiated_hold_time), ('last_error', last_error), ('fsm_established_time', fsm_established_time), ('timers', timers), ('transport', transport), ('treat_as_withdraw', treat_as_withdraw), ('erroneous_update_messages', erroneous_update_messages), ('graceful_restart', graceful_restart), ('logging_options', logging_options), ('ebgp_multihop', ebgp_multihop), ('route_reflector', route_reflector), ('as_path_options', as_path_options), ('add_paths', add_paths), ('use_multiple_paths', use_multiple_paths), ('apply_policy', apply_policy), ('afi_safis', afi_safis), ('statistics', statistics), ])


class yc_established_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_established(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/established. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The established event is generated
when the BGP FSM enters the established state.
  """
  __slots__ = ('_path_helper', '_extmethods', '__remote_address','__last_error','__session_state',)

  _yang_name = 'established'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__remote_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__last_error = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="last-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__session_state = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="session-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'established']

  def _get_remote_address(self):
    """
    Getter method for remote_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/established/remote_address (leafref)

    YANG Description: IP address of the neighbor that went into established
state.
    """
    return self.__remote_address
      
  def _set_remote_address(self, v, load=False):
    """
    Setter method for remote_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/established/remote_address (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_address() directly.

    YANG Description: IP address of the neighbor that went into established
state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_address must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__remote_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_address(self):
    self.__remote_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_last_error(self):
    """
    Getter method for last_error, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/established/last_error (leafref)

    YANG Description: The last error code and subcode seen by this
peer on this connection.  If no error has
occurred, this field is zero.  Otherwise, the
first byte of this two byte OCTET STRING
contains the error code, and the second byte
contains the subcode.
    """
    return self.__last_error
      
  def _set_last_error(self, v, load=False):
    """
    Setter method for last_error, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/established/last_error (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_error is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_error() directly.

    YANG Description: The last error code and subcode seen by this
peer on this connection.  If no error has
occurred, this field is zero.  Otherwise, the
first byte of this two byte OCTET STRING
contains the error code, and the second byte
contains the subcode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="last-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_error must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="last-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__last_error = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_error(self):
    self.__last_error = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="last-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_session_state(self):
    """
    Getter method for session_state, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/established/session_state (leafref)

    YANG Description: The BGP peer connection state.
    """
    return self.__session_state
      
  def _set_session_state(self, v, load=False):
    """
    Setter method for session_state, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/established/session_state (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_session_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_session_state() directly.

    YANG Description: The BGP peer connection state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="session-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """session_state must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="session-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__session_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_session_state(self):
    self.__session_state = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="session-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)

  remote_address = __builtin__.property(_get_remote_address, _set_remote_address)
  last_error = __builtin__.property(_get_last_error, _set_last_error)
  session_state = __builtin__.property(_get_session_state, _set_session_state)


  _pyangbind_elements = OrderedDict([('remote_address', remote_address), ('last_error', last_error), ('session_state', session_state), ])


class yc_backward_transition_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_backward_transition(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/backward-transition. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The backward-transition event is
generated when the BGP FSM moves from a higher
numbered state to a lower numbered state.
  """
  __slots__ = ('_path_helper', '_extmethods', '__remote_addr','__last_error','__session_state',)

  _yang_name = 'backward-transition'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__remote_addr = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__last_error = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="last-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__session_state = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="session-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'backward-transition']

  def _get_remote_addr(self):
    """
    Getter method for remote_addr, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/backward_transition/remote_addr (leafref)

    YANG Description: IP address of the neighbor that went away from
established state.
    """
    return self.__remote_addr
      
  def _set_remote_addr(self, v, load=False):
    """
    Setter method for remote_addr, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/backward_transition/remote_addr (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_addr() directly.

    YANG Description: IP address of the neighbor that went away from
established state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="remote-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_addr must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__remote_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_addr(self):
    self.__remote_addr = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="remote-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_last_error(self):
    """
    Getter method for last_error, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/backward_transition/last_error (leafref)

    YANG Description: The last error code and subcode seen by this
peer on this connection.  If no error has
occurred, this field is zero.  Otherwise, the
first byte of this two byte OCTET STRING
contains the error code, and the second byte
contains the subcode.
    """
    return self.__last_error
      
  def _set_last_error(self, v, load=False):
    """
    Setter method for last_error, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/backward_transition/last_error (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_error is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_error() directly.

    YANG Description: The last error code and subcode seen by this
peer on this connection.  If no error has
occurred, this field is zero.  Otherwise, the
first byte of this two byte OCTET STRING
contains the error code, and the second byte
contains the subcode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="last-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_error must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="last-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__last_error = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_error(self):
    self.__last_error = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="last-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_session_state(self):
    """
    Getter method for session_state, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/backward_transition/session_state (leafref)

    YANG Description: The BGP peer connection state.
    """
    return self.__session_state
      
  def _set_session_state(self, v, load=False):
    """
    Setter method for session_state, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/backward_transition/session_state (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_session_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_session_state() directly.

    YANG Description: The BGP peer connection state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="session-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """session_state must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="session-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__session_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_session_state(self):
    self.__session_state = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="session-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)

  remote_addr = __builtin__.property(_get_remote_addr, _set_remote_addr)
  last_error = __builtin__.property(_get_last_error, _set_last_error)
  session_state = __builtin__.property(_get_session_state, _set_session_state)


  _pyangbind_elements = OrderedDict([('remote_addr', remote_addr), ('last_error', last_error), ('session_state', session_state), ])


class yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/clear/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_at',)

  _yang_name = 'input'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'clear', 'input']

  def _get_clear_at(self):
    """
    Getter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/clear/input/clear_at (yang:date-and-time)

    YANG Description: Time when the clear action command needs to be
executed.
    """
    return self.__clear_at
      
  def _set_clear_at(self, v, load=False):
    """
    Setter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/clear/input/clear_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_at() directly.

    YANG Description: Time when the clear action command needs to be
executed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__clear_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_at(self):
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)

  clear_at = __builtin__.property(_get_clear_at, _set_clear_at)


  _pyangbind_elements = OrderedDict([('clear_at', clear_at), ])


class yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/clear/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_finished_at',)

  _yang_name = 'output'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'clear', 'output']

  def _get_clear_finished_at(self):
    """
    Getter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/clear/output/clear_finished_at (yang:date-and-time)

    YANG Description: Time when the clear action command completed.
    """
    return self.__clear_finished_at
      
  def _set_clear_finished_at(self, v, load=False):
    """
    Setter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/clear/output/clear_finished_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_finished_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_finished_at() directly.

    YANG Description: Time when the clear action command completed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_finished_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__clear_finished_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_finished_at(self):
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=True)

  clear_finished_at = __builtin__.property(_get_clear_finished_at, _set_clear_finished_at)


  _pyangbind_elements = OrderedDict([('clear_finished_at', clear_finished_at), ])


class yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors/clear. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Clear neighbors action.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__output',)

  _yang_name = 'clear'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=True)
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors', 'clear']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/clear/input (input)
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/clear/input (input)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with input""",
          'defined-type': "ietf-bgp:input",
          'generated-type': """YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=True)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=True)


  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/clear/output (output)
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/clear/output (output)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with output""",
          'defined-type': "ietf-bgp:output",
          'generated-type': """YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=True)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=True)

  input = __builtin__.property(_get_input, _set_input)
  output = __builtin__.property(_get_output, _set_output)


  _pyangbind_elements = OrderedDict([('input', input), ('output', output), ])


class yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for BGP neighbors
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor','__established','__backward_transition','__clear',)

  _yang_name = 'neighbors'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor = YANGDynClass(base=YANGListType("remote_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='remote-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)
    self.__established = YANGDynClass(base=yc_established_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_established, is_leaf=True, yang_name="established", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='notification', is_config=True)
    self.__backward_transition = YANGDynClass(base=yc_backward_transition_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_backward_transition, is_leaf=True, yang_name="backward-transition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='notification', is_config=True)
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'neighbors']

  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor (list)

    YANG Description: List of BGP neighbors configured on the local system,
uniquely identified by remote IPv[46] address
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: List of BGP neighbors configured on the local system,
uniquely identified by remote IPv[46] address
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("remote_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='remote-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("remote_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='remote-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("remote_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='remote-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)


  def _get_established(self):
    """
    Getter method for established, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/established (notification)

    YANG Description: The established event is generated
when the BGP FSM enters the established state.
    """
    return self.__established
      
  def _set_established(self, v, load=False):
    """
    Setter method for established, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/established (notification)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_established is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_established() directly.

    YANG Description: The established event is generated
when the BGP FSM enters the established state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_established_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_established, is_leaf=True, yang_name="established", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='notification', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """established must be of a type compatible with notification""",
          'defined-type': "notification",
          'generated-type': """YANGDynClass(base=yc_established_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_established, is_leaf=True, yang_name="established", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='notification', is_config=True)""",
        })

    self.__established = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_established(self):
    self.__established = YANGDynClass(base=yc_established_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_established, is_leaf=True, yang_name="established", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='notification', is_config=True)


  def _get_backward_transition(self):
    """
    Getter method for backward_transition, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/backward_transition (notification)

    YANG Description: The backward-transition event is
generated when the BGP FSM moves from a higher
numbered state to a lower numbered state.
    """
    return self.__backward_transition
      
  def _set_backward_transition(self, v, load=False):
    """
    Setter method for backward_transition, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/backward_transition (notification)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_backward_transition is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_backward_transition() directly.

    YANG Description: The backward-transition event is
generated when the BGP FSM moves from a higher
numbered state to a lower numbered state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_backward_transition_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_backward_transition, is_leaf=True, yang_name="backward-transition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='notification', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """backward_transition must be of a type compatible with notification""",
          'defined-type': "notification",
          'generated-type': """YANGDynClass(base=yc_backward_transition_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_backward_transition, is_leaf=True, yang_name="backward-transition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='notification', is_config=True)""",
        })

    self.__backward_transition = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_backward_transition(self):
    self.__backward_transition = YANGDynClass(base=yc_backward_transition_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_backward_transition, is_leaf=True, yang_name="backward-transition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='notification', is_config=True)


  def _get_clear(self):
    """
    Getter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/clear (action)

    YANG Description: Clear neighbors action.
    """
    return self.__clear
      
  def _set_clear(self, v, load=False):
    """
    Setter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors/clear (action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear() directly.

    YANG Description: Clear neighbors action.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear must be of a type compatible with action""",
          'defined-type': "ietf-bgp:action",
          'generated-type': """YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=True)""",
        })

    self.__clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear(self):
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=True)

  neighbor = __builtin__.property(_get_neighbor, _set_neighbor) # type: yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors_neighbor
  established = __builtin__.property(_get_established, _set_established)
  backward_transition = __builtin__.property(_get_backward_transition, _set_backward_transition)
  clear = __builtin__.property(_get_clear, _set_clear)


  _pyangbind_elements = OrderedDict([('neighbor', neighbor), ('established', established), ('backward_transition', backward_transition), ('clear', clear), ])


class yc_route_flap_damping_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_route_flap_damping(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/route-flap-damping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Routes learned via BGP are subject to weighted route
dampening.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__suppress_above','__reuse_above','__max_flap','__reach_decay','__unreach_decay','__keep_history',)

  _yang_name = 'route-flap-damping'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__suppress_above = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(3.0), is_leaf=True, yang_name="suppress-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)
    self.__reuse_above = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(2.0), is_leaf=True, yang_name="reuse-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)
    self.__max_flap = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(16.0), is_leaf=True, yang_name="max-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)
    self.__reach_decay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="reach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)
    self.__unreach_decay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(900), is_leaf=True, yang_name="unreach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)
    self.__keep_history = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1800), is_leaf=True, yang_name="keep-history", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'route-flap-damping']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping/enable (boolean)

    YANG Description: Enable route flap damping.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Enable route flap damping.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_suppress_above(self):
    """
    Getter method for suppress_above, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping/suppress_above (decimal64)

    YANG Description: This is the value of the instability metric at which
route suppression takes place. A route is not installed
in the forwarding information base (FIB), or announced
even if it is reachable during the period that it is
suppressed.
    """
    return self.__suppress_above
      
  def _set_suppress_above(self, v, load=False):
    """
    Setter method for suppress_above, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping/suppress_above (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_above is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_above() directly.

    YANG Description: This is the value of the instability metric at which
route suppression takes place. A route is not installed
in the forwarding information base (FIB), or announced
even if it is reachable during the period that it is
suppressed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(3.0), is_leaf=True, yang_name="suppress-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_above must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(3.0), is_leaf=True, yang_name="suppress-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)""",
        })

    self.__suppress_above = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_above(self):
    self.__suppress_above = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(3.0), is_leaf=True, yang_name="suppress-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)


  def _get_reuse_above(self):
    """
    Getter method for reuse_above, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping/reuse_above (decimal64)

    YANG Description: This is the value of the instability metric at which a
suppressed route becomes unsuppressed if it is reachable
but currently suppressed. The value assigned to
reuse-below must be less than suppress-above.
    """
    return self.__reuse_above
      
  def _set_reuse_above(self, v, load=False):
    """
    Setter method for reuse_above, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping/reuse_above (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse_above is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse_above() directly.

    YANG Description: This is the value of the instability metric at which a
suppressed route becomes unsuppressed if it is reachable
but currently suppressed. The value assigned to
reuse-below must be less than suppress-above.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(2.0), is_leaf=True, yang_name="reuse-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse_above must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(2.0), is_leaf=True, yang_name="reuse-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)""",
        })

    self.__reuse_above = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse_above(self):
    self.__reuse_above = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(2.0), is_leaf=True, yang_name="reuse-above", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)


  def _get_max_flap(self):
    """
    Getter method for max_flap, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping/max_flap (decimal64)

    YANG Description: This is the upper limit of the instability metric. This
       value must be greater than the larger of 1 and
       suppress-above.
    """
    return self.__max_flap
      
  def _set_max_flap(self, v, load=False):
    """
    Setter method for max_flap, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping/max_flap (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_flap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_flap() directly.

    YANG Description: This is the upper limit of the instability metric. This
       value must be greater than the larger of 1 and
       suppress-above.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(16.0), is_leaf=True, yang_name="max-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_flap must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(16.0), is_leaf=True, yang_name="max-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)""",
        })

    self.__max_flap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_flap(self):
    self.__max_flap = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), default=Decimal(16.0), is_leaf=True, yang_name="max-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='decimal64', is_config=True)


  def _get_reach_decay(self):
    """
    Getter method for reach_decay, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping/reach_decay (yang:gauge32)

    YANG Description: This value specifies the time desired for the instability
metric value to reach one-half of its current value when
the route is reachable. This half-life value determines
the rate at which the metric value is decayed. A smaller
half-life value makes a suppressed route reusable sooner
than a larger value.
    """
    return self.__reach_decay
      
  def _set_reach_decay(self, v, load=False):
    """
    Setter method for reach_decay, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping/reach_decay (yang:gauge32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reach_decay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reach_decay() directly.

    YANG Description: This value specifies the time desired for the instability
metric value to reach one-half of its current value when
the route is reachable. This half-life value determines
the rate at which the metric value is decayed. A smaller
half-life value makes a suppressed route reusable sooner
than a larger value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="reach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reach_decay must be of a type compatible with yang:gauge32""",
          'defined-type': "yang:gauge32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="reach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)""",
        })

    self.__reach_decay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reach_decay(self):
    self.__reach_decay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="reach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)


  def _get_unreach_decay(self):
    """
    Getter method for unreach_decay, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping/unreach_decay (yang:gauge32)

    YANG Description: This value acts the same as reach-decay except that it
specifies the rate at which the instability metric is
decayed when a route is unreachable. It should have a
value greater than or equal to reach-decay.
    """
    return self.__unreach_decay
      
  def _set_unreach_decay(self, v, load=False):
    """
    Setter method for unreach_decay, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping/unreach_decay (yang:gauge32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unreach_decay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unreach_decay() directly.

    YANG Description: This value acts the same as reach-decay except that it
specifies the rate at which the instability metric is
decayed when a route is unreachable. It should have a
value greater than or equal to reach-decay.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(900), is_leaf=True, yang_name="unreach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unreach_decay must be of a type compatible with yang:gauge32""",
          'defined-type': "yang:gauge32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(900), is_leaf=True, yang_name="unreach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)""",
        })

    self.__unreach_decay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unreach_decay(self):
    self.__unreach_decay = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(900), is_leaf=True, yang_name="unreach-decay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)


  def _get_keep_history(self):
    """
    Getter method for keep_history, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping/keep_history (yang:gauge32)

    YANG Description: This value specifies the period over which the route
flapping history is to be maintained for a given route.
The size of the configuration arrays described below is
directly affected by this value.
    """
    return self.__keep_history
      
  def _set_keep_history(self, v, load=False):
    """
    Setter method for keep_history, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping/keep_history (yang:gauge32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keep_history is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keep_history() directly.

    YANG Description: This value specifies the period over which the route
flapping history is to be maintained for a given route.
The size of the configuration arrays described below is
directly affected by this value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1800), is_leaf=True, yang_name="keep-history", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keep_history must be of a type compatible with yang:gauge32""",
          'defined-type': "yang:gauge32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1800), is_leaf=True, yang_name="keep-history", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)""",
        })

    self.__keep_history = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keep_history(self):
    self.__keep_history = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1800), is_leaf=True, yang_name="keep-history", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:gauge32', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  suppress_above = __builtin__.property(_get_suppress_above, _set_suppress_above)
  reuse_above = __builtin__.property(_get_reuse_above, _set_reuse_above)
  max_flap = __builtin__.property(_get_max_flap, _set_max_flap)
  reach_decay = __builtin__.property(_get_reach_decay, _set_reach_decay)
  unreach_decay = __builtin__.property(_get_unreach_decay, _set_unreach_decay)
  keep_history = __builtin__.property(_get_keep_history, _set_keep_history)


  _pyangbind_elements = OrderedDict([('enable', enable), ('suppress_above', suppress_above), ('reuse_above', reuse_above), ('max_flap', max_flap), ('reach_decay', reach_decay), ('unreach_decay', unreach_decay), ('keep_history', keep_history), ])


class yc_timers_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_timers(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/timers. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Timers related to a BGP peer-group.
  """
  __slots__ = ('_path_helper', '_extmethods', '__connect_retry_interval','__hold_time','__keepalive','__min_as_origination_interval','__min_route_advertisement_interval',)

  _yang_name = 'timers'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__connect_retry_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(120), is_leaf=True, yang_name="connect-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    self.__hold_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0', '3..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(90), is_leaf=True, yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    self.__keepalive = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(30), is_leaf=True, yang_name="keepalive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    self.__min_as_origination_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(15), is_leaf=True, yang_name="min-as-origination-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    self.__min_route_advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="min-route-advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'timers']

  def _get_connect_retry_interval(self):
    """
    Getter method for connect_retry_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/timers/connect_retry_interval (uint16)

    YANG Description: Time interval (in seconds) for the ConnectRetryTimer. The
suggested value for this timer is 120 seconds.
    """
    return self.__connect_retry_interval
      
  def _set_connect_retry_interval(self, v, load=False):
    """
    Setter method for connect_retry_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/timers/connect_retry_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connect_retry_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connect_retry_interval() directly.

    YANG Description: Time interval (in seconds) for the ConnectRetryTimer. The
suggested value for this timer is 120 seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(120), is_leaf=True, yang_name="connect-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connect_retry_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(120), is_leaf=True, yang_name="connect-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__connect_retry_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connect_retry_interval(self):
    self.__connect_retry_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(120), is_leaf=True, yang_name="connect-retry-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)


  def _get_hold_time(self):
    """
    Getter method for hold_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/timers/hold_time (uint16)

    YANG Description: Time interval (in seconds) for the HoldTimer established
with the peer.  When read as operational data (ro), the
value of this object is calculated by this BGP speaker,
using the smaller of the values in hold-time that was
configured (rw) in the running datastore and the Hold Time
received in the OPEN message.

This value must be at least three seconds
if it is not zero (0).

If the Hold Timer has not been established
with the peer this object MUST have a value
of zero (0).

If the configured value of hold-time object was
a value of (0), then when read this object MUST have a
value of (0) also.
    """
    return self.__hold_time
      
  def _set_hold_time(self, v, load=False):
    """
    Setter method for hold_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/timers/hold_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_time() directly.

    YANG Description: Time interval (in seconds) for the HoldTimer established
with the peer.  When read as operational data (ro), the
value of this object is calculated by this BGP speaker,
using the smaller of the values in hold-time that was
configured (rw) in the running datastore and the Hold Time
received in the OPEN message.

This value must be at least three seconds
if it is not zero (0).

If the Hold Timer has not been established
with the peer this object MUST have a value
of zero (0).

If the configured value of hold-time object was
a value of (0), then when read this object MUST have a
value of (0) also.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0', '3..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(90), is_leaf=True, yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0', '3..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(90), is_leaf=True, yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__hold_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_time(self):
    self.__hold_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0', '3..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(90), is_leaf=True, yang_name="hold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)


  def _get_keepalive(self):
    """
    Getter method for keepalive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/timers/keepalive (uint16)

    YANG Description: When used as a configuration (rw) value, this Time interval
(in seconds) for the KeepAlive timer configured for this BGP
speaker with this peer. The value of this object will only
determine the KEEPALIVE messages' frequency relative to
the value specified in configured value for hold-time.

If the value of this object is zero (0), no periodical
KEEPALIVE messages are sent to the peer after the BGP
connection has been established.  The suggested value for
this timer is 30 seconds.;

The actual time interval for the KEEPALIVE messages is
indicated by operational value of keepalive. That value
of this object is calculated by this BGP speaker such that,
when compared with hold-time, it has the same proportion
that keepalive has, compared with hold-time. A
reasonable maximum value for this timer would be one third
of that of hold-time.
    """
    return self.__keepalive
      
  def _set_keepalive(self, v, load=False):
    """
    Setter method for keepalive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/timers/keepalive (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keepalive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keepalive() directly.

    YANG Description: When used as a configuration (rw) value, this Time interval
(in seconds) for the KeepAlive timer configured for this BGP
speaker with this peer. The value of this object will only
determine the KEEPALIVE messages' frequency relative to
the value specified in configured value for hold-time.

If the value of this object is zero (0), no periodical
KEEPALIVE messages are sent to the peer after the BGP
connection has been established.  The suggested value for
this timer is 30 seconds.;

The actual time interval for the KEEPALIVE messages is
indicated by operational value of keepalive. That value
of this object is calculated by this BGP speaker such that,
when compared with hold-time, it has the same proportion
that keepalive has, compared with hold-time. A
reasonable maximum value for this timer would be one third
of that of hold-time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(30), is_leaf=True, yang_name="keepalive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keepalive must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(30), is_leaf=True, yang_name="keepalive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__keepalive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keepalive(self):
    self.__keepalive = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..21845']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(30), is_leaf=True, yang_name="keepalive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)


  def _get_min_as_origination_interval(self):
    """
    Getter method for min_as_origination_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/timers/min_as_origination_interval (uint16)

    YANG Description: Time interval (in seconds) for the MinASOriginationInterval
timer. The suggested value for this timer is 15 seconds.
    """
    return self.__min_as_origination_interval
      
  def _set_min_as_origination_interval(self, v, load=False):
    """
    Setter method for min_as_origination_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/timers/min_as_origination_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_as_origination_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_as_origination_interval() directly.

    YANG Description: Time interval (in seconds) for the MinASOriginationInterval
timer. The suggested value for this timer is 15 seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(15), is_leaf=True, yang_name="min-as-origination-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_as_origination_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(15), is_leaf=True, yang_name="min-as-origination-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__min_as_origination_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_as_origination_interval(self):
    self.__min_as_origination_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(15), is_leaf=True, yang_name="min-as-origination-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)


  def _get_min_route_advertisement_interval(self):
    """
    Getter method for min_route_advertisement_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/timers/min_route_advertisement_interval (uint16)

    YANG Description: Time interval (in seconds) for the
MinRouteAdvertisementInterval timer.
The suggested value for this timer is 30
seconds for EBGP connections and 5
seconds for IBGP connections.
    """
    return self.__min_route_advertisement_interval
      
  def _set_min_route_advertisement_interval(self, v, load=False):
    """
    Setter method for min_route_advertisement_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/timers/min_route_advertisement_interval (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_route_advertisement_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_route_advertisement_interval() directly.

    YANG Description: Time interval (in seconds) for the
MinRouteAdvertisementInterval timer.
The suggested value for this timer is 30
seconds for EBGP connections and 5
seconds for IBGP connections.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="min-route-advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_route_advertisement_interval must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="min-route-advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__min_route_advertisement_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_route_advertisement_interval(self):
    self.__min_route_advertisement_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="min-route-advertisement-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)

  connect_retry_interval = __builtin__.property(_get_connect_retry_interval, _set_connect_retry_interval)
  hold_time = __builtin__.property(_get_hold_time, _set_hold_time)
  keepalive = __builtin__.property(_get_keepalive, _set_keepalive)
  min_as_origination_interval = __builtin__.property(_get_min_as_origination_interval, _set_min_as_origination_interval)
  min_route_advertisement_interval = __builtin__.property(_get_min_route_advertisement_interval, _set_min_route_advertisement_interval)


  _pyangbind_elements = OrderedDict([('connect_retry_interval', connect_retry_interval), ('hold_time', hold_time), ('keepalive', keepalive), ('min_as_origination_interval', min_as_origination_interval), ('min_route_advertisement_interval', min_route_advertisement_interval), ])


class yc_transport_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_transport(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/transport. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Transport session parameters for the BGP peer-group.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tcp_mss','__mtu_discovery','__passive_mode','__local_address','__auth_password',)

  _yang_name = 'transport'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tcp_mss = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tcp-mss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    self.__mtu_discovery = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__passive_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="passive-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__local_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),six.text_type,], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=True)
    self.__auth_password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="auth-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'transport']

  def _get_tcp_mss(self):
    """
    Getter method for tcp_mss, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/transport/tcp_mss (uint16)

    YANG Description: Sets the max segment size for BGP TCP sessions.
    """
    return self.__tcp_mss
      
  def _set_tcp_mss(self, v, load=False):
    """
    Setter method for tcp_mss, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/transport/tcp_mss (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tcp_mss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tcp_mss() directly.

    YANG Description: Sets the max segment size for BGP TCP sessions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tcp-mss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tcp_mss must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tcp-mss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__tcp_mss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tcp_mss(self):
    self.__tcp_mss = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="tcp-mss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)


  def _get_mtu_discovery(self):
    """
    Getter method for mtu_discovery, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/transport/mtu_discovery (boolean)

    YANG Description: Turns path mtu discovery for BGP TCP sessions on (true) or
off (false)
    """
    return self.__mtu_discovery
      
  def _set_mtu_discovery(self, v, load=False):
    """
    Setter method for mtu_discovery, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/transport/mtu_discovery (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu_discovery is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu_discovery() directly.

    YANG Description: Turns path mtu discovery for BGP TCP sessions on (true) or
off (false)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu_discovery must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__mtu_discovery = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu_discovery(self):
    self.__mtu_discovery = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mtu-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_passive_mode(self):
    """
    Getter method for passive_mode, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/transport/passive_mode (boolean)

    YANG Description: Wait for peers to issue requests to open a BGP session,
rather than initiating sessions from the local router.
    """
    return self.__passive_mode
      
  def _set_passive_mode(self, v, load=False):
    """
    Setter method for passive_mode, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/transport/passive_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_passive_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_passive_mode() directly.

    YANG Description: Wait for peers to issue requests to open a BGP session,
rather than initiating sessions from the local router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="passive-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """passive_mode must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="passive-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__passive_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_passive_mode(self):
    self.__passive_mode = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="passive-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_local_address(self):
    """
    Getter method for local_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/transport/local_address (union)

    YANG Description: Set the local IP (either IPv4 or IPv6) address to use for
the session when sending BGP update messages.  This may be
expressed as either an IP address or reference to the name
of an interface.
    """
    return self.__local_address
      
  def _set_local_address(self, v, load=False):
    """
    Setter method for local_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/transport/local_address (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_address() directly.

    YANG Description: Set the local IP (either IPv4 or IPv6) address to use for
the session when sending BGP update messages.  This may be
expressed as either an IP address or reference to the name
of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),six.text_type,], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_address must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),six.text_type,], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=True)""",
        })

    self.__local_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_address(self):
    self.__local_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),six.text_type,], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=True)


  def _get_auth_password(self):
    """
    Getter method for auth_password, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/transport/auth_password (string)

    YANG Description: Configures an MD5 authentication password for use with
neighboring devices.
    """
    return self.__auth_password
      
  def _set_auth_password(self, v, load=False):
    """
    Setter method for auth_password, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/transport/auth_password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_password() directly.

    YANG Description: Configures an MD5 authentication password for use with
neighboring devices.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="auth-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="auth-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)""",
        })

    self.__auth_password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_password(self):
    self.__auth_password = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="auth-password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)

  tcp_mss = __builtin__.property(_get_tcp_mss, _set_tcp_mss)
  mtu_discovery = __builtin__.property(_get_mtu_discovery, _set_mtu_discovery)
  passive_mode = __builtin__.property(_get_passive_mode, _set_passive_mode)
  local_address = __builtin__.property(_get_local_address, _set_local_address)
  auth_password = __builtin__.property(_get_auth_password, _set_auth_password)


  _pyangbind_elements = OrderedDict([('tcp_mss', tcp_mss), ('mtu_discovery', mtu_discovery), ('passive_mode', passive_mode), ('local_address', local_address), ('auth_password', auth_password), ])


class yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_graceful_restart(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/graceful-restart. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating the graceful restart mechanism for BGP.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__restart_time','__stale_routes_time','__helper_only',)

  _yang_name = 'graceful-restart'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__restart_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    self.__stale_routes_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stale-routes-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__helper_only = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="helper-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'graceful-restart']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/graceful_restart/enabled (boolean)

    YANG Description: Enable or disable the graceful-restart capability.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/graceful_restart/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Enable or disable the graceful-restart capability.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_restart_time(self):
    """
    Getter method for restart_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/graceful_restart/restart_time (uint16)

    YANG Description: Estimated time (in seconds) for the local BGP speaker to
restart a session. This value is advertise in the graceful
restart BGP capability.  This is a 12-bit value, referred to
as Restart Time in RFC4724.  Per RFC4724, the suggested
default value is <= the hold-time value.
    """
    return self.__restart_time
      
  def _set_restart_time(self, v, load=False):
    """
    Setter method for restart_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/graceful_restart/restart_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_time() directly.

    YANG Description: Estimated time (in seconds) for the local BGP speaker to
restart a session. This value is advertise in the graceful
restart BGP capability.  This is a 12-bit value, referred to
as Restart Time in RFC4724.  Per RFC4724, the suggested
default value is <= the hold-time value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)""",
        })

    self.__restart_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_time(self):
    self.__restart_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..4096']}), is_leaf=True, yang_name="restart-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=True)


  def _get_stale_routes_time(self):
    """
    Getter method for stale_routes_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/graceful_restart/stale_routes_time (uint32)

    YANG Description: An upper-bound on the time that stale routes will be
retained by a router after a session is restarted. If an
End-of-RIB (EOR) marker is received prior to this timer
expiring stale-routes will be flushed upon its receipt - if
no EOR is received, then when this timer expires stale paths
will be purged. This timer is referred to as the
Selection_Deferral_Timer in RFC4724
    """
    return self.__stale_routes_time
      
  def _set_stale_routes_time(self, v, load=False):
    """
    Setter method for stale_routes_time, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/graceful_restart/stale_routes_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stale_routes_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stale_routes_time() directly.

    YANG Description: An upper-bound on the time that stale routes will be
retained by a router after a session is restarted. If an
End-of-RIB (EOR) marker is received prior to this timer
expiring stale-routes will be flushed upon its receipt - if
no EOR is received, then when this timer expires stale paths
will be purged. This timer is referred to as the
Selection_Deferral_Timer in RFC4724
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stale-routes-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stale_routes_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stale-routes-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__stale_routes_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stale_routes_time(self):
    self.__stale_routes_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="stale-routes-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_helper_only(self):
    """
    Getter method for helper_only, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/graceful_restart/helper_only (boolean)

    YANG Description: Enable graceful-restart in helper mode only. When this leaf
is set, the local system does not retain forwarding its own
state during a restart, but supports procedures for the
receiving speaker, as defined in RFC4724.
    """
    return self.__helper_only
      
  def _set_helper_only(self, v, load=False):
    """
    Setter method for helper_only, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/graceful_restart/helper_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helper_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helper_only() directly.

    YANG Description: Enable graceful-restart in helper mode only. When this leaf
is set, the local system does not retain forwarding its own
state during a restart, but supports procedures for the
receiving speaker, as defined in RFC4724.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="helper-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """helper_only must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="helper-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__helper_only = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_helper_only(self):
    self.__helper_only = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="helper-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  restart_time = __builtin__.property(_get_restart_time, _set_restart_time)
  stale_routes_time = __builtin__.property(_get_stale_routes_time, _set_stale_routes_time)
  helper_only = __builtin__.property(_get_helper_only, _set_helper_only)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('restart_time', restart_time), ('stale_routes_time', stale_routes_time), ('helper_only', helper_only), ])


class yc_ebgp_multihop_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_ebgp_multihop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/ebgp-multihop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: eBGP multi-hop parameters for the BGPgroup
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__multihop_ttl',)

  _yang_name = 'ebgp-multihop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__multihop_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="multihop-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'ebgp-multihop']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/ebgp_multihop/enabled (boolean)

    YANG Description: When enabled the referenced group or neighbors are
permitted to be indirectly connected - including cases
where the TTL can be decremented between the BGP peers
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/ebgp_multihop/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When enabled the referenced group or neighbors are
permitted to be indirectly connected - including cases
where the TTL can be decremented between the BGP peers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_multihop_ttl(self):
    """
    Getter method for multihop_ttl, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/ebgp_multihop/multihop_ttl (uint8)

    YANG Description: Time-to-live value to use when packets are sent to the
referenced group or neighbors and ebgp-multihop is
enabled
    """
    return self.__multihop_ttl
      
  def _set_multihop_ttl(self, v, load=False):
    """
    Setter method for multihop_ttl, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/ebgp_multihop/multihop_ttl (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_multihop_ttl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_multihop_ttl() directly.

    YANG Description: Time-to-live value to use when packets are sent to the
referenced group or neighbors and ebgp-multihop is
enabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="multihop-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """multihop_ttl must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="multihop-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__multihop_ttl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_multihop_ttl(self):
    self.__multihop_ttl = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="multihop-ttl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  multihop_ttl = __builtin__.property(_get_multihop_ttl, _set_multihop_ttl)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('multihop_ttl', multihop_ttl), ])


class yc_route_reflector_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_route_reflector(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/route-reflector. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route reflector parameters for the BGPgroup
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_reflector_cluster_id','__no_client_reflect','__route_reflector_client',)

  _yang_name = 'route-reflector'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_reflector_cluster_id = YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="route-reflector-cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:rr-cluster-id-type', is_config=True)
    self.__no_client_reflect = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-client-reflect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__route_reflector_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="route-reflector-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'route-reflector']

  def _get_route_reflector_cluster_id(self):
    """
    Getter method for route_reflector_cluster_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_reflector/route_reflector_cluster_id (bt:rr-cluster-id-type)

    YANG Description: Route Reflector cluster id to use when local router is
configured as a route reflector.  Commonly set at the
group level, but allows a different cluster id to be set
for each neighbor.
    """
    return self.__route_reflector_cluster_id
      
  def _set_route_reflector_cluster_id(self, v, load=False):
    """
    Setter method for route_reflector_cluster_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_reflector/route_reflector_cluster_id (bt:rr-cluster-id-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector_cluster_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector_cluster_id() directly.

    YANG Description: Route Reflector cluster id to use when local router is
configured as a route reflector.  Commonly set at the
group level, but allows a different cluster id to be set
for each neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="route-reflector-cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:rr-cluster-id-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector_cluster_id must be of a type compatible with bt:rr-cluster-id-type""",
          'defined-type': "bt:rr-cluster-id-type",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="route-reflector-cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:rr-cluster-id-type', is_config=True)""",
        })

    self.__route_reflector_cluster_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector_cluster_id(self):
    self.__route_reflector_cluster_id = YANGDynClass(base=[RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="route-reflector-cluster-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:rr-cluster-id-type', is_config=True)


  def _get_no_client_reflect(self):
    """
    Getter method for no_client_reflect, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_reflector/no_client_reflect (boolean)

    YANG Description: When set to 'true', this disables route redistribution
by the Route Reflector. It is set 'true' when the client is
fully meshed to prevent sending of redundant route
advertisements.
    """
    return self.__no_client_reflect
      
  def _set_no_client_reflect(self, v, load=False):
    """
    Setter method for no_client_reflect, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_reflector/no_client_reflect (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_client_reflect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_client_reflect() directly.

    YANG Description: When set to 'true', this disables route redistribution
by the Route Reflector. It is set 'true' when the client is
fully meshed to prevent sending of redundant route
advertisements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-client-reflect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_client_reflect must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-client-reflect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__no_client_reflect = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_client_reflect(self):
    self.__no_client_reflect = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="no-client-reflect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_route_reflector_client(self):
    """
    Getter method for route_reflector_client, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_reflector/route_reflector_client (boolean)

    YANG Description: Configure the neighbor as a route reflector client.
    """
    return self.__route_reflector_client
      
  def _set_route_reflector_client(self, v, load=False):
    """
    Setter method for route_reflector_client, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_reflector/route_reflector_client (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector_client is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector_client() directly.

    YANG Description: Configure the neighbor as a route reflector client.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="route-reflector-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector_client must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="route-reflector-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__route_reflector_client = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector_client(self):
    self.__route_reflector_client = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="route-reflector-client", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  route_reflector_cluster_id = __builtin__.property(_get_route_reflector_cluster_id, _set_route_reflector_cluster_id)
  no_client_reflect = __builtin__.property(_get_no_client_reflect, _set_no_client_reflect)
  route_reflector_client = __builtin__.property(_get_route_reflector_client, _set_route_reflector_client)


  _pyangbind_elements = OrderedDict([('route_reflector_cluster_id', route_reflector_cluster_id), ('no_client_reflect', no_client_reflect), ('route_reflector_client', route_reflector_client), ])


class yc_as_path_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_as_path_options(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/as-path-options. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
  """
  __slots__ = ('_path_helper', '_extmethods', '__allow_own_as','__replace_peer_as',)

  _yang_name = 'as-path-options'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__allow_own_as = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="allow-own-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    self.__replace_peer_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="replace-peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'as-path-options']

  def _get_allow_own_as(self):
    """
    Getter method for allow_own_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/as_path_options/allow_own_as (uint8)

    YANG Description: Specify the number of occurrences of the local BGP
speaker's AS that can occur within the AS_PATH before it
is rejected.
    """
    return self.__allow_own_as
      
  def _set_allow_own_as(self, v, load=False):
    """
    Setter method for allow_own_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/as_path_options/allow_own_as (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allow_own_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allow_own_as() directly.

    YANG Description: Specify the number of occurrences of the local BGP
speaker's AS that can occur within the AS_PATH before it
is rejected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="allow-own-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allow_own_as must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="allow-own-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__allow_own_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allow_own_as(self):
    self.__allow_own_as = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="allow-own-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)


  def _get_replace_peer_as(self):
    """
    Getter method for replace_peer_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/as_path_options/replace_peer_as (boolean)

    YANG Description: Replace occurrences of the peer's AS in the AS_PATH with
the local autonomous system number
    """
    return self.__replace_peer_as
      
  def _set_replace_peer_as(self, v, load=False):
    """
    Setter method for replace_peer_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/as_path_options/replace_peer_as (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_replace_peer_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_replace_peer_as() directly.

    YANG Description: Replace occurrences of the peer's AS in the AS_PATH with
the local autonomous system number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="replace-peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """replace_peer_as must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="replace-peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__replace_peer_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_replace_peer_as(self):
    self.__replace_peer_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="replace-peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  allow_own_as = __builtin__.property(_get_allow_own_as, _set_allow_own_as)
  replace_peer_as = __builtin__.property(_get_replace_peer_as, _set_replace_peer_as)


  _pyangbind_elements = OrderedDict([('allow_own_as', allow_own_as), ('replace_peer_as', replace_peer_as), ])


class yc_add_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_add_paths(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/add-paths. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the advertisement and receipt of
multiple paths for a single NLRI (add-paths)
  """
  __slots__ = ('_path_helper', '_extmethods', '__receive','__max_','__all','__eligible_prefix_policy',)

  _yang_name = 'add-paths'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__receive = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max", parent=self, choice=('send', 'max'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    self.__all = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="all", parent=self, choice=('send', 'all'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='empty', is_config=True)
    self.__eligible_prefix_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="eligible-prefix-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'add-paths']

  def _get_receive(self):
    """
    Getter method for receive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/add_paths/receive (boolean)

    YANG Description: Enable ability to receive multiple path advertisements for
an NLRI from the neighbor or group
    """
    return self.__receive
      
  def _set_receive(self, v, load=False):
    """
    Setter method for receive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/add_paths/receive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive() directly.

    YANG Description: Enable ability to receive multiple path advertisements for
an NLRI from the neighbor or group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__receive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive(self):
    self.__receive = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/add_paths/max (uint8)

    YANG Description: The maximum number of paths to advertise to neighbors
for a single NLRI
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/add_paths/max (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum number of paths to advertise to neighbors
for a single NLRI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max", parent=self, choice=('send', 'max'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max", parent=self, choice=('send', 'max'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="max", parent=self, choice=('send', 'max'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=True)


  def _get_all(self):
    """
    Getter method for all, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/add_paths/all (empty)

    YANG Description: Send all the path advertisements to neighbors for a
single NLRI.
    """
    return self.__all
      
  def _set_all(self, v, load=False):
    """
    Setter method for all, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/add_paths/all (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_all is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_all() directly.

    YANG Description: Send all the path advertisements to neighbors for a
single NLRI.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="all", parent=self, choice=('send', 'all'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """all must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="all", parent=self, choice=('send', 'all'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='empty', is_config=True)""",
        })

    self.__all = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_all(self):
    self.__all = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="all", parent=self, choice=('send', 'all'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='empty', is_config=True)


  def _get_eligible_prefix_policy(self):
    """
    Getter method for eligible_prefix_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/add_paths/eligible_prefix_policy (leafref)

    YANG Description: A reference to a routing policy which can be used to
restrict the prefixes for which add-paths is enabled
    """
    return self.__eligible_prefix_policy
      
  def _set_eligible_prefix_policy(self, v, load=False):
    """
    Setter method for eligible_prefix_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/add_paths/eligible_prefix_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eligible_prefix_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eligible_prefix_policy() directly.

    YANG Description: A reference to a routing policy which can be used to
restrict the prefixes for which add-paths is enabled
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="eligible-prefix-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eligible_prefix_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="eligible-prefix-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__eligible_prefix_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eligible_prefix_policy(self):
    self.__eligible_prefix_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="eligible-prefix-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)

  receive = __builtin__.property(_get_receive, _set_receive)
  max_ = __builtin__.property(_get_max_, _set_max_)
  all = __builtin__.property(_get_all, _set_all)
  eligible_prefix_policy = __builtin__.property(_get_eligible_prefix_policy, _set_eligible_prefix_policy)

  __choices__ = {'send': {'max': ['max_'], 'all': ['all']}}
  _pyangbind_elements = OrderedDict([('receive', receive), ('max_', max_), ('all', all), ('eligible_prefix_policy', eligible_prefix_policy), ])


class yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths_ebgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/use-multiple-paths/ebgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multi-Path parameters for eBGP
  """
  __slots__ = ('_path_helper', '_extmethods', '__allow_multiple_as','__maximum_paths',)

  _yang_name = 'ebgp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__allow_multiple_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'use-multiple-paths', 'ebgp']

  def _get_allow_multiple_as(self):
    """
    Getter method for allow_multiple_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/use_multiple_paths/ebgp/allow_multiple_as (boolean)

    YANG Description: Allow multi-path to use paths from different neighboring
ASes.  The default is to only consider multiple paths
from the same neighboring AS.
    """
    return self.__allow_multiple_as
      
  def _set_allow_multiple_as(self, v, load=False):
    """
    Setter method for allow_multiple_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/use_multiple_paths/ebgp/allow_multiple_as (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allow_multiple_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allow_multiple_as() directly.

    YANG Description: Allow multi-path to use paths from different neighboring
ASes.  The default is to only consider multiple paths
from the same neighboring AS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allow_multiple_as must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__allow_multiple_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allow_multiple_as(self):
    self.__allow_multiple_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_maximum_paths(self):
    """
    Getter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/use_multiple_paths/ebgp/maximum_paths (uint32)

    YANG Description: Maximum number of parallel paths to consider when using
BGP multi-path. The default is use a single path.
    """
    return self.__maximum_paths
      
  def _set_maximum_paths(self, v, load=False):
    """
    Setter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/use_multiple_paths/ebgp/maximum_paths (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_paths() directly.

    YANG Description: Maximum number of parallel paths to consider when using
BGP multi-path. The default is use a single path.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_paths must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__maximum_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_paths(self):
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  allow_multiple_as = __builtin__.property(_get_allow_multiple_as, _set_allow_multiple_as)
  maximum_paths = __builtin__.property(_get_maximum_paths, _set_maximum_paths)


  _pyangbind_elements = OrderedDict([('allow_multiple_as', allow_multiple_as), ('maximum_paths', maximum_paths), ])


class yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths_ibgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/use-multiple-paths/ibgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multi-Path parameters for iBGP
  """
  __slots__ = ('_path_helper', '_extmethods', '__maximum_paths',)

  _yang_name = 'ibgp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'use-multiple-paths', 'ibgp']

  def _get_maximum_paths(self):
    """
    Getter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/use_multiple_paths/ibgp/maximum_paths (uint32)

    YANG Description: Maximum number of parallel paths to consider when using
iBGP multi-path. The default is to use a single path
    """
    return self.__maximum_paths
      
  def _set_maximum_paths(self, v, load=False):
    """
    Setter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/use_multiple_paths/ibgp/maximum_paths (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_paths() directly.

    YANG Description: Maximum number of parallel paths to consider when using
iBGP multi-path. The default is to use a single path
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_paths must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__maximum_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_paths(self):
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  maximum_paths = __builtin__.property(_get_maximum_paths, _set_maximum_paths)


  _pyangbind_elements = OrderedDict([('maximum_paths', maximum_paths), ])


class yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/use-multiple-paths. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters related to the use of multiple paths for the
same NLRI
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__ebgp','__ibgp',)

  _yang_name = 'use-multiple-paths'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ebgp = YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ibgp = YANGDynClass(base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'use-multiple-paths']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/use_multiple_paths/enabled (boolean)

    YANG Description: Whether the use of multiple paths for the same NLRI is
enabled for the neighbor. This value is overridden by any
more specific configuration value.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/use_multiple_paths/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Whether the use of multiple paths for the same NLRI is
enabled for the neighbor. This value is overridden by any
more specific configuration value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ebgp(self):
    """
    Getter method for ebgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/use_multiple_paths/ebgp (container)

    YANG Description: Multi-Path parameters for eBGP
    """
    return self.__ebgp
      
  def _set_ebgp(self, v, load=False):
    """
    Setter method for ebgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/use_multiple_paths/ebgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp() directly.

    YANG Description: Multi-Path parameters for eBGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp(self):
    self.__ebgp = YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ibgp(self):
    """
    Getter method for ibgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/use_multiple_paths/ibgp (container)

    YANG Description: Multi-Path parameters for iBGP
    """
    return self.__ibgp
      
  def _set_ibgp(self, v, load=False):
    """
    Setter method for ibgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/use_multiple_paths/ibgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ibgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ibgp() directly.

    YANG Description: Multi-Path parameters for iBGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ibgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ibgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ibgp(self):
    self.__ibgp = YANGDynClass(base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  ebgp = __builtin__.property(_get_ebgp, _set_ebgp) # type: yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths_ebgp
  ibgp = __builtin__.property(_get_ibgp, _set_ibgp) # type: yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths_ibgp


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('ebgp', ebgp), ('ibgp', ibgp), ])


class yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_apply_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/apply-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
  """
  __slots__ = ('_path_helper', '_extmethods', '__import_policy','__default_import_policy','__export_policy','__default_export_policy',)

  _yang_name = 'apply-policy'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__import_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__default_import_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    self.__export_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__default_export_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'apply-policy']

  def _get_import_policy(self):
    """
    Getter method for import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/apply_policy/import_policy (leafref)

    YANG Description: List of policy names in sequence to be applied on
receiving redistributed routes from another routing protocol
or receiving a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    return self.__import_policy
      
  def _set_import_policy(self, v, load=False):
    """
    Setter method for import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/apply_policy/import_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_policy() directly.

    YANG Description: List of policy names in sequence to be applied on
receiving redistributed routes from another routing protocol
or receiving a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_policy(self):
    self.__import_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_default_import_policy(self):
    """
    Getter method for default_import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/apply_policy/default_import_policy (default-policy-type)

    YANG Description: Explicitly set a default policy if no policy definition
in the import policy chain is satisfied.
    """
    return self.__default_import_policy
      
  def _set_default_import_policy(self, v, load=False):
    """
    Setter method for default_import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/apply_policy/default_import_policy (default-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_import_policy() directly.

    YANG Description: Explicitly set a default policy if no policy definition
in the import policy chain is satisfied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_import_policy must be of a type compatible with default-policy-type""",
          'defined-type': "ietf-bgp:default-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)""",
        })

    self.__default_import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_import_policy(self):
    self.__default_import_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)


  def _get_export_policy(self):
    """
    Getter method for export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/apply_policy/export_policy (leafref)

    YANG Description: List of policy names in sequence to be applied on
redistributing routes from one routing protocol to another
or sending a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    return self.__export_policy
      
  def _set_export_policy(self, v, load=False):
    """
    Setter method for export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/apply_policy/export_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_export_policy() directly.

    YANG Description: List of policy names in sequence to be applied on
redistributing routes from one routing protocol to another
or sending a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """export_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_export_policy(self):
    self.__export_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_default_export_policy(self):
    """
    Getter method for default_export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/apply_policy/default_export_policy (default-policy-type)

    YANG Description: Explicitly set a default policy if no policy definition
in the export policy chain is satisfied.
    """
    return self.__default_export_policy
      
  def _set_default_export_policy(self, v, load=False):
    """
    Setter method for default_export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/apply_policy/default_export_policy (default-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_export_policy() directly.

    YANG Description: Explicitly set a default policy if no policy definition
in the export policy chain is satisfied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_export_policy must be of a type compatible with default-policy-type""",
          'defined-type': "ietf-bgp:default-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)""",
        })

    self.__default_export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_export_policy(self):
    self.__default_export_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)

  import_policy = __builtin__.property(_get_import_policy, _set_import_policy)
  default_import_policy = __builtin__.property(_get_default_import_policy, _set_default_import_policy)
  export_policy = __builtin__.property(_get_export_policy, _set_export_policy)
  default_export_policy = __builtin__.property(_get_default_export_policy, _set_default_export_policy)


  _pyangbind_elements = OrderedDict([('import_policy', import_policy), ('default_import_policy', default_import_policy), ('export_policy', export_policy), ('default_export_policy', default_export_policy), ])


class yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_graceful_restart(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/graceful-restart. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to BGP graceful-restart
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled',)

  _yang_name = 'graceful-restart'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'graceful-restart']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/graceful_restart/enabled (boolean)

    YANG Description: This leaf indicates whether graceful-restart is enabled for
this AFI-SAFI
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/graceful_restart/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf indicates whether graceful-restart is enabled for
this AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ])


class yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_route_selection_options(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/route-selection-options. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to options for route selection
  """
  __slots__ = ('_path_helper', '_extmethods', '__always_compare_med','__ignore_as_path_length','__external_compare_router_id','__advertise_inactive_routes','__enable_aigp','__ignore_next_hop_igp_metric','__enable_med',)

  _yang_name = 'route-selection-options'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__always_compare_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ignore_as_path_length = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__external_compare_router_id = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__advertise_inactive_routes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__enable_aigp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ignore_next_hop_igp_metric = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__enable_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'route-selection-options']

  def _get_always_compare_med(self):
    """
    Getter method for always_compare_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options/always_compare_med (boolean)

    YANG Description: Compare multi-exit discriminator (MED) value from
different ASes when selecting the best route.  The default
behavior is to only compare MEDs for paths received from
the same AS.
    """
    return self.__always_compare_med
      
  def _set_always_compare_med(self, v, load=False):
    """
    Setter method for always_compare_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options/always_compare_med (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_always_compare_med is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_always_compare_med() directly.

    YANG Description: Compare multi-exit discriminator (MED) value from
different ASes when selecting the best route.  The default
behavior is to only compare MEDs for paths received from
the same AS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """always_compare_med must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__always_compare_med = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_always_compare_med(self):
    self.__always_compare_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="always-compare-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ignore_as_path_length(self):
    """
    Getter method for ignore_as_path_length, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options/ignore_as_path_length (boolean)

    YANG Description: Ignore the AS path length when selecting the best path.
The default is to use the AS path length and prefer paths
with shorter length.
    """
    return self.__ignore_as_path_length
      
  def _set_ignore_as_path_length(self, v, load=False):
    """
    Setter method for ignore_as_path_length, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options/ignore_as_path_length (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_as_path_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_as_path_length() directly.

    YANG Description: Ignore the AS path length when selecting the best path.
The default is to use the AS path length and prefer paths
with shorter length.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_as_path_length must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ignore_as_path_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_as_path_length(self):
    self.__ignore_as_path_length = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-as-path-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_external_compare_router_id(self):
    """
    Getter method for external_compare_router_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options/external_compare_router_id (boolean)

    YANG Description: When comparing similar routes received from external BGP
peers, use the router-id as a criterion to select the
active path.
    """
    return self.__external_compare_router_id
      
  def _set_external_compare_router_id(self, v, load=False):
    """
    Setter method for external_compare_router_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options/external_compare_router_id (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external_compare_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external_compare_router_id() directly.

    YANG Description: When comparing similar routes received from external BGP
peers, use the router-id as a criterion to select the
active path.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """external_compare_router_id must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__external_compare_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_external_compare_router_id(self):
    self.__external_compare_router_id = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="external-compare-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_advertise_inactive_routes(self):
    """
    Getter method for advertise_inactive_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options/advertise_inactive_routes (boolean)

    YANG Description: Advertise inactive routes to external peers.  The default
is to only advertise active routes.
    """
    return self.__advertise_inactive_routes
      
  def _set_advertise_inactive_routes(self, v, load=False):
    """
    Setter method for advertise_inactive_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options/advertise_inactive_routes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_advertise_inactive_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_advertise_inactive_routes() directly.

    YANG Description: Advertise inactive routes to external peers.  The default
is to only advertise active routes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """advertise_inactive_routes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__advertise_inactive_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_advertise_inactive_routes(self):
    self.__advertise_inactive_routes = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="advertise-inactive-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_enable_aigp(self):
    """
    Getter method for enable_aigp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options/enable_aigp (boolean)

    YANG Description: Flag to enable sending / receiving accumulated IGP
attribute in routing updates
    """
    return self.__enable_aigp
      
  def _set_enable_aigp(self, v, load=False):
    """
    Setter method for enable_aigp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options/enable_aigp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_aigp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_aigp() directly.

    YANG Description: Flag to enable sending / receiving accumulated IGP
attribute in routing updates
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_aigp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enable_aigp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_aigp(self):
    self.__enable_aigp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-aigp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ignore_next_hop_igp_metric(self):
    """
    Getter method for ignore_next_hop_igp_metric, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options/ignore_next_hop_igp_metric (boolean)

    YANG Description: Ignore the IGP metric to the next-hop when calculating BGP
best-path. The default is to select the route for which
the metric to the next-hop is lowest
    """
    return self.__ignore_next_hop_igp_metric
      
  def _set_ignore_next_hop_igp_metric(self, v, load=False):
    """
    Setter method for ignore_next_hop_igp_metric, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options/ignore_next_hop_igp_metric (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_next_hop_igp_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_next_hop_igp_metric() directly.

    YANG Description: Ignore the IGP metric to the next-hop when calculating BGP
best-path. The default is to select the route for which
the metric to the next-hop is lowest
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_next_hop_igp_metric must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__ignore_next_hop_igp_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_next_hop_igp_metric(self):
    self.__ignore_next_hop_igp_metric = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-next-hop-igp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_enable_med(self):
    """
    Getter method for enable_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options/enable_med (boolean)

    YANG Description: Flag to enable sending/receiving of MED metric attribute
       in routing updates.
    """
    return self.__enable_med
      
  def _set_enable_med(self, v, load=False):
    """
    Setter method for enable_med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options/enable_med (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_med is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_med() directly.

    YANG Description: Flag to enable sending/receiving of MED metric attribute
       in routing updates.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_med must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enable_med = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_med(self):
    self.__enable_med = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  always_compare_med = __builtin__.property(_get_always_compare_med, _set_always_compare_med)
  ignore_as_path_length = __builtin__.property(_get_ignore_as_path_length, _set_ignore_as_path_length)
  external_compare_router_id = __builtin__.property(_get_external_compare_router_id, _set_external_compare_router_id)
  advertise_inactive_routes = __builtin__.property(_get_advertise_inactive_routes, _set_advertise_inactive_routes)
  enable_aigp = __builtin__.property(_get_enable_aigp, _set_enable_aigp)
  ignore_next_hop_igp_metric = __builtin__.property(_get_ignore_next_hop_igp_metric, _set_ignore_next_hop_igp_metric)
  enable_med = __builtin__.property(_get_enable_med, _set_enable_med)


  _pyangbind_elements = OrderedDict([('always_compare_med', always_compare_med), ('ignore_as_path_length', ignore_as_path_length), ('external_compare_router_id', external_compare_router_id), ('advertise_inactive_routes', advertise_inactive_routes), ('enable_aigp', enable_aigp), ('ignore_next_hop_igp_metric', ignore_next_hop_igp_metric), ('enable_med', enable_med), ])


class yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths_ebgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/use-multiple-paths/ebgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multi-Path parameters for eBGP
  """
  __slots__ = ('_path_helper', '_extmethods', '__allow_multiple_as','__maximum_paths',)

  _yang_name = 'ebgp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__allow_multiple_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'use-multiple-paths', 'ebgp']

  def _get_allow_multiple_as(self):
    """
    Getter method for allow_multiple_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/ebgp/allow_multiple_as (boolean)

    YANG Description: Allow multi-path to use paths from different neighboring
ASes.  The default is to only consider multiple paths
from the same neighboring AS.
    """
    return self.__allow_multiple_as
      
  def _set_allow_multiple_as(self, v, load=False):
    """
    Setter method for allow_multiple_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/ebgp/allow_multiple_as (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allow_multiple_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allow_multiple_as() directly.

    YANG Description: Allow multi-path to use paths from different neighboring
ASes.  The default is to only consider multiple paths
from the same neighboring AS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allow_multiple_as must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__allow_multiple_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allow_multiple_as(self):
    self.__allow_multiple_as = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="allow-multiple-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_maximum_paths(self):
    """
    Getter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/ebgp/maximum_paths (uint32)

    YANG Description: Maximum number of parallel paths to consider when using
BGP multi-path. The default is use a single path.
    """
    return self.__maximum_paths
      
  def _set_maximum_paths(self, v, load=False):
    """
    Setter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/ebgp/maximum_paths (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_paths() directly.

    YANG Description: Maximum number of parallel paths to consider when using
BGP multi-path. The default is use a single path.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_paths must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__maximum_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_paths(self):
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  allow_multiple_as = __builtin__.property(_get_allow_multiple_as, _set_allow_multiple_as)
  maximum_paths = __builtin__.property(_get_maximum_paths, _set_maximum_paths)


  _pyangbind_elements = OrderedDict([('allow_multiple_as', allow_multiple_as), ('maximum_paths', maximum_paths), ])


class yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths_ibgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/use-multiple-paths/ibgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multi-Path parameters for iBGP
  """
  __slots__ = ('_path_helper', '_extmethods', '__maximum_paths',)

  _yang_name = 'ibgp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'use-multiple-paths', 'ibgp']

  def _get_maximum_paths(self):
    """
    Getter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/ibgp/maximum_paths (uint32)

    YANG Description: Maximum number of parallel paths to consider when using
iBGP multi-path. The default is to use a single path
    """
    return self.__maximum_paths
      
  def _set_maximum_paths(self, v, load=False):
    """
    Setter method for maximum_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/ibgp/maximum_paths (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_maximum_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_maximum_paths() directly.

    YANG Description: Maximum number of parallel paths to consider when using
iBGP multi-path. The default is to use a single path
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """maximum_paths must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__maximum_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_maximum_paths(self):
    self.__maximum_paths = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="maximum-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  maximum_paths = __builtin__.property(_get_maximum_paths, _set_maximum_paths)


  _pyangbind_elements = OrderedDict([('maximum_paths', maximum_paths), ])


class yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/use-multiple-paths. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters related to the use of multiple paths for the
same NLRI
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__ebgp','__ibgp',)

  _yang_name = 'use-multiple-paths'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__ebgp = YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ibgp = YANGDynClass(base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'use-multiple-paths']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/enabled (boolean)

    YANG Description: Whether the use of multiple paths for the same NLRI is
enabled for the neighbor. This value is overridden by any
more specific configuration value.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Whether the use of multiple paths for the same NLRI is
enabled for the neighbor. This value is overridden by any
more specific configuration value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_ebgp(self):
    """
    Getter method for ebgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/ebgp (container)

    YANG Description: Multi-Path parameters for eBGP
    """
    return self.__ebgp
      
  def _set_ebgp(self, v, load=False):
    """
    Setter method for ebgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/ebgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp() directly.

    YANG Description: Multi-Path parameters for eBGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp(self):
    self.__ebgp = YANGDynClass(base=yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths_ebgp, is_container='container', yang_name="ebgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ibgp(self):
    """
    Getter method for ibgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/ibgp (container)

    YANG Description: Multi-Path parameters for iBGP
    """
    return self.__ibgp
      
  def _set_ibgp(self, v, load=False):
    """
    Setter method for ibgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths/ibgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ibgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ibgp() directly.

    YANG Description: Multi-Path parameters for iBGP
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ibgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ibgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ibgp(self):
    self.__ibgp = YANGDynClass(base=yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths_ibgp, is_container='container', yang_name="ibgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  enabled = __builtin__.property(_get_enabled, _set_enabled)
  ebgp = __builtin__.property(_get_ebgp, _set_ebgp) # type: yc_ebgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths_ebgp
  ibgp = __builtin__.property(_get_ibgp, _set_ibgp) # type: yc_ibgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths_ibgp


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('ebgp', ebgp), ('ibgp', ibgp), ])


class yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_apply_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/apply-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
  """
  __slots__ = ('_path_helper', '_extmethods', '__import_policy','__default_import_policy','__export_policy','__default_export_policy',)

  _yang_name = 'apply-policy'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__import_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__default_import_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    self.__export_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    self.__default_export_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'apply-policy']

  def _get_import_policy(self):
    """
    Getter method for import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/apply_policy/import_policy (leafref)

    YANG Description: List of policy names in sequence to be applied on
receiving redistributed routes from another routing protocol
or receiving a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    return self.__import_policy
      
  def _set_import_policy(self, v, load=False):
    """
    Setter method for import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/apply_policy/import_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_policy() directly.

    YANG Description: List of policy names in sequence to be applied on
receiving redistributed routes from another routing protocol
or receiving a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_policy(self):
    self.__import_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_default_import_policy(self):
    """
    Getter method for default_import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/apply_policy/default_import_policy (default-policy-type)

    YANG Description: Explicitly set a default policy if no policy definition
in the import policy chain is satisfied.
    """
    return self.__default_import_policy
      
  def _set_default_import_policy(self, v, load=False):
    """
    Setter method for default_import_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/apply_policy/default_import_policy (default-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_import_policy() directly.

    YANG Description: Explicitly set a default policy if no policy definition
in the import policy chain is satisfied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_import_policy must be of a type compatible with default-policy-type""",
          'defined-type': "ietf-bgp:default-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)""",
        })

    self.__default_import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_import_policy(self):
    self.__default_import_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-import-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)


  def _get_export_policy(self):
    """
    Getter method for export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/apply_policy/export_policy (leafref)

    YANG Description: List of policy names in sequence to be applied on
redistributing routes from one routing protocol to another
or sending a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    return self.__export_policy
      
  def _set_export_policy(self, v, load=False):
    """
    Setter method for export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/apply_policy/export_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_export_policy() directly.

    YANG Description: List of policy names in sequence to be applied on
redistributing routes from one routing protocol to another
or sending a routing update in the current context, e.g.,
for the current peer group, neighbor, address family,
etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """export_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)""",
        })

    self.__export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_export_policy(self):
    self.__export_policy = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=True)


  def _get_default_export_policy(self):
    """
    Getter method for default_export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/apply_policy/default_export_policy (default-policy-type)

    YANG Description: Explicitly set a default policy if no policy definition
in the export policy chain is satisfied.
    """
    return self.__default_export_policy
      
  def _set_default_export_policy(self, v, load=False):
    """
    Setter method for default_export_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/apply_policy/default_export_policy (default-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_export_policy() directly.

    YANG Description: Explicitly set a default policy if no policy definition
in the export policy chain is satisfied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_export_policy must be of a type compatible with default-policy-type""",
          'defined-type': "ietf-bgp:default-policy-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)""",
        })

    self.__default_export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_export_policy(self):
    self.__default_export_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'accept-route': {}, 'reject-route': {}},), default=six.text_type("reject-route"), is_leaf=True, yang_name="default-export-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='default-policy-type', is_config=True)

  import_policy = __builtin__.property(_get_import_policy, _set_import_policy)
  default_import_policy = __builtin__.property(_get_default_import_policy, _set_default_import_policy)
  export_policy = __builtin__.property(_get_export_policy, _set_export_policy)
  default_export_policy = __builtin__.property(_get_default_export_policy, _set_default_export_policy)


  _pyangbind_elements = OrderedDict([('import_policy', import_policy), ('default_import_policy', default_import_policy), ('export_policy', export_policy), ('default_export_policy', default_export_policy), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/ipv4-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/ipv4-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv4 unicast configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit','__send_default_route',)

  _yang_name = 'ipv4-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__send_default_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'ipv4-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_send_default_route(self):
    """
    Getter method for send_default_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_unicast/send_default_route (boolean)

    YANG Description: If set to true, send the default-route to the neighbour(s)
    """
    return self.__send_default_route
      
  def _set_send_default_route(self, v, load=False):
    """
    Setter method for send_default_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_unicast/send_default_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_default_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_default_route() directly.

    YANG Description: If set to true, send the default-route to the neighbour(s)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_default_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__send_default_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_default_route(self):
    self.__send_default_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_unicast_prefix_limit
  send_default_route = __builtin__.property(_get_send_default_route, _set_send_default_route)


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ('send_default_route', send_default_route), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/ipv6-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/ipv6-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv6 unicast configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit','__send_default_route',)

  _yang_name = 'ipv6-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__send_default_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'ipv6-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_send_default_route(self):
    """
    Getter method for send_default_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_unicast/send_default_route (boolean)

    YANG Description: If set to true, send the default-route to the neighbour(s)
    """
    return self.__send_default_route
      
  def _set_send_default_route(self, v, load=False):
    """
    Setter method for send_default_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_unicast/send_default_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_default_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_default_route() directly.

    YANG Description: If set to true, send the default-route to the neighbour(s)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_default_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__send_default_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_default_route(self):
    self.__send_default_route = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="send-default-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_unicast_prefix_limit
  send_default_route = __builtin__.property(_get_send_default_route, _set_send_default_route)


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ('send_default_route', send_default_route), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/ipv4-labeled-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'ipv4-labeled-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_labeled_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/ipv4-labeled-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv4 Labeled Unicast configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'ipv4-labeled-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'ipv4-labeled-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_labeled_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_labeled_unicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/ipv6-labeled-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'ipv6-labeled-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_labeled_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/ipv6-labeled-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPv6 Labeled Unicast configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'ipv6-labeled-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'ipv6-labeled-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_labeled_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_labeled_unicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/l3vpn-ipv4-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'l3vpn-ipv4-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/l3vpn-ipv4-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unicast IPv4 L3VPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l3vpn-ipv4-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'l3vpn-ipv4-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_unicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/l3vpn-ipv6-unicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'l3vpn-ipv6-unicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/l3vpn-ipv6-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unicast IPv6 L3VPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l3vpn-ipv6-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'l3vpn-ipv6-unicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_unicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_unicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/l3vpn-ipv4-multicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'l3vpn-ipv4-multicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_multicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/l3vpn-ipv4-multicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multicast IPv4 L3VPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l3vpn-ipv4-multicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'l3vpn-ipv4-multicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_multicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_multicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/l3vpn-ipv6-multicast/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'l3vpn-ipv6-multicast', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_multicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/l3vpn-ipv6-multicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Multicast IPv6 L3VPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l3vpn-ipv6-multicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'l3vpn-ipv6-multicast']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_multicast/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_multicast_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_vpls_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/l2vpn-vpls/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'l2vpn-vpls', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_vpls/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_vpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/l2vpn-vpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BGP-signalled VPLS configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l2vpn-vpls'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_vpls_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'l2vpn-vpls']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_vpls/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_vpls/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_vpls_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_vpls_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_vpls_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_vpls_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_evpn_prefix_limit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/l2vpn-evpn/prefix-limit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
  """
  __slots__ = ('_path_helper', '_extmethods', '__max_prefixes','__shutdown_threshold_pct','__restart_timer',)

  _yang_name = 'prefix-limit'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'l2vpn-evpn', 'prefix-limit']

  def _get_max_prefixes(self):
    """
    Getter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/max_prefixes (uint32)

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    return self.__max_prefixes
      
  def _set_max_prefixes(self, v, load=False):
    """
    Setter method for max_prefixes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/max_prefixes (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_prefixes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_prefixes() directly.

    YANG Description: Maximum number of prefixes that will be accepted from the
neighbour
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_prefixes must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__max_prefixes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_prefixes(self):
    self.__max_prefixes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-prefixes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_shutdown_threshold_pct(self):
    """
    Getter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/shutdown_threshold_pct (bt:percentage)

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    return self.__shutdown_threshold_pct
      
  def _set_shutdown_threshold_pct(self, v, load=False):
    """
    Setter method for shutdown_threshold_pct, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/shutdown_threshold_pct (bt:percentage)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shutdown_threshold_pct is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shutdown_threshold_pct() directly.

    YANG Description: Threshold on number of prefixes that can be received from
a neighbour before generation of warning messages or log
entries. Expressed as a percentage of max-prefixes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shutdown_threshold_pct must be of a type compatible with bt:percentage""",
          'defined-type': "bt:percentage",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)""",
        })

    self.__shutdown_threshold_pct = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shutdown_threshold_pct(self):
    self.__shutdown_threshold_pct = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..100']}), is_leaf=True, yang_name="shutdown-threshold-pct", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:percentage', is_config=True)


  def _get_restart_timer(self):
    """
    Getter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/restart_timer (uint32)

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    return self.__restart_timer
      
  def _set_restart_timer(self, v, load=False):
    """
    Setter method for restart_timer, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_evpn/prefix_limit/restart_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_restart_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_restart_timer() directly.

    YANG Description: Time interval in seconds after which the BGP session is
re-established after being torn down due to exceeding the
max-prefix limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """restart_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__restart_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_restart_timer(self):
    self.__restart_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="restart-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  max_prefixes = __builtin__.property(_get_max_prefixes, _set_max_prefixes)
  shutdown_threshold_pct = __builtin__.property(_get_shutdown_threshold_pct, _set_shutdown_threshold_pct)
  restart_timer = __builtin__.property(_get_restart_timer, _set_restart_timer)


  _pyangbind_elements = OrderedDict([('max_prefixes', max_prefixes), ('shutdown_threshold_pct', shutdown_threshold_pct), ('restart_timer', restart_timer), ])


class yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_evpn(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi/l2vpn-evpn. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BGP EVPN configuration options
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix_limit',)

  _yang_name = 'l2vpn-evpn'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_evpn_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi', 'l2vpn-evpn']

  def _get_prefix_limit(self):
    """
    Getter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_evpn/prefix_limit (container)

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    return self.__prefix_limit
      
  def _set_prefix_limit(self, v, load=False):
    """
    Setter method for prefix_limit, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_evpn/prefix_limit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_limit() directly.

    YANG Description: Parameters relating to the prefix limit for the AFI-SAFI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_evpn_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_limit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_evpn_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__prefix_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_limit(self):
    self.__prefix_limit = YANGDynClass(base=yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_evpn_prefix_limit, is_container='container', yang_name="prefix-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  prefix_limit = __builtin__.property(_get_prefix_limit, _set_prefix_limit) # type: yc_prefix_limit_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_evpn_prefix_limit


  _pyangbind_elements = OrderedDict([('prefix_limit', prefix_limit), ])


class yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis/afi-safi. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: AFI, SAFI configuration available for the
neighbour or group
  """
  __slots__ = ('_path_helper', '_extmethods', '__afi_safi_name','__enabled','__graceful_restart','__route_selection_options','__use_multiple_paths','__apply_policy','__ipv4_unicast','__ipv6_unicast','__ipv4_labeled_unicast','__ipv6_labeled_unicast','__l3vpn_ipv4_unicast','__l3vpn_ipv6_unicast','__l3vpn_ipv4_multicast','__l3vpn_ipv6_multicast','__l2vpn_vpls','__l2vpn_evpn',)

  _yang_name = 'afi-safi'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afi_safi_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__graceful_restart = YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__route_selection_options = YANGDynClass(base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__use_multiple_paths = YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__apply_policy = YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ipv4_unicast = YANGDynClass(base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ipv6_unicast = YANGDynClass(base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ipv4_labeled_unicast = YANGDynClass(base=yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_labeled_unicast, is_container='container', yang_name="ipv4-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ipv6_labeled_unicast = YANGDynClass(base=yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_labeled_unicast, is_container='container', yang_name="ipv6-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l3vpn_ipv4_unicast = YANGDynClass(base=yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_unicast, is_container='container', yang_name="l3vpn-ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l3vpn_ipv6_unicast = YANGDynClass(base=yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_unicast, is_container='container', yang_name="l3vpn-ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l3vpn_ipv4_multicast = YANGDynClass(base=yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_multicast, is_container='container', yang_name="l3vpn-ipv4-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l3vpn_ipv6_multicast = YANGDynClass(base=yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_multicast, is_container='container', yang_name="l3vpn-ipv6-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l2vpn_vpls = YANGDynClass(base=yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_vpls, is_container='container', yang_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__l2vpn_evpn = YANGDynClass(base=yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_evpn, is_container='container', yang_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis', 'afi-safi']

  def _get_afi_safi_name(self):
    """
    Getter method for afi_safi_name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/afi_safi_name (identityref)

    YANG Description: AFI,SAFI
    """
    return self.__afi_safi_name
      
  def _set_afi_safi_name(self, v, load=False):
    """
    Setter method for afi_safi_name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/afi_safi_name (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safi_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safi_name() directly.

    YANG Description: AFI,SAFI
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safi_name must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=True)""",
        })

    self.__afi_safi_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safi_name(self):
    self.__afi_safi_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/enabled (boolean)

    YANG Description: This leaf indicates whether the IPv4 Unicast AFI,SAFI is
enabled for the neighbour or group
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This leaf indicates whether the IPv4 Unicast AFI,SAFI is
enabled for the neighbour or group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/graceful_restart (container)

    YANG Description: Parameters relating to BGP graceful-restart
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: Parameters relating to BGP graceful-restart
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_route_selection_options(self):
    """
    Getter method for route_selection_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options (container)

    YANG Description: Parameters relating to options for route selection
    """
    return self.__route_selection_options
      
  def _set_route_selection_options(self, v, load=False):
    """
    Setter method for route_selection_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/route_selection_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_selection_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_selection_options() directly.

    YANG Description: Parameters relating to options for route selection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_selection_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_selection_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_selection_options(self):
    self.__route_selection_options = YANGDynClass(base=yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_route_selection_options, is_container='container', yang_name="route-selection-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_use_multiple_paths(self):
    """
    Getter method for use_multiple_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths (container)

    YANG Description: Parameters related to the use of multiple paths for the
same NLRI
    """
    return self.__use_multiple_paths
      
  def _set_use_multiple_paths(self, v, load=False):
    """
    Setter method for use_multiple_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/use_multiple_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_multiple_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_multiple_paths() directly.

    YANG Description: Parameters related to the use of multiple paths for the
same NLRI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_multiple_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__use_multiple_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_multiple_paths(self):
    self.__use_multiple_paths = YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_apply_policy(self):
    """
    Getter method for apply_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/apply_policy (container)

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    return self.__apply_policy
      
  def _set_apply_policy(self, v, load=False):
    """
    Setter method for apply_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/apply_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_policy() directly.

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__apply_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_policy(self):
    self.__apply_policy = YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ipv4_unicast(self):
    """
    Getter method for ipv4_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_unicast (container)

    YANG Description: IPv4 unicast configuration options
    """
    return self.__ipv4_unicast
      
  def _set_ipv4_unicast(self, v, load=False):
    """
    Setter method for ipv4_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_unicast() directly.

    YANG Description: IPv4 unicast configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ipv4_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_unicast(self):
    self.__ipv4_unicast = YANGDynClass(base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ipv6_unicast(self):
    """
    Getter method for ipv6_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_unicast (container)

    YANG Description: IPv6 unicast configuration options
    """
    return self.__ipv6_unicast
      
  def _set_ipv6_unicast(self, v, load=False):
    """
    Setter method for ipv6_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_unicast() directly.

    YANG Description: IPv6 unicast configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ipv6_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_unicast(self):
    self.__ipv6_unicast = YANGDynClass(base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ipv4_labeled_unicast(self):
    """
    Getter method for ipv4_labeled_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_labeled_unicast (container)

    YANG Description: IPv4 Labeled Unicast configuration options
    """
    return self.__ipv4_labeled_unicast
      
  def _set_ipv4_labeled_unicast(self, v, load=False):
    """
    Setter method for ipv4_labeled_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv4_labeled_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_labeled_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_labeled_unicast() directly.

    YANG Description: IPv4 Labeled Unicast configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_labeled_unicast, is_container='container', yang_name="ipv4-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_labeled_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_labeled_unicast, is_container='container', yang_name="ipv4-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ipv4_labeled_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_labeled_unicast(self):
    self.__ipv4_labeled_unicast = YANGDynClass(base=yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_labeled_unicast, is_container='container', yang_name="ipv4-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ipv6_labeled_unicast(self):
    """
    Getter method for ipv6_labeled_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_labeled_unicast (container)

    YANG Description: IPv6 Labeled Unicast configuration options
    """
    return self.__ipv6_labeled_unicast
      
  def _set_ipv6_labeled_unicast(self, v, load=False):
    """
    Setter method for ipv6_labeled_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/ipv6_labeled_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_labeled_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_labeled_unicast() directly.

    YANG Description: IPv6 Labeled Unicast configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_labeled_unicast, is_container='container', yang_name="ipv6-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_labeled_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_labeled_unicast, is_container='container', yang_name="ipv6-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ipv6_labeled_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_labeled_unicast(self):
    self.__ipv6_labeled_unicast = YANGDynClass(base=yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_labeled_unicast, is_container='container', yang_name="ipv6-labeled-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l3vpn_ipv4_unicast(self):
    """
    Getter method for l3vpn_ipv4_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_unicast (container)

    YANG Description: Unicast IPv4 L3VPN configuration options
    """
    return self.__l3vpn_ipv4_unicast
      
  def _set_l3vpn_ipv4_unicast(self, v, load=False):
    """
    Setter method for l3vpn_ipv4_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3vpn_ipv4_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3vpn_ipv4_unicast() directly.

    YANG Description: Unicast IPv4 L3VPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_unicast, is_container='container', yang_name="l3vpn-ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3vpn_ipv4_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_unicast, is_container='container', yang_name="l3vpn-ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l3vpn_ipv4_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3vpn_ipv4_unicast(self):
    self.__l3vpn_ipv4_unicast = YANGDynClass(base=yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_unicast, is_container='container', yang_name="l3vpn-ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l3vpn_ipv6_unicast(self):
    """
    Getter method for l3vpn_ipv6_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_unicast (container)

    YANG Description: Unicast IPv6 L3VPN configuration options
    """
    return self.__l3vpn_ipv6_unicast
      
  def _set_l3vpn_ipv6_unicast(self, v, load=False):
    """
    Setter method for l3vpn_ipv6_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3vpn_ipv6_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3vpn_ipv6_unicast() directly.

    YANG Description: Unicast IPv6 L3VPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_unicast, is_container='container', yang_name="l3vpn-ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3vpn_ipv6_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_unicast, is_container='container', yang_name="l3vpn-ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l3vpn_ipv6_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3vpn_ipv6_unicast(self):
    self.__l3vpn_ipv6_unicast = YANGDynClass(base=yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_unicast, is_container='container', yang_name="l3vpn-ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l3vpn_ipv4_multicast(self):
    """
    Getter method for l3vpn_ipv4_multicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_multicast (container)

    YANG Description: Multicast IPv4 L3VPN configuration options
    """
    return self.__l3vpn_ipv4_multicast
      
  def _set_l3vpn_ipv4_multicast(self, v, load=False):
    """
    Setter method for l3vpn_ipv4_multicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv4_multicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3vpn_ipv4_multicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3vpn_ipv4_multicast() directly.

    YANG Description: Multicast IPv4 L3VPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_multicast, is_container='container', yang_name="l3vpn-ipv4-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3vpn_ipv4_multicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_multicast, is_container='container', yang_name="l3vpn-ipv4-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l3vpn_ipv4_multicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3vpn_ipv4_multicast(self):
    self.__l3vpn_ipv4_multicast = YANGDynClass(base=yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_multicast, is_container='container', yang_name="l3vpn-ipv4-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l3vpn_ipv6_multicast(self):
    """
    Getter method for l3vpn_ipv6_multicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_multicast (container)

    YANG Description: Multicast IPv6 L3VPN configuration options
    """
    return self.__l3vpn_ipv6_multicast
      
  def _set_l3vpn_ipv6_multicast(self, v, load=False):
    """
    Setter method for l3vpn_ipv6_multicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l3vpn_ipv6_multicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3vpn_ipv6_multicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3vpn_ipv6_multicast() directly.

    YANG Description: Multicast IPv6 L3VPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_multicast, is_container='container', yang_name="l3vpn-ipv6-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l3vpn_ipv6_multicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_multicast, is_container='container', yang_name="l3vpn-ipv6-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l3vpn_ipv6_multicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l3vpn_ipv6_multicast(self):
    self.__l3vpn_ipv6_multicast = YANGDynClass(base=yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_multicast, is_container='container', yang_name="l3vpn-ipv6-multicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l2vpn_vpls(self):
    """
    Getter method for l2vpn_vpls, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_vpls (container)

    YANG Description: BGP-signalled VPLS configuration options
    """
    return self.__l2vpn_vpls
      
  def _set_l2vpn_vpls(self, v, load=False):
    """
    Setter method for l2vpn_vpls, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_vpls (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2vpn_vpls is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2vpn_vpls() directly.

    YANG Description: BGP-signalled VPLS configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_vpls, is_container='container', yang_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2vpn_vpls must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_vpls, is_container='container', yang_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l2vpn_vpls = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2vpn_vpls(self):
    self.__l2vpn_vpls = YANGDynClass(base=yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_vpls, is_container='container', yang_name="l2vpn-vpls", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_l2vpn_evpn(self):
    """
    Getter method for l2vpn_evpn, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_evpn (container)

    YANG Description: BGP EVPN configuration options
    """
    return self.__l2vpn_evpn
      
  def _set_l2vpn_evpn(self, v, load=False):
    """
    Setter method for l2vpn_evpn, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi/l2vpn_evpn (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2vpn_evpn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2vpn_evpn() directly.

    YANG Description: BGP EVPN configuration options
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_evpn, is_container='container', yang_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2vpn_evpn must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_evpn, is_container='container', yang_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__l2vpn_evpn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2vpn_evpn(self):
    self.__l2vpn_evpn = YANGDynClass(base=yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_evpn, is_container='container', yang_name="l2vpn-evpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  afi_safi_name = __builtin__.property(_get_afi_safi_name, _set_afi_safi_name)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart) # type: yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_graceful_restart
  route_selection_options = __builtin__.property(_get_route_selection_options, _set_route_selection_options) # type: yc_route_selection_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_route_selection_options
  use_multiple_paths = __builtin__.property(_get_use_multiple_paths, _set_use_multiple_paths) # type: yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_use_multiple_paths
  apply_policy = __builtin__.property(_get_apply_policy, _set_apply_policy) # type: yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_apply_policy
  ipv4_unicast = __builtin__.property(_get_ipv4_unicast, _set_ipv4_unicast) # type: yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_unicast
  ipv6_unicast = __builtin__.property(_get_ipv6_unicast, _set_ipv6_unicast) # type: yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_unicast
  ipv4_labeled_unicast = __builtin__.property(_get_ipv4_labeled_unicast, _set_ipv4_labeled_unicast) # type: yc_ipv4_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv4_labeled_unicast
  ipv6_labeled_unicast = __builtin__.property(_get_ipv6_labeled_unicast, _set_ipv6_labeled_unicast) # type: yc_ipv6_labeled_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_ipv6_labeled_unicast
  l3vpn_ipv4_unicast = __builtin__.property(_get_l3vpn_ipv4_unicast, _set_l3vpn_ipv4_unicast) # type: yc_l3vpn_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_unicast
  l3vpn_ipv6_unicast = __builtin__.property(_get_l3vpn_ipv6_unicast, _set_l3vpn_ipv6_unicast) # type: yc_l3vpn_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_unicast
  l3vpn_ipv4_multicast = __builtin__.property(_get_l3vpn_ipv4_multicast, _set_l3vpn_ipv4_multicast) # type: yc_l3vpn_ipv4_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv4_multicast
  l3vpn_ipv6_multicast = __builtin__.property(_get_l3vpn_ipv6_multicast, _set_l3vpn_ipv6_multicast) # type: yc_l3vpn_ipv6_multicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l3vpn_ipv6_multicast
  l2vpn_vpls = __builtin__.property(_get_l2vpn_vpls, _set_l2vpn_vpls) # type: yc_l2vpn_vpls_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_vpls
  l2vpn_evpn = __builtin__.property(_get_l2vpn_evpn, _set_l2vpn_evpn) # type: yc_l2vpn_evpn_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi_l2vpn_evpn


  _pyangbind_elements = OrderedDict([('afi_safi_name', afi_safi_name), ('enabled', enabled), ('graceful_restart', graceful_restart), ('route_selection_options', route_selection_options), ('use_multiple_paths', use_multiple_paths), ('apply_policy', apply_policy), ('ipv4_unicast', ipv4_unicast), ('ipv6_unicast', ipv6_unicast), ('ipv4_labeled_unicast', ipv4_labeled_unicast), ('ipv6_labeled_unicast', ipv6_labeled_unicast), ('l3vpn_ipv4_unicast', l3vpn_ipv4_unicast), ('l3vpn_ipv6_unicast', l3vpn_ipv6_unicast), ('l3vpn_ipv4_multicast', l3vpn_ipv4_multicast), ('l3vpn_ipv6_multicast', l3vpn_ipv6_multicast), ('l2vpn_vpls', l2vpn_vpls), ('l2vpn_evpn', l2vpn_evpn), ])


class yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group/afi-safis. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-address-family configuration parameters associated with
the group.
  """
  __slots__ = ('_path_helper', '_extmethods', '__afi_safi',)

  _yang_name = 'afi-safis'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afi_safi = YANGDynClass(base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group', 'afi-safis']

  def _get_afi_safi(self):
    """
    Getter method for afi_safi, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi (list)

    YANG Description: AFI, SAFI configuration available for the
neighbour or group
    """
    return self.__afi_safi
      
  def _set_afi_safi(self, v, load=False):
    """
    Setter method for afi_safi, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis/afi_safi (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safi() directly.

    YANG Description: AFI, SAFI configuration available for the
neighbour or group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safi must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)""",
        })

    self.__afi_safi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safi(self):
    self.__afi_safi = YANGDynClass(base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)

  afi_safi = __builtin__.property(_get_afi_safi, _set_afi_safi) # type: yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis_afi_safi


  _pyangbind_elements = OrderedDict([('afi_safi', afi_safi), ])


class yc_peer_group_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups/peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of BGP peer-groups configured on the local system -
uniquely identified by peer-group name
  """
  __slots__ = ('_path_helper', '_extmethods', '__peer_group_name','__remote_as','__peer_as','__local_as','__remove_private_as','__route_flap_damping','__send_community','__description','__timers','__transport','__graceful_restart','__ebgp_multihop','__route_reflector','__as_path_options','__add_paths','__use_multiple_paths','__apply_policy','__afi_safis',)

  _yang_name = 'peer-group'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peer_group_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peer-group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)
    self.__remote_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    self.__peer_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    self.__local_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    self.__remove_private_as = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="remove-private-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:remove-private-as-option', is_config=True)
    self.__route_flap_damping = YANGDynClass(base=yc_route_flap_damping_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_route_flap_damping, is_container='container', yang_name="route-flap-damping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__send_community = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="send-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:community-type', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)
    self.__timers = YANGDynClass(base=yc_timers_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__transport = YANGDynClass(base=yc_transport_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__graceful_restart = YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__ebgp_multihop = YANGDynClass(base=yc_ebgp_multihop_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__route_reflector = YANGDynClass(base=yc_route_reflector_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__as_path_options = YANGDynClass(base=yc_as_path_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__add_paths = YANGDynClass(base=yc_add_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_add_paths, is_container='container', yang_name="add-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__use_multiple_paths = YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__apply_policy = YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__afi_safis = YANGDynClass(base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups', 'peer-group']

  def _get_peer_group_name(self):
    """
    Getter method for peer_group_name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/peer_group_name (string)

    YANG Description: Name of the BGP peer-group
    """
    return self.__peer_group_name
      
  def _set_peer_group_name(self, v, load=False):
    """
    Setter method for peer_group_name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/peer_group_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_group_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_group_name() directly.

    YANG Description: Name of the BGP peer-group
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="peer-group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_group_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peer-group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)""",
        })

    self.__peer_group_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_group_name(self):
    self.__peer_group_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="peer-group-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)


  def _get_remote_as(self):
    """
    Getter method for remote_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/remote_as (inet:as-number)

    YANG Description: The remote autonomous system number received in
the BGP OPEN message.
    """
    return self.__remote_as
      
  def _set_remote_as(self, v, load=False):
    """
    Setter method for remote_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/remote_as (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_as() directly.

    YANG Description: The remote autonomous system number received in
the BGP OPEN message.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_as must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)""",
        })

    self.__remote_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_as(self):
    self.__remote_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="remote-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)


  def _get_peer_as(self):
    """
    Getter method for peer_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/peer_as (inet:as-number)

    YANG Description: AS number of the peer.
    """
    return self.__peer_as
      
  def _set_peer_as(self, v, load=False):
    """
    Setter method for peer_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/peer_as (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_as() directly.

    YANG Description: AS number of the peer.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_as must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)""",
        })

    self.__peer_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_as(self):
    self.__peer_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="peer-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)


  def _get_local_as(self):
    """
    Getter method for local_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/local_as (inet:as-number)

    YANG Description: The local autonomous system number that is to be used when
establishing sessions with the remote peer or peer group, if
this differs from the global BGP router autonomous system
number.
    """
    return self.__local_as
      
  def _set_local_as(self, v, load=False):
    """
    Setter method for local_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/local_as (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_as() directly.

    YANG Description: The local autonomous system number that is to be used when
establishing sessions with the remote peer or peer group, if
this differs from the global BGP router autonomous system
number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_as must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)""",
        })

    self.__local_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_as(self):
    self.__local_as = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=True)


  def _get_remove_private_as(self):
    """
    Getter method for remove_private_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/remove_private_as (bt:remove-private-as-option)

    YANG Description: Remove private AS numbers from updates sent to peers - when
this leaf is not specified, the AS_PATH attribute should be
sent to the peer unchanged
    """
    return self.__remove_private_as
      
  def _set_remove_private_as(self, v, load=False):
    """
    Setter method for remove_private_as, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/remove_private_as (bt:remove-private-as-option)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remove_private_as is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remove_private_as() directly.

    YANG Description: Remove private AS numbers from updates sent to peers - when
this leaf is not specified, the AS_PATH attribute should be
sent to the peer unchanged
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="remove-private-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:remove-private-as-option', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remove_private_as must be of a type compatible with bt:remove-private-as-option""",
          'defined-type': "bt:remove-private-as-option",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="remove-private-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:remove-private-as-option', is_config=True)""",
        })

    self.__remove_private_as = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remove_private_as(self):
    self.__remove_private_as = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REMOVE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:PRIVATE_AS_REPLACE_ALL': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="remove-private-as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:remove-private-as-option', is_config=True)


  def _get_route_flap_damping(self):
    """
    Getter method for route_flap_damping, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping (container)

    YANG Description: Routes learned via BGP are subject to weighted route
dampening.
    """
    return self.__route_flap_damping
      
  def _set_route_flap_damping(self, v, load=False):
    """
    Setter method for route_flap_damping, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_flap_damping (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_flap_damping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_flap_damping() directly.

    YANG Description: Routes learned via BGP are subject to weighted route
dampening.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_route_flap_damping_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_route_flap_damping, is_container='container', yang_name="route-flap-damping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_flap_damping must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_route_flap_damping_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_route_flap_damping, is_container='container', yang_name="route-flap-damping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_flap_damping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_flap_damping(self):
    self.__route_flap_damping = YANGDynClass(base=yc_route_flap_damping_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_route_flap_damping, is_container='container', yang_name="route-flap-damping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_send_community(self):
    """
    Getter method for send_community, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/send_community (bt:community-type)

    YANG Description: When supported, this tells the router to propogate any
prefixes that are attached to this community. The value
of 0 implies 'none'.
    """
    return self.__send_community
      
  def _set_send_community(self, v, load=False):
    """
    Setter method for send_community, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/send_community (bt:community-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_community() directly.

    YANG Description: When supported, this tells the router to propogate any
prefixes that are attached to this community. The value
of 0 implies 'none'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="send-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:community-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_community must be of a type compatible with bt:community-type""",
          'defined-type': "bt:community-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="send-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:community-type', is_config=True)""",
        })

    self.__send_community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_community(self):
    self.__send_community = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="send-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:community-type', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/description (string)

    YANG Description: An optional textual description (intended primarily for use
with a peer or group
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: An optional textual description (intended primarily for use
with a peer or group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='string', is_config=True)


  def _get_timers(self):
    """
    Getter method for timers, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/timers (container)

    YANG Description: Timers related to a BGP peer-group.
    """
    return self.__timers
      
  def _set_timers(self, v, load=False):
    """
    Setter method for timers, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/timers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_timers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_timers() directly.

    YANG Description: Timers related to a BGP peer-group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_timers_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """timers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_timers_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__timers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_timers(self):
    self.__timers = YANGDynClass(base=yc_timers_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_timers, is_container='container', yang_name="timers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_transport(self):
    """
    Getter method for transport, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/transport (container)

    YANG Description: Transport session parameters for the BGP peer-group.
    """
    return self.__transport
      
  def _set_transport(self, v, load=False):
    """
    Setter method for transport, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/transport (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transport() directly.

    YANG Description: Transport session parameters for the BGP peer-group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_transport_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transport must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_transport_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__transport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transport(self):
    self.__transport = YANGDynClass(base=yc_transport_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_transport, is_container='container', yang_name="transport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_graceful_restart(self):
    """
    Getter method for graceful_restart, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/graceful_restart (container)

    YANG Description: Parameters relating the graceful restart mechanism for BGP.
    """
    return self.__graceful_restart
      
  def _set_graceful_restart(self, v, load=False):
    """
    Setter method for graceful_restart, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/graceful_restart (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_graceful_restart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_graceful_restart() directly.

    YANG Description: Parameters relating the graceful restart mechanism for BGP.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """graceful_restart must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__graceful_restart = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_graceful_restart(self):
    self.__graceful_restart = YANGDynClass(base=yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_graceful_restart, is_container='container', yang_name="graceful-restart", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_ebgp_multihop(self):
    """
    Getter method for ebgp_multihop, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/ebgp_multihop (container)

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    return self.__ebgp_multihop
      
  def _set_ebgp_multihop(self, v, load=False):
    """
    Setter method for ebgp_multihop, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/ebgp_multihop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ebgp_multihop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ebgp_multihop() directly.

    YANG Description: eBGP multi-hop parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ebgp_multihop_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ebgp_multihop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ebgp_multihop_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__ebgp_multihop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ebgp_multihop(self):
    self.__ebgp_multihop = YANGDynClass(base=yc_ebgp_multihop_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_ebgp_multihop, is_container='container', yang_name="ebgp-multihop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_route_reflector(self):
    """
    Getter method for route_reflector, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_reflector (container)

    YANG Description: Route reflector parameters for the BGPgroup
    """
    return self.__route_reflector
      
  def _set_route_reflector(self, v, load=False):
    """
    Setter method for route_reflector, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/route_reflector (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_reflector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_reflector() directly.

    YANG Description: Route reflector parameters for the BGPgroup
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_route_reflector_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_reflector must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_route_reflector_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__route_reflector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_reflector(self):
    self.__route_reflector = YANGDynClass(base=yc_route_reflector_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_route_reflector, is_container='container', yang_name="route-reflector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_as_path_options(self):
    """
    Getter method for as_path_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/as_path_options (container)

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    return self.__as_path_options
      
  def _set_as_path_options(self, v, load=False):
    """
    Setter method for as_path_options, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/as_path_options (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_path_options is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_path_options() directly.

    YANG Description: AS_PATH manipulation parameters for the BGP neighbor or
group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_as_path_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_path_options must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_as_path_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__as_path_options = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_path_options(self):
    self.__as_path_options = YANGDynClass(base=yc_as_path_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_as_path_options, is_container='container', yang_name="as-path-options", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_add_paths(self):
    """
    Getter method for add_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/add_paths (container)

    YANG Description: Parameters relating to the advertisement and receipt of
multiple paths for a single NLRI (add-paths)
    """
    return self.__add_paths
      
  def _set_add_paths(self, v, load=False):
    """
    Setter method for add_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/add_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_add_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_add_paths() directly.

    YANG Description: Parameters relating to the advertisement and receipt of
multiple paths for a single NLRI (add-paths)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_add_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_add_paths, is_container='container', yang_name="add-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """add_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_add_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_add_paths, is_container='container', yang_name="add-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__add_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_add_paths(self):
    self.__add_paths = YANGDynClass(base=yc_add_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_add_paths, is_container='container', yang_name="add-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_use_multiple_paths(self):
    """
    Getter method for use_multiple_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/use_multiple_paths (container)

    YANG Description: Parameters related to the use of multiple paths for the
same NLRI
    """
    return self.__use_multiple_paths
      
  def _set_use_multiple_paths(self, v, load=False):
    """
    Setter method for use_multiple_paths, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/use_multiple_paths (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_multiple_paths is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_multiple_paths() directly.

    YANG Description: Parameters related to the use of multiple paths for the
same NLRI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_multiple_paths must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__use_multiple_paths = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_multiple_paths(self):
    self.__use_multiple_paths = YANGDynClass(base=yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths, is_container='container', yang_name="use-multiple-paths", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_apply_policy(self):
    """
    Getter method for apply_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/apply_policy (container)

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    return self.__apply_policy
      
  def _set_apply_policy(self, v, load=False):
    """
    Setter method for apply_policy, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/apply_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_apply_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_apply_policy() directly.

    YANG Description: Anchor point for routing policies in the model.
Import and export policies are with respect to the local
routing table, i.e., export (send) and import (receive),
depending on the context.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """apply_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__apply_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_apply_policy(self):
    self.__apply_policy = YANGDynClass(base=yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_apply_policy, is_container='container', yang_name="apply-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_afi_safis(self):
    """
    Getter method for afi_safis, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis (container)

    YANG Description: Per-address-family configuration parameters associated with
the group.
    """
    return self.__afi_safis
      
  def _set_afi_safis(self, v, load=False):
    """
    Setter method for afi_safis, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group/afi_safis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safis() directly.

    YANG Description: Per-address-family configuration parameters associated with
the group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__afi_safis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safis(self):
    self.__afi_safis = YANGDynClass(base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  peer_group_name = __builtin__.property(_get_peer_group_name, _set_peer_group_name)
  remote_as = __builtin__.property(_get_remote_as, _set_remote_as)
  peer_as = __builtin__.property(_get_peer_as, _set_peer_as)
  local_as = __builtin__.property(_get_local_as, _set_local_as)
  remove_private_as = __builtin__.property(_get_remove_private_as, _set_remove_private_as)
  route_flap_damping = __builtin__.property(_get_route_flap_damping, _set_route_flap_damping) # type: yc_route_flap_damping_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_route_flap_damping
  send_community = __builtin__.property(_get_send_community, _set_send_community)
  description = __builtin__.property(_get_description, _set_description)
  timers = __builtin__.property(_get_timers, _set_timers) # type: yc_timers_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_timers
  transport = __builtin__.property(_get_transport, _set_transport) # type: yc_transport_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_transport
  graceful_restart = __builtin__.property(_get_graceful_restart, _set_graceful_restart) # type: yc_graceful_restart_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_graceful_restart
  ebgp_multihop = __builtin__.property(_get_ebgp_multihop, _set_ebgp_multihop) # type: yc_ebgp_multihop_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_ebgp_multihop
  route_reflector = __builtin__.property(_get_route_reflector, _set_route_reflector) # type: yc_route_reflector_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_route_reflector
  as_path_options = __builtin__.property(_get_as_path_options, _set_as_path_options) # type: yc_as_path_options_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_as_path_options
  add_paths = __builtin__.property(_get_add_paths, _set_add_paths) # type: yc_add_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_add_paths
  use_multiple_paths = __builtin__.property(_get_use_multiple_paths, _set_use_multiple_paths) # type: yc_use_multiple_paths_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_use_multiple_paths
  apply_policy = __builtin__.property(_get_apply_policy, _set_apply_policy) # type: yc_apply_policy_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_apply_policy
  afi_safis = __builtin__.property(_get_afi_safis, _set_afi_safis) # type: yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group_afi_safis


  _pyangbind_elements = OrderedDict([('peer_group_name', peer_group_name), ('remote_as', remote_as), ('peer_as', peer_as), ('local_as', local_as), ('remove_private_as', remove_private_as), ('route_flap_damping', route_flap_damping), ('send_community', send_community), ('description', description), ('timers', timers), ('transport', transport), ('graceful_restart', graceful_restart), ('ebgp_multihop', ebgp_multihop), ('route_reflector', route_reflector), ('as_path_options', as_path_options), ('add_paths', add_paths), ('use_multiple_paths', use_multiple_paths), ('apply_policy', apply_policy), ('afi_safis', afi_safis), ])


class yc_peer_groups_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/peer-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for BGP peer-groups
  """
  __slots__ = ('_path_helper', '_extmethods', '__peer_group',)

  _yang_name = 'peer-groups'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__peer_group = YANGDynClass(base=YANGListType("peer_group_name",yc_peer_group_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group, yang_name="peer-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-group-name', extensions=None), is_container='list', yang_name="peer-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'peer-groups']

  def _get_peer_group(self):
    """
    Getter method for peer_group, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group (list)

    YANG Description: List of BGP peer-groups configured on the local system -
uniquely identified by peer-group name
    """
    return self.__peer_group
      
  def _set_peer_group(self, v, load=False):
    """
    Setter method for peer_group, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups/peer_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_group() directly.

    YANG Description: List of BGP peer-groups configured on the local system -
uniquely identified by peer-group name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("peer_group_name",yc_peer_group_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group, yang_name="peer-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-group-name', extensions=None), is_container='list', yang_name="peer-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_group must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("peer_group_name",yc_peer_group_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group, yang_name="peer-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-group-name', extensions=None), is_container='list', yang_name="peer-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)""",
        })

    self.__peer_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_group(self):
    self.__peer_group = YANGDynClass(base=YANGListType("peer_group_name",yc_peer_group_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group, yang_name="peer-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='peer-group-name', extensions=None), is_container='list', yang_name="peer-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)

  peer_group = __builtin__.property(_get_peer_group, _set_peer_group) # type: yc_peer_group_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups_peer_group


  _pyangbind_elements = OrderedDict([('peer_group', peer_group), ])


class yc_bfd_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces_interface_bfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/interfaces/interface/bfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BFD client configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__local_multiplier','__desired_min_tx_interval','__required_min_rx_interval','__min_interval',)

  _yang_name = 'bfd'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    self.__local_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(3), is_leaf=True, yang_name="local-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='multiplier', is_config=True)
    self.__desired_min_tx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000000), is_leaf=True, yang_name="desired-min-tx-interval", parent=self, choice=('interval-config-type', 'tx-rx-intervals'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__required_min_rx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000000), is_leaf=True, yang_name="required-min-rx-interval", parent=self, choice=('interval-config-type', 'tx-rx-intervals'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    self.__min_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000000), is_leaf=True, yang_name="min-interval", parent=self, choice=('interval-config-type', 'single-interval'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'interfaces', 'interface', 'bfd']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface/bfd/enable (boolean)

    YANG Description: Indicates whether the BFD is enabled.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface/bfd/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: Indicates whether the BFD is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=True)


  def _get_local_multiplier(self):
    """
    Getter method for local_multiplier, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface/bfd/local_multiplier (multiplier)

    YANG Description: Multiplier transmitted by local system.
    """
    return self.__local_multiplier
      
  def _set_local_multiplier(self, v, load=False):
    """
    Setter method for local_multiplier, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface/bfd/local_multiplier (multiplier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_multiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_multiplier() directly.

    YANG Description: Multiplier transmitted by local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(3), is_leaf=True, yang_name="local-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='multiplier', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_multiplier must be of a type compatible with multiplier""",
          'defined-type': "ietf-bgp:multiplier",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(3), is_leaf=True, yang_name="local-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='multiplier', is_config=True)""",
        })

    self.__local_multiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_multiplier(self):
    self.__local_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..255']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(3), is_leaf=True, yang_name="local-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='multiplier', is_config=True)


  def _get_desired_min_tx_interval(self):
    """
    Getter method for desired_min_tx_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface/bfd/desired_min_tx_interval (uint32)

    YANG Description: Desired minimum transmit interval of control packets.
    """
    return self.__desired_min_tx_interval
      
  def _set_desired_min_tx_interval(self, v, load=False):
    """
    Setter method for desired_min_tx_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface/bfd/desired_min_tx_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_desired_min_tx_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_desired_min_tx_interval() directly.

    YANG Description: Desired minimum transmit interval of control packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000000), is_leaf=True, yang_name="desired-min-tx-interval", parent=self, choice=('interval-config-type', 'tx-rx-intervals'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """desired_min_tx_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000000), is_leaf=True, yang_name="desired-min-tx-interval", parent=self, choice=('interval-config-type', 'tx-rx-intervals'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__desired_min_tx_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_desired_min_tx_interval(self):
    self.__desired_min_tx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000000), is_leaf=True, yang_name="desired-min-tx-interval", parent=self, choice=('interval-config-type', 'tx-rx-intervals'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_required_min_rx_interval(self):
    """
    Getter method for required_min_rx_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface/bfd/required_min_rx_interval (uint32)

    YANG Description: Required minimum receive interval of control packets.
    """
    return self.__required_min_rx_interval
      
  def _set_required_min_rx_interval(self, v, load=False):
    """
    Setter method for required_min_rx_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface/bfd/required_min_rx_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_required_min_rx_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_required_min_rx_interval() directly.

    YANG Description: Required minimum receive interval of control packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000000), is_leaf=True, yang_name="required-min-rx-interval", parent=self, choice=('interval-config-type', 'tx-rx-intervals'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """required_min_rx_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000000), is_leaf=True, yang_name="required-min-rx-interval", parent=self, choice=('interval-config-type', 'tx-rx-intervals'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__required_min_rx_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_required_min_rx_interval(self):
    self.__required_min_rx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000000), is_leaf=True, yang_name="required-min-rx-interval", parent=self, choice=('interval-config-type', 'tx-rx-intervals'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)


  def _get_min_interval(self):
    """
    Getter method for min_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface/bfd/min_interval (uint32)

    YANG Description: Desired minimum transmit interval and required minimum receive interval of control packets.
    """
    return self.__min_interval
      
  def _set_min_interval(self, v, load=False):
    """
    Setter method for min_interval, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface/bfd/min_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_interval() directly.

    YANG Description: Desired minimum transmit interval and required minimum receive interval of control packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000000), is_leaf=True, yang_name="min-interval", parent=self, choice=('interval-config-type', 'single-interval'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000000), is_leaf=True, yang_name="min-interval", parent=self, choice=('interval-config-type', 'single-interval'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)""",
        })

    self.__min_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_interval(self):
    self.__min_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1000000), is_leaf=True, yang_name="min-interval", parent=self, choice=('interval-config-type', 'single-interval'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=True)

  enable = __builtin__.property(_get_enable, _set_enable)
  local_multiplier = __builtin__.property(_get_local_multiplier, _set_local_multiplier)
  desired_min_tx_interval = __builtin__.property(_get_desired_min_tx_interval, _set_desired_min_tx_interval)
  required_min_rx_interval = __builtin__.property(_get_required_min_rx_interval, _set_required_min_rx_interval)
  min_interval = __builtin__.property(_get_min_interval, _set_min_interval)

  __choices__ = {'interval-config-type': {'tx-rx-intervals': ['desired_min_tx_interval', 'required_min_rx_interval'], 'single-interval': ['min_interval']}}
  _pyangbind_elements = OrderedDict([('enable', enable), ('local_multiplier', local_multiplier), ('desired_min_tx_interval', desired_min_tx_interval), ('required_min_rx_interval', required_min_rx_interval), ('min_interval', min_interval), ])


class yc_interface_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/interfaces/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of interfaces within the routing instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__bfd',)

  _yang_name = 'interface'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='if:interface-ref', is_config=True)
    self.__bfd = YANGDynClass(base=yc_bfd_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces_interface_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'interfaces', 'interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface/name (if:interface-ref)

    YANG Description: Reference to the interface within the routing instance.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface/name (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the interface within the routing instance.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='if:interface-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='if:interface-ref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='if:interface-ref', is_config=True)


  def _get_bfd(self):
    """
    Getter method for bfd, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface/bfd (container)

    YANG Description: BFD client configuration.
    """
    return self.__bfd
      
  def _set_bfd(self, v, load=False):
    """
    Setter method for bfd, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface/bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfd() directly.

    YANG Description: BFD client configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bfd_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces_interface_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bfd_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces_interface_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfd(self):
    self.__bfd = YANGDynClass(base=yc_bfd_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces_interface_bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  bfd = __builtin__.property(_get_bfd, _set_bfd) # type: yc_bfd_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces_interface_bfd


  _pyangbind_elements = OrderedDict([('name', name), ('bfd', bfd), ])


class yc_interfaces_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface specific parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface (list)

    YANG Description: List of interfaces within the routing instance.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: List of interfaces within the routing instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interface_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interface_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface) # type: yc_interface_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces_interface


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_aggregator_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_aggregator(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/attr-sets/attr-set/attr-set-attributes/aggregator. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: BGP attribute indicating the prefix has been
aggregated by the specified AS and router.
  """
  __slots__ = ('_path_helper', '_extmethods', '__as_','__as4','__address',)

  _yang_name = 'aggregator'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__as_ = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)
    self.__as4 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-address', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'attr-sets', 'attr-set', 'attr-set-attributes', 'aggregator']

  def _get_as_(self):
    """
    Getter method for as_, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/aggregator/as (inet:as-number)

    YANG Description: AS number of the autonomous system that performed the
aggregation.
    """
    return self.__as_
      
  def _set_as_(self, v, load=False):
    """
    Setter method for as_, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/aggregator/as (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_() directly.

    YANG Description: AS number of the autonomous system that performed the
aggregation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_ must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)""",
        })

    self.__as_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_(self):
    self.__as_ = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)


  def _get_as4(self):
    """
    Getter method for as4, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/aggregator/as4 (inet:as-number)

    YANG Description: AS number of the autonomous system that performed the
aggregation (4-octet representation).  This value is
populated if an upstream router is not 4-octet capable.
Its semantics are similar to the AS4_PATH optional
transitive attribute
    """
    return self.__as4
      
  def _set_as4(self, v, load=False):
    """
    Setter method for as4, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/aggregator/as4 (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as4() directly.

    YANG Description: AS number of the autonomous system that performed the
aggregation (4-octet representation).  This value is
populated if an upstream router is not 4-octet capable.
Its semantics are similar to the AS4_PATH optional
transitive attribute
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as4 must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)""",
        })

    self.__as4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as4(self):
    self.__as4 = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="as4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)


  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/aggregator/address (inet:ipv4-address)

    YANG Description: IP address of the router that performed the
  aggregation.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/aggregator/address (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: IP address of the router that performed the
  aggregation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-address', is_config=False)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-address', is_config=False)

  as_ = __builtin__.property(_get_as_)
  as4 = __builtin__.property(_get_as4)
  address = __builtin__.property(_get_address)


  _pyangbind_elements = OrderedDict([('as_', as_), ('as4', as4), ('address', address), ])


class yc_segment_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as_path_segment(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/attr-sets/attr-set/attr-set-attributes/as-path/segment. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of AS PATH segments
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__type','__member',)

  _yang_name = 'segment'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    self.__member = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'attr-sets', 'attr-set', 'attr-set-attributes', 'as-path', 'segment']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as_path/segment/index (uint16)

    YANG Description: An index into the AS segments.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as_path/segment/index (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: An index into the AS segments.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as_path/segment/type (identityref)

    YANG Description: The type of AS-PATH segment
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as_path/segment/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of AS-PATH segment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)


  def _get_member(self):
    """
    Getter method for member, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as_path/segment/member (inet:as-number)

    YANG Description: List of the AS numbers in the AS-PATH segment
    """
    return self.__member
      
  def _set_member(self, v, load=False):
    """
    Setter method for member, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as_path/segment/member (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member() directly.

    YANG Description: List of the AS numbers in the AS-PATH segment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)""",
        })

    self.__member = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member(self):
    self.__member = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)

  index = __builtin__.property(_get_index)
  type = __builtin__.property(_get_type)
  member = __builtin__.property(_get_member)


  _pyangbind_elements = OrderedDict([('index', index), ('type', type), ('member', member), ])


class yc_as_path_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as_path(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/attr-sets/attr-set/attr-set-attributes/as-path. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of AS path segments.

In the Adj-RIB-In or Adj-RIB-Out, this list should show
the received or sent AS_PATH, respectively.  For
example, if the local router is not 4-byte capable, this
value should consist of 2-octet ASNs or the AS_TRANS
(AS 23456) values received or sent in route updates.

In the Loc-RIB, this list should reflect the effective
AS path for the route, e.g., a 4-octet value if the
local router is 4-octet capable.
  """
  __slots__ = ('_path_helper', '_extmethods', '__segment',)

  _yang_name = 'as-path'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__segment = YANGDynClass(base=YANGListType("index",yc_segment_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as_path_segment, yang_name="segment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'attr-sets', 'attr-set', 'attr-set-attributes', 'as-path']

  def _get_segment(self):
    """
    Getter method for segment, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as_path/segment (list)

    YANG Description: List of AS PATH segments
    """
    return self.__segment
      
  def _set_segment(self, v, load=False):
    """
    Setter method for segment, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as_path/segment (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_segment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_segment() directly.

    YANG Description: List of AS PATH segments
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_segment_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as_path_segment, yang_name="segment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """segment must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_segment_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as_path_segment, yang_name="segment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__segment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_segment(self):
    self.__segment = YANGDynClass(base=YANGListType("index",yc_segment_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as_path_segment, yang_name="segment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  segment = __builtin__.property(_get_segment) # type: yc_segment_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as_path_segment


  _pyangbind_elements = OrderedDict([('segment', segment), ])


class yc_segment_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as4_path_segment(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/attr-sets/attr-set/attr-set-attributes/as4-path/segment. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of AS PATH segments
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__type','__member',)

  _yang_name = 'segment'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    self.__member = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'attr-sets', 'attr-set', 'attr-set-attributes', 'as4-path', 'segment']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as4_path/segment/index (uint16)

    YANG Description: An index into the AS segments.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as4_path/segment/index (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: An index into the AS segments.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as4_path/segment/type (identityref)

    YANG Description: The type of AS-PATH segment
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as4_path/segment/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: The type of AS-PATH segment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-sequence': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:as-confed-set': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)


  def _get_member(self):
    """
    Getter method for member, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as4_path/segment/member (inet:as-number)

    YANG Description: List of the AS numbers in the AS-PATH segment
    """
    return self.__member
      
  def _set_member(self, v, load=False):
    """
    Setter method for member, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as4_path/segment/member (inet:as-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_member is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_member() directly.

    YANG Description: List of the AS numbers in the AS-PATH segment
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """member must be of a type compatible with inet:as-number""",
          'defined-type': "inet:as-number",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)""",
        })

    self.__member = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_member(self):
    self.__member = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="member", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:as-number', is_config=False)

  index = __builtin__.property(_get_index)
  type = __builtin__.property(_get_type)
  member = __builtin__.property(_get_member)


  _pyangbind_elements = OrderedDict([('index', index), ('type', type), ('member', member), ])


class yc_as4_path_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as4_path(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/attr-sets/attr-set/attr-set-attributes/as4-path. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This is the path encoded with 4-octet
AS numbers in the optional transitive AS4_PATH attribute.
This value is populated with the received or sent
attribute in Adj-RIB-In or Adj-RIB-Out, respectively.
It should not be populated in Loc-RIB since the Loc-RIB
is expected to store the effective AS-Path in the
as-path leaf regardless of being 4-octet or 2-octet.
  """
  __slots__ = ('_path_helper', '_extmethods', '__segment',)

  _yang_name = 'as4-path'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__segment = YANGDynClass(base=YANGListType("index",yc_segment_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as4_path_segment, yang_name="segment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'attr-sets', 'attr-set', 'attr-set-attributes', 'as4-path']

  def _get_segment(self):
    """
    Getter method for segment, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as4_path/segment (list)

    YANG Description: List of AS PATH segments
    """
    return self.__segment
      
  def _set_segment(self, v, load=False):
    """
    Setter method for segment, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as4_path/segment (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_segment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_segment() directly.

    YANG Description: List of AS PATH segments
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_segment_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as4_path_segment, yang_name="segment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """segment must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_segment_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as4_path_segment, yang_name="segment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__segment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_segment(self):
    self.__segment = YANGDynClass(base=YANGListType("index",yc_segment_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as4_path_segment, yang_name="segment", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  segment = __builtin__.property(_get_segment) # type: yc_segment_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as4_path_segment


  _pyangbind_elements = OrderedDict([('segment', segment), ])


class yc_attr_set_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/attr-sets/attr-set/attr-set-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A container for attribute set parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__origin','__atomic_aggregate','__next_hop','__med','__local_pref','__originator_id','__cluster_list','__aigp_metric','__aggregator','__as_path','__as4_path',)

  _yang_name = 'attr-set-attributes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'igp': {}, 'egp': {}, 'incomplete': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:bgp-origin-attr-type', is_config=False)
    self.__atomic_aggregate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="atomic-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__next_hop = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)
    self.__med = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__local_pref = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-pref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__originator_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="originator-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=False)
    self.__cluster_list = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'})), is_leaf=False, yang_name="cluster-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=False)
    self.__aigp_metric = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="aigp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    self.__aggregator = YANGDynClass(base=yc_aggregator_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_aggregator, is_container='container', yang_name="aggregator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__as_path = YANGDynClass(base=yc_as_path_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as_path, is_container='container', yang_name="as-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__as4_path = YANGDynClass(base=yc_as4_path_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as4_path, is_container='container', yang_name="as4-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'attr-sets', 'attr-set', 'attr-set-attributes']

  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/origin (bt:bgp-origin-attr-type)

    YANG Description: BGP attribute defining the origin of the path
information.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/origin (bt:bgp-origin-attr-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: BGP attribute defining the origin of the path
information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'igp': {}, 'egp': {}, 'incomplete': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:bgp-origin-attr-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with bt:bgp-origin-attr-type""",
          'defined-type': "bt:bgp-origin-attr-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'igp': {}, 'egp': {}, 'incomplete': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:bgp-origin-attr-type', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'igp': {}, 'egp': {}, 'incomplete': {}},), is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='bt:bgp-origin-attr-type', is_config=False)


  def _get_atomic_aggregate(self):
    """
    Getter method for atomic_aggregate, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/atomic_aggregate (boolean)

    YANG Description: BGP attribute indicating that the prefix is an atomic
aggregate; i.e., the peer selected a less specific
route without selecting a more specific route that is
included in it.
    """
    return self.__atomic_aggregate
      
  def _set_atomic_aggregate(self, v, load=False):
    """
    Setter method for atomic_aggregate, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/atomic_aggregate (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_atomic_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_atomic_aggregate() directly.

    YANG Description: BGP attribute indicating that the prefix is an atomic
aggregate; i.e., the peer selected a less specific
route without selecting a more specific route that is
included in it.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="atomic-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """atomic_aggregate must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="atomic-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__atomic_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_atomic_aggregate(self):
    self.__atomic_aggregate = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="atomic-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/next_hop (inet:ip-address)

    YANG Description: BGP next hop attribute defining the IP address of the
router that should be used as the next hop to the
destination
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/next_hop (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: BGP next hop attribute defining the IP address of the
router that should be used as the next hop to the
destination
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)


  def _get_med(self):
    """
    Getter method for med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/med (uint32)

    YANG Description: BGP multi-exit discriminator attribute used in BGP route
selection process
    """
    return self.__med
      
  def _set_med(self, v, load=False):
    """
    Setter method for med, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/med (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_med is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_med() directly.

    YANG Description: BGP multi-exit discriminator attribute used in BGP route
selection process
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """med must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__med = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_med(self):
    self.__med = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="med", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_local_pref(self):
    """
    Getter method for local_pref, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/local_pref (uint32)

    YANG Description: BGP local preference attribute sent to internal peers to
indicate the degree of preference for externally learned
routes.  The route with the highest local preference
value is preferred.
    """
    return self.__local_pref
      
  def _set_local_pref(self, v, load=False):
    """
    Setter method for local_pref, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/local_pref (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_pref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_pref() directly.

    YANG Description: BGP local preference attribute sent to internal peers to
indicate the degree of preference for externally learned
routes.  The route with the highest local preference
value is preferred.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-pref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_pref must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-pref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__local_pref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_pref(self):
    self.__local_pref = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="local-pref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_originator_id(self):
    """
    Getter method for originator_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/originator_id (yang:dotted-quad)

    YANG Description: BGP attribute that provides the id as an IPv4 address
of the originator of the announcement.
    """
    return self.__originator_id
      
  def _set_originator_id(self, v, load=False):
    """
    Setter method for originator_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/originator_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_originator_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_originator_id() directly.

    YANG Description: BGP attribute that provides the id as an IPv4 address
of the originator of the announcement.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="originator-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """originator_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="originator-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=False)""",
        })

    self.__originator_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_originator_id(self):
    self.__originator_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="originator-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=False)


  def _get_cluster_list(self):
    """
    Getter method for cluster_list, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/cluster_list (yang:dotted-quad)

    YANG Description: Represents the reflection path that the route has
passed.
    """
    return self.__cluster_list
      
  def _set_cluster_list(self, v, load=False):
    """
    Setter method for cluster_list, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/cluster_list (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cluster_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cluster_list() directly.

    YANG Description: Represents the reflection path that the route has
passed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'})), is_leaf=False, yang_name="cluster-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cluster_list must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'})), is_leaf=False, yang_name="cluster-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=False)""",
        })

    self.__cluster_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cluster_list(self):
    self.__cluster_list = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'})), is_leaf=False, yang_name="cluster-list", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:dotted-quad', is_config=False)


  def _get_aigp_metric(self):
    """
    Getter method for aigp_metric, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/aigp_metric (uint64)

    YANG Description: BGP path attribute representing the accumulated IGP
metric for the path
    """
    return self.__aigp_metric
      
  def _set_aigp_metric(self, v, load=False):
    """
    Setter method for aigp_metric, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/aigp_metric (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aigp_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aigp_metric() directly.

    YANG Description: BGP path attribute representing the accumulated IGP
metric for the path
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="aigp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aigp_metric must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="aigp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__aigp_metric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aigp_metric(self):
    self.__aigp_metric = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="aigp-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)


  def _get_aggregator(self):
    """
    Getter method for aggregator, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/aggregator (container)

    YANG Description: BGP attribute indicating the prefix has been
aggregated by the specified AS and router.
    """
    return self.__aggregator
      
  def _set_aggregator(self, v, load=False):
    """
    Setter method for aggregator, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/aggregator (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregator() directly.

    YANG Description: BGP attribute indicating the prefix has been
aggregated by the specified AS and router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_aggregator_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_aggregator, is_container='container', yang_name="aggregator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregator must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_aggregator_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_aggregator, is_container='container', yang_name="aggregator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__aggregator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregator(self):
    self.__aggregator = YANGDynClass(base=yc_aggregator_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_aggregator, is_container='container', yang_name="aggregator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_as_path(self):
    """
    Getter method for as_path, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as_path (container)

    YANG Description: Enclosing container for the list of AS path segments.

In the Adj-RIB-In or Adj-RIB-Out, this list should show
the received or sent AS_PATH, respectively.  For
example, if the local router is not 4-byte capable, this
value should consist of 2-octet ASNs or the AS_TRANS
(AS 23456) values received or sent in route updates.

In the Loc-RIB, this list should reflect the effective
AS path for the route, e.g., a 4-octet value if the
local router is 4-octet capable.
    """
    return self.__as_path
      
  def _set_as_path(self, v, load=False):
    """
    Setter method for as_path, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as_path (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_path() directly.

    YANG Description: Enclosing container for the list of AS path segments.

In the Adj-RIB-In or Adj-RIB-Out, this list should show
the received or sent AS_PATH, respectively.  For
example, if the local router is not 4-byte capable, this
value should consist of 2-octet ASNs or the AS_TRANS
(AS 23456) values received or sent in route updates.

In the Loc-RIB, this list should reflect the effective
AS path for the route, e.g., a 4-octet value if the
local router is 4-octet capable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_as_path_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as_path, is_container='container', yang_name="as-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_path must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_as_path_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as_path, is_container='container', yang_name="as-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__as_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_path(self):
    self.__as_path = YANGDynClass(base=yc_as_path_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as_path, is_container='container', yang_name="as-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_as4_path(self):
    """
    Getter method for as4_path, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as4_path (container)

    YANG Description: This is the path encoded with 4-octet
AS numbers in the optional transitive AS4_PATH attribute.
This value is populated with the received or sent
attribute in Adj-RIB-In or Adj-RIB-Out, respectively.
It should not be populated in Loc-RIB since the Loc-RIB
is expected to store the effective AS-Path in the
as-path leaf regardless of being 4-octet or 2-octet.
    """
    return self.__as4_path
      
  def _set_as4_path(self, v, load=False):
    """
    Setter method for as4_path, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes/as4_path (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as4_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as4_path() directly.

    YANG Description: This is the path encoded with 4-octet
AS numbers in the optional transitive AS4_PATH attribute.
This value is populated with the received or sent
attribute in Adj-RIB-In or Adj-RIB-Out, respectively.
It should not be populated in Loc-RIB since the Loc-RIB
is expected to store the effective AS-Path in the
as-path leaf regardless of being 4-octet or 2-octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_as4_path_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as4_path, is_container='container', yang_name="as4-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as4_path must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_as4_path_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as4_path, is_container='container', yang_name="as4-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__as4_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as4_path(self):
    self.__as4_path = YANGDynClass(base=yc_as4_path_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as4_path, is_container='container', yang_name="as4-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  origin = __builtin__.property(_get_origin)
  atomic_aggregate = __builtin__.property(_get_atomic_aggregate)
  next_hop = __builtin__.property(_get_next_hop)
  med = __builtin__.property(_get_med)
  local_pref = __builtin__.property(_get_local_pref)
  originator_id = __builtin__.property(_get_originator_id)
  cluster_list = __builtin__.property(_get_cluster_list)
  aigp_metric = __builtin__.property(_get_aigp_metric)
  aggregator = __builtin__.property(_get_aggregator) # type: yc_aggregator_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_aggregator
  as_path = __builtin__.property(_get_as_path) # type: yc_as_path_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as_path
  as4_path = __builtin__.property(_get_as4_path) # type: yc_as4_path_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes_as4_path


  _pyangbind_elements = OrderedDict([('origin', origin), ('atomic_aggregate', atomic_aggregate), ('next_hop', next_hop), ('med', med), ('local_pref', local_pref), ('originator_id', originator_id), ('cluster_list', cluster_list), ('aigp_metric', aigp_metric), ('aggregator', aggregator), ('as_path', as_path), ('as4_path', as4_path), ])


class yc_attr_set_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/attr-sets/attr-set. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of path attributes that may be in use by multiple
routes in the table
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__attr_set_attributes',)

  _yang_name = 'attr-set'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    self.__attr_set_attributes = YANGDynClass(base=yc_attr_set_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes, is_container='container', yang_name="attr-set-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'attr-sets', 'attr-set']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/index (uint64)

    YANG Description: System generated index for each attribute set.  The
index is used to reference an attribute set from a
specific path.  Multiple paths may reference the same
attribute set.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/index (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: System generated index for each attribute set.  The
index is used to reference an attribute set from a
specific path.  Multiple paths may reference the same
attribute set.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)


  def _get_attr_set_attributes(self):
    """
    Getter method for attr_set_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes (container)

    YANG Description: A container for attribute set parameters.
    """
    return self.__attr_set_attributes
      
  def _set_attr_set_attributes(self, v, load=False):
    """
    Setter method for attr_set_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set/attr_set_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_set_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_set_attributes() directly.

    YANG Description: A container for attribute set parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_attr_set_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes, is_container='container', yang_name="attr-set-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_set_attributes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_attr_set_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes, is_container='container', yang_name="attr-set-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__attr_set_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_set_attributes(self):
    self.__attr_set_attributes = YANGDynClass(base=yc_attr_set_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes, is_container='container', yang_name="attr-set-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  index = __builtin__.property(_get_index)
  attr_set_attributes = __builtin__.property(_get_attr_set_attributes) # type: yc_attr_set_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set_attr_set_attributes


  _pyangbind_elements = OrderedDict([('index', index), ('attr_set_attributes', attr_set_attributes), ])


class yc_attr_sets_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/attr-sets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of path attribute sets
  """
  __slots__ = ('_path_helper', '_extmethods', '__attr_set',)

  _yang_name = 'attr-sets'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__attr_set = YANGDynClass(base=YANGListType("index",yc_attr_set_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set, yang_name="attr-set", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="attr-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'attr-sets']

  def _get_attr_set(self):
    """
    Getter method for attr_set, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set (list)

    YANG Description: List of path attributes that may be in use by multiple
routes in the table
    """
    return self.__attr_set
      
  def _set_attr_set(self, v, load=False):
    """
    Setter method for attr_set, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets/attr_set (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_set is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_set() directly.

    YANG Description: List of path attributes that may be in use by multiple
routes in the table
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_attr_set_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set, yang_name="attr-set", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="attr-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_set must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_attr_set_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set, yang_name="attr-set", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="attr-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__attr_set = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_set(self):
    self.__attr_set = YANGDynClass(base=YANGListType("index",yc_attr_set_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set, yang_name="attr-set", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="attr-set", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  attr_set = __builtin__.property(_get_attr_set) # type: yc_attr_set_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets_attr_set


  _pyangbind_elements = OrderedDict([('attr_set', attr_set), ])


class yc_community_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_communities_community(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/communities/community. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of path attributes that may be in use by multiple
routes in the table
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__community',)

  _yang_name = 'community'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    self.__community = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'no-export': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-export': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-export': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'no-advertise': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-advertise': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-advertise': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'no-export-subconfed': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-export-subconfed': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-export-subconfed': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'no-peer': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-peer': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-peer': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},),RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['65536..4294901759']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]+:[0-9]+)'}),]), is_leaf=False, yang_name="community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'communities', 'community']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/communities/community/index (uint64)

    YANG Description: System generated index for each attribute set.  The
index is used to reference an attribute set from a
specific path.  Multiple paths may reference the same
attribute set.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/communities/community/index (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: System generated index for each attribute set.  The
index is used to reference an attribute set from a
specific path.  Multiple paths may reference the same
attribute set.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)


  def _get_community(self):
    """
    Getter method for community, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/communities/community/community (union)

    YANG Description: List of standard or well-known BGP community
attributes.
    """
    return self.__community
      
  def _set_community(self, v, load=False):
    """
    Setter method for community, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/communities/community/community (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_community() directly.

    YANG Description: List of standard or well-known BGP community
attributes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'no-export': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-export': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-export': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'no-advertise': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-advertise': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-advertise': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'no-export-subconfed': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-export-subconfed': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-export-subconfed': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'no-peer': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-peer': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-peer': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},),RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['65536..4294901759']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]+:[0-9]+)'}),]), is_leaf=False, yang_name="community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """community must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'no-export': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-export': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-export': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'no-advertise': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-advertise': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-advertise': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'no-export-subconfed': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-export-subconfed': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-export-subconfed': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'no-peer': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-peer': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-peer': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},),RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['65536..4294901759']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]+:[0-9]+)'}),]), is_leaf=False, yang_name="community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)""",
        })

    self.__community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_community(self):
    self.__community = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'no-export': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-export': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-export': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'no-advertise': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-advertise': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-advertise': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'no-export-subconfed': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-export-subconfed': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-export-subconfed': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'no-peer': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:no-peer': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:no-peer': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},),RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['65536..4294901759']}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([0-9]+:[0-9]+)'}),]), is_leaf=False, yang_name="community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

  index = __builtin__.property(_get_index)
  community = __builtin__.property(_get_community)


  _pyangbind_elements = OrderedDict([('index', index), ('community', community), ])


class yc_communities_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_communities(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/communities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of community attribute
sets
  """
  __slots__ = ('_path_helper', '_extmethods', '__community',)

  _yang_name = 'communities'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__community = YANGDynClass(base=YANGListType("index",yc_community_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_communities_community, yang_name="community", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'communities']

  def _get_community(self):
    """
    Getter method for community, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/communities/community (list)

    YANG Description: List of path attributes that may be in use by multiple
routes in the table
    """
    return self.__community
      
  def _set_community(self, v, load=False):
    """
    Setter method for community, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/communities/community (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_community() directly.

    YANG Description: List of path attributes that may be in use by multiple
routes in the table
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_community_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_communities_community, yang_name="community", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """community must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_community_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_communities_community, yang_name="community", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_community(self):
    self.__community = YANGDynClass(base=YANGListType("index",yc_community_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_communities_community, yang_name="community", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  community = __builtin__.property(_get_community) # type: yc_community_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_communities_community


  _pyangbind_elements = OrderedDict([('community', community), ])


class yc_ext_community_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_ext_communities_ext_community(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/ext-communities/ext-community. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of path attributes that may be in use by multiple
routes in the table
  """
  __slots__ = ('_path_helper', '_extmethods', '__index','__ext_community',)

  _yang_name = 'ext-community'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    self.__ext_community = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'})), is_leaf=False, yang_name="ext-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='rt:route-target', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'ext-communities', 'ext-community']

  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/ext_communities/ext_community/index (uint64)

    YANG Description: System generated index for each attribute set.  The
index is used to reference an attribute set from a
specific path.  Multiple paths may reference the same
attribute set.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/ext_communities/ext_community/index (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: System generated index for each attribute set.  The
index is used to reference an attribute set from a
specific path.  Multiple paths may reference the same
attribute set.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint64', is_config=False)


  def _get_ext_community(self):
    """
    Getter method for ext_community, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/ext_communities/ext_community/ext_community (rt:route-target)

    YANG Description: List of BGP extended community attributes. The received
extended community may be an explicitly modeled
type or unknown, represented by an 8-octet value
formatted according to RFC 4360.
    """
    return self.__ext_community
      
  def _set_ext_community(self, v, load=False):
    """
    Setter method for ext_community, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/ext_communities/ext_community/ext_community (rt:route-target)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_community() directly.

    YANG Description: List of BGP extended community attributes. The received
extended community may be an explicitly modeled
type or unknown, represented by an 8-octet value
formatted according to RFC 4360.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'})), is_leaf=False, yang_name="ext-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='rt:route-target', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_community must be of a type compatible with rt:route-target""",
          'defined-type': "rt:route-target",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'})), is_leaf=False, yang_name="ext-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='rt:route-target', is_config=False)""",
        })

    self.__ext_community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_community(self):
    self.__ext_community = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(0:(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0):(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0))|(1:((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(2:(429496729[0-5]|42949672[0-8][0-9]|4294967[01][0-9]{2}|429496[0-6][0-9]{3}|42949[0-5][0-9]{4}|4294[0-8][0-9]{5}|429[0-3][0-9]{6}|42[0-8][0-9]{7}|4[01][0-9]{8}|[1-3][0-9]{9}|[1-9][0-9]{0,8}|0):(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[1-9][0-9]{0,3}|0))|(6(:[a-fA-F0-9]{2}){6})|(([3-57-9a-fA-F]|[1-9a-fA-F][0-9a-fA-F]{1,3}):[0-9a-fA-F]{1,12})'})), is_leaf=False, yang_name="ext-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='rt:route-target', is_config=False)

  index = __builtin__.property(_get_index)
  ext_community = __builtin__.property(_get_ext_community)


  _pyangbind_elements = OrderedDict([('index', index), ('ext_community', ext_community), ])


class yc_ext_communities_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_ext_communities(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/ext-communities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the list of extended community
attribute sets
  """
  __slots__ = ('_path_helper', '_extmethods', '__ext_community',)

  _yang_name = 'ext-communities'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ext_community = YANGDynClass(base=YANGListType("index",yc_ext_community_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_ext_communities_ext_community, yang_name="ext-community", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="ext-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'ext-communities']

  def _get_ext_community(self):
    """
    Getter method for ext_community, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/ext_communities/ext_community (list)

    YANG Description: List of path attributes that may be in use by multiple
routes in the table
    """
    return self.__ext_community
      
  def _set_ext_community(self, v, load=False):
    """
    Setter method for ext_community, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/ext_communities/ext_community (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_community is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_community() directly.

    YANG Description: List of path attributes that may be in use by multiple
routes in the table
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("index",yc_ext_community_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_ext_communities_ext_community, yang_name="ext-community", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="ext-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_community must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("index",yc_ext_community_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_ext_communities_ext_community, yang_name="ext-community", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="ext-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__ext_community = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_community(self):
    self.__ext_community = YANGDynClass(base=YANGListType("index",yc_ext_community_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_ext_communities_ext_community, yang_name="ext-community", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='index', extensions=None), is_container='list', yang_name="ext-community", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  ext_community = __builtin__.property(_get_ext_community) # type: yc_ext_community_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_ext_communities_ext_community


  _pyangbind_elements = OrderedDict([('ext_community', ext_community), ])


class yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route_unknown_attributes_unknown_attribute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/loc-rib/routes/route/unknown-attributes/unknown-attribute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optional','__transitive','__partial','__extended','__attr_type','__attr_len','__attr_value',)

  _yang_name = 'unknown-attribute'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'loc-rib', 'routes', 'route', 'unknown-attributes', 'unknown-attribute']

  def _get_optional(self):
    """
    Getter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/optional (boolean)

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    return self.__optional
      
  def _set_optional(self, v, load=False):
    """
    Setter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/optional (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optional() directly.

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optional must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__optional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optional(self):
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_transitive(self):
    """
    Getter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    return self.__transitive
      
  def _set_transitive(self, v, load=False):
    """
    Setter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transitive() directly.

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transitive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__transitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transitive(self):
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_partial(self):
    """
    Getter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/partial (boolean)

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    return self.__partial
      
  def _set_partial(self, v, load=False):
    """
    Setter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/partial (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partial is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partial() directly.

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partial must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__partial = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partial(self):
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_extended(self):
    """
    Getter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/extended (boolean)

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    return self.__extended
      
  def _set_extended(self, v, load=False):
    """
    Setter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/extended (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended() directly.

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__extended = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended(self):
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_attr_type(self):
    """
    Getter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)

    YANG Description: 1-octet value encoding the attribute type code
    """
    return self.__attr_type
      
  def _set_attr_type(self, v, load=False):
    """
    Setter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_type() directly.

    YANG Description: 1-octet value encoding the attribute type code
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__attr_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_type(self):
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)


  def _get_attr_len(self):
    """
    Getter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    return self.__attr_len
      
  def _set_attr_len(self, v, load=False):
    """
    Setter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_len is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_len() directly.

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_len must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)""",
        })

    self.__attr_len = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_len(self):
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)


  def _get_attr_value(self):
    """
    Getter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    return self.__attr_value
      
  def _set_attr_value(self, v, load=False):
    """
    Setter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_value() directly.

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_value must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)""",
        })

    self.__attr_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_value(self):
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

  optional = __builtin__.property(_get_optional)
  transitive = __builtin__.property(_get_transitive)
  partial = __builtin__.property(_get_partial)
  extended = __builtin__.property(_get_extended)
  attr_type = __builtin__.property(_get_attr_type)
  attr_len = __builtin__.property(_get_attr_len)
  attr_value = __builtin__.property(_get_attr_value)


  _pyangbind_elements = OrderedDict([('optional', optional), ('transitive', transitive), ('partial', partial), ('extended', extended), ('attr_type', attr_type), ('attr_len', attr_len), ('attr_value', attr_value), ])


class yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route_unknown_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/loc-rib/routes/route/unknown-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__unknown_attribute',)

  _yang_name = 'unknown-attributes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'loc-rib', 'routes', 'route', 'unknown-attributes']

  def _get_unknown_attribute(self):
    """
    Getter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute (list)

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    return self.__unknown_attribute
      
  def _set_unknown_attribute(self, v, load=False):
    """
    Setter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attribute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attribute() directly.

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attribute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__unknown_attribute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attribute(self):
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  unknown_attribute = __builtin__.property(_get_unknown_attribute) # type: yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route_unknown_attributes_unknown_attribute


  _pyangbind_elements = OrderedDict([('unknown_attribute', unknown_attribute), ])


class yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/loc-rib/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of routes in the table, keyed by the route
prefix, the route origin, and path-id.  The route
origin can be either the neighbor address from which
the route was learned, or the source protocol that
injected the route.  The path-id distinguishes routes
for the same prefix received from a neighbor (e.g.,
if add-paths is enabled).
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__origin','__path_id','__attr_index','__community_index','__ext_community_index','__last_modified','__valid_route','__invalid_reason','__unknown_attributes','__reject_reason',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)
    self.__origin = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'loc-rib', 'routes', 'route']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/prefix (inet:ipv4-prefix)

    YANG Description: The IPv4 prefix corresponding to the route
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/prefix (inet:ipv4-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: The IPv4 prefix corresponding to the route
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv4-prefix""",
          'defined-type': "inet:ipv4-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/origin (union)

    YANG Description: Indicates the origin of the route.  If the route is learned
from a neighbor, this value is the neighbor address.  If
the route was injected or redistributed from another
protocol, the origin indicates the source protocol for the
route.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/origin (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: Indicates the origin of the route.  If the route is learned
from a neighbor, this value is the neighbor address.  If
the route was injected or redistributed from another
protocol, the origin indicates the source protocol for the
route.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)


  def _get_path_id(self):
    """
    Getter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/path_id (uint32)

    YANG Description: If the route is learned from a neighbor, the path-id
corresponds to the path-id for the route in the
corresponding adj-rib-in-post table.  If the route is
injected from another protocol, or the neighbor does not
support BGP add-paths, the path-id should be set
to zero, also the default value.

However, YANG does not allow default values to be set
for parameters that form the key, so a default value
cannot be set here.
    """
    return self.__path_id
      
  def _set_path_id(self, v, load=False):
    """
    Setter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/path_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_id() directly.

    YANG Description: If the route is learned from a neighbor, the path-id
corresponds to the path-id for the route in the
corresponding adj-rib-in-post table.  If the route is
injected from another protocol, or the neighbor does not
support BGP add-paths, the path-id should be set
to zero, also the default value.

However, YANG does not allow default values to be set
for parameters that form the key, so a default value
cannot be set here.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__path_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_id(self):
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_attr_index(self):
    """
    Getter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/attr_index (leafref)

    YANG Description: Reference to the common attribute group for the
route
    """
    return self.__attr_index
      
  def _set_attr_index(self, v, load=False):
    """
    Setter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/attr_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_index() directly.

    YANG Description: Reference to the common attribute group for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__attr_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_index(self):
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_community_index(self):
    """
    Getter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/community_index (leafref)

    YANG Description: Reference to the community attribute for the route
    """
    return self.__community_index
      
  def _set_community_index(self, v, load=False):
    """
    Setter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_community_index() directly.

    YANG Description: Reference to the community attribute for the route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_community_index(self):
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_ext_community_index(self):
    """
    Getter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/ext_community_index (leafref)

    YANG Description: Reference to the extended community attribute for the
route
    """
    return self.__ext_community_index
      
  def _set_ext_community_index(self, v, load=False):
    """
    Setter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/ext_community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_community_index() directly.

    YANG Description: Reference to the extended community attribute for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__ext_community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_community_index(self):
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_last_modified(self):
    """
    Getter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/last_modified (types:timeticks)

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_modified
      
  def _set_last_modified(self, v, load=False):
    """
    Setter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/last_modified (types:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_modified is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_modified() directly.

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_modified must be of a type compatible with types:timeticks""",
          'defined-type': "types:timeticks",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)""",
        })

    self.__last_modified = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_modified(self):
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)


  def _get_valid_route(self):
    """
    Getter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/valid_route (boolean)

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    return self.__valid_route
      
  def _set_valid_route(self, v, load=False):
    """
    Setter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/valid_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_route() directly.

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__valid_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_route(self):
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_invalid_reason(self):
    """
    Getter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/invalid_reason (identityref)

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    return self.__invalid_reason
      
  def _set_invalid_reason(self, v, load=False):
    """
    Setter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/invalid_reason (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invalid_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invalid_reason() directly.

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invalid_reason must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)""",
        })

    self.__invalid_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invalid_reason(self):
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)


  def _get_unknown_attributes(self):
    """
    Getter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes (container)

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    return self.__unknown_attributes
      
  def _set_unknown_attributes(self, v, load=False):
    """
    Setter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/unknown_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attributes() directly.

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attributes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__unknown_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attributes(self):
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_reject_reason(self):
    """
    Getter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/reject_reason (union)

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    return self.__reject_reason
      
  def _set_reject_reason(self, v, load=False):
    """
    Setter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route/reject_reason (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reject_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reject_reason() directly.

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reject_reason must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)""",
        })

    self.__reject_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reject_reason(self):
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  origin = __builtin__.property(_get_origin)
  path_id = __builtin__.property(_get_path_id)
  attr_index = __builtin__.property(_get_attr_index)
  community_index = __builtin__.property(_get_community_index)
  ext_community_index = __builtin__.property(_get_ext_community_index)
  last_modified = __builtin__.property(_get_last_modified)
  valid_route = __builtin__.property(_get_valid_route)
  invalid_reason = __builtin__.property(_get_invalid_reason)
  unknown_attributes = __builtin__.property(_get_unknown_attributes) # type: yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route_unknown_attributes
  reject_reason = __builtin__.property(_get_reject_reason)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('origin', origin), ('path_id', path_id), ('attr_index', attr_index), ('community_index', community_index), ('ext_community_index', ext_community_index), ('last_modified', last_modified), ('valid_route', valid_route), ('invalid_reason', invalid_reason), ('unknown_attributes', unknown_attributes), ('reject_reason', reject_reason), ])


class yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/loc-rib/routes/clear-routes/clear/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_at',)

  _yang_name = 'input'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'loc-rib', 'routes', 'clear-routes', 'clear', 'input']

  def _get_clear_at(self):
    """
    Getter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/clear_routes/clear/input/clear_at (yang:date-and-time)

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    return self.__clear_at
      
  def _set_clear_at(self, v, load=False):
    """
    Setter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/clear_routes/clear/input/clear_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_at() directly.

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_at(self):
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_at = __builtin__.property(_get_clear_at)


  _pyangbind_elements = OrderedDict([('clear_at', clear_at), ])


class yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/loc-rib/routes/clear-routes/clear/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_finished_at',)

  _yang_name = 'output'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'loc-rib', 'routes', 'clear-routes', 'clear', 'output']

  def _get_clear_finished_at(self):
    """
    Getter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)

    YANG Description: The time when the clear operation finished.
    """
    return self.__clear_finished_at
      
  def _set_clear_finished_at(self, v, load=False):
    """
    Setter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_finished_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_finished_at() directly.

    YANG Description: The time when the clear operation finished.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_finished_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_finished_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_finished_at(self):
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_finished_at = __builtin__.property(_get_clear_finished_at)


  _pyangbind_elements = OrderedDict([('clear_finished_at', clear_finished_at), ])


class yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/loc-rib/routes/clear-routes/clear. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__output',)

  _yang_name = 'clear'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'loc-rib', 'routes', 'clear-routes', 'clear']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/clear_routes/clear/input (input)
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/clear_routes/clear/input (input)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with input""",
          'defined-type': "ietf-bgp:input",
          'generated-type': """YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)


  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/clear_routes/clear/output (output)
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/clear_routes/clear/output (output)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with output""",
          'defined-type': "ietf-bgp:output",
          'generated-type': """YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

  input = __builtin__.property(_get_input)
  output = __builtin__.property(_get_output)


  _pyangbind_elements = OrderedDict([('input', input), ('output', output), ])


class yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/loc-rib/routes/clear-routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Action commands to clear routes governed by a if-feature.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear',)

  _yang_name = 'clear-routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'loc-rib', 'routes', 'clear-routes']

  def _get_clear(self):
    """
    Getter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/clear_routes/clear (action)
    """
    return self.__clear
      
  def _set_clear(self, v, load=False):
    """
    Setter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/clear_routes/clear (action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear must be of a type compatible with action""",
          'defined-type': "ietf-bgp:action",
          'generated-type': """YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)""",
        })

    self.__clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear(self):
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

  clear = __builtin__.property(_get_clear)


  _pyangbind_elements = OrderedDict([('clear', clear), ])


class yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/loc-rib/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of routes in the routing
table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route','__clear_routes',)

  _yang_name = 'routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType("prefix origin path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix origin path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'loc-rib', 'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route (list)

    YANG Description: List of routes in the table, keyed by the route
prefix, the route origin, and path-id.  The route
origin can be either the neighbor address from which
the route was learned, or the source protocol that
injected the route.  The path-id distinguishes routes
for the same prefix received from a neighbor (e.g.,
if add-paths is enabled).
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: List of routes in the table, keyed by the route
prefix, the route origin, and path-id.  The route
origin can be either the neighbor address from which
the route was learned, or the source protocol that
injected the route.  The path-id distinguishes routes
for the same prefix received from a neighbor (e.g.,
if add-paths is enabled).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix origin path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix origin path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix origin path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix origin path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType("prefix origin path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix origin path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)


  def _get_clear_routes(self):
    """
    Getter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/clear_routes (container)

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    return self.__clear_routes
      
  def _set_clear_routes(self, v, load=False):
    """
    Setter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes/clear_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_routes() directly.

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__clear_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_routes(self):
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_route
  clear_routes = __builtin__.property(_get_clear_routes) # type: yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes_clear_routes


  _pyangbind_elements = OrderedDict([('route', route), ('clear_routes', clear_routes), ])


class yc_loc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/loc-rib. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the IPv4 BGP LOC-RIB data
  """
  __slots__ = ('_path_helper', '_extmethods', '__routes',)

  _yang_name = 'loc-rib'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'loc-rib']

  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes (container)

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  routes = __builtin__.property(_get_routes) # type: yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib_routes


  _pyangbind_elements = OrderedDict([('routes', routes), ])


class yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes_unknown_attribute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-in-pre/routes/route/unknown-attributes/unknown-attribute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optional','__transitive','__partial','__extended','__attr_type','__attr_len','__attr_value',)

  _yang_name = 'unknown-attribute'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes', 'route', 'unknown-attributes', 'unknown-attribute']

  def _get_optional(self):
    """
    Getter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/optional (boolean)

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    return self.__optional
      
  def _set_optional(self, v, load=False):
    """
    Setter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/optional (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optional() directly.

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optional must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__optional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optional(self):
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_transitive(self):
    """
    Getter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    return self.__transitive
      
  def _set_transitive(self, v, load=False):
    """
    Setter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transitive() directly.

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transitive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__transitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transitive(self):
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_partial(self):
    """
    Getter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/partial (boolean)

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    return self.__partial
      
  def _set_partial(self, v, load=False):
    """
    Setter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/partial (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partial is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partial() directly.

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partial must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__partial = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partial(self):
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_extended(self):
    """
    Getter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/extended (boolean)

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    return self.__extended
      
  def _set_extended(self, v, load=False):
    """
    Setter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/extended (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended() directly.

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__extended = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended(self):
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_attr_type(self):
    """
    Getter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)

    YANG Description: 1-octet value encoding the attribute type code
    """
    return self.__attr_type
      
  def _set_attr_type(self, v, load=False):
    """
    Setter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_type() directly.

    YANG Description: 1-octet value encoding the attribute type code
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__attr_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_type(self):
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)


  def _get_attr_len(self):
    """
    Getter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    return self.__attr_len
      
  def _set_attr_len(self, v, load=False):
    """
    Setter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_len is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_len() directly.

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_len must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)""",
        })

    self.__attr_len = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_len(self):
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)


  def _get_attr_value(self):
    """
    Getter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    return self.__attr_value
      
  def _set_attr_value(self, v, load=False):
    """
    Setter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_value() directly.

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_value must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)""",
        })

    self.__attr_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_value(self):
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

  optional = __builtin__.property(_get_optional)
  transitive = __builtin__.property(_get_transitive)
  partial = __builtin__.property(_get_partial)
  extended = __builtin__.property(_get_extended)
  attr_type = __builtin__.property(_get_attr_type)
  attr_len = __builtin__.property(_get_attr_len)
  attr_value = __builtin__.property(_get_attr_value)


  _pyangbind_elements = OrderedDict([('optional', optional), ('transitive', transitive), ('partial', partial), ('extended', extended), ('attr_type', attr_type), ('attr_len', attr_len), ('attr_value', attr_value), ])


class yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-in-pre/routes/route/unknown-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__unknown_attribute',)

  _yang_name = 'unknown-attributes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes', 'route', 'unknown-attributes']

  def _get_unknown_attribute(self):
    """
    Getter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute (list)

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    return self.__unknown_attribute
      
  def _set_unknown_attribute(self, v, load=False):
    """
    Setter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attribute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attribute() directly.

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attribute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__unknown_attribute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attribute(self):
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  unknown_attribute = __builtin__.property(_get_unknown_attribute) # type: yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes_unknown_attribute


  _pyangbind_elements = OrderedDict([('unknown_attribute', unknown_attribute), ])


class yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-in-pre/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of routes in the table, keyed by a combination of
the route prefix and path-id to distinguish multiple
routes received from a neighbor for the same prefix,
e.g., when BGP add-paths is enabled.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__path_id','__attr_index','__community_index','__ext_community_index','__last_modified','__valid_route','__invalid_reason','__unknown_attributes','__reject_reason',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes', 'route']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/prefix (inet:ipv4-prefix)

    YANG Description: Prefix for the route
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/prefix (inet:ipv4-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Prefix for the route
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv4-prefix""",
          'defined-type': "inet:ipv4-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)


  def _get_path_id(self):
    """
    Getter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/path_id (uint32)

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    return self.__path_id
      
  def _set_path_id(self, v, load=False):
    """
    Setter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/path_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_id() directly.

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__path_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_id(self):
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_attr_index(self):
    """
    Getter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/attr_index (leafref)

    YANG Description: Reference to the common attribute group for the
route
    """
    return self.__attr_index
      
  def _set_attr_index(self, v, load=False):
    """
    Setter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/attr_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_index() directly.

    YANG Description: Reference to the common attribute group for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__attr_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_index(self):
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_community_index(self):
    """
    Getter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/community_index (leafref)

    YANG Description: Reference to the community attribute for the route
    """
    return self.__community_index
      
  def _set_community_index(self, v, load=False):
    """
    Setter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_community_index() directly.

    YANG Description: Reference to the community attribute for the route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_community_index(self):
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_ext_community_index(self):
    """
    Getter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/ext_community_index (leafref)

    YANG Description: Reference to the extended community attribute for the
route
    """
    return self.__ext_community_index
      
  def _set_ext_community_index(self, v, load=False):
    """
    Setter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/ext_community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_community_index() directly.

    YANG Description: Reference to the extended community attribute for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__ext_community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_community_index(self):
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_last_modified(self):
    """
    Getter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/last_modified (types:timeticks)

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_modified
      
  def _set_last_modified(self, v, load=False):
    """
    Setter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/last_modified (types:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_modified is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_modified() directly.

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_modified must be of a type compatible with types:timeticks""",
          'defined-type': "types:timeticks",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)""",
        })

    self.__last_modified = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_modified(self):
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)


  def _get_valid_route(self):
    """
    Getter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/valid_route (boolean)

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    return self.__valid_route
      
  def _set_valid_route(self, v, load=False):
    """
    Setter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/valid_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_route() directly.

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__valid_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_route(self):
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_invalid_reason(self):
    """
    Getter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/invalid_reason (identityref)

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    return self.__invalid_reason
      
  def _set_invalid_reason(self, v, load=False):
    """
    Setter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/invalid_reason (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invalid_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invalid_reason() directly.

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invalid_reason must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)""",
        })

    self.__invalid_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invalid_reason(self):
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)


  def _get_unknown_attributes(self):
    """
    Getter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes (container)

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    return self.__unknown_attributes
      
  def _set_unknown_attributes(self, v, load=False):
    """
    Setter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attributes() directly.

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attributes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__unknown_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attributes(self):
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_reject_reason(self):
    """
    Getter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/reject_reason (union)

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    return self.__reject_reason
      
  def _set_reject_reason(self, v, load=False):
    """
    Setter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/reject_reason (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reject_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reject_reason() directly.

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reject_reason must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)""",
        })

    self.__reject_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reject_reason(self):
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  path_id = __builtin__.property(_get_path_id)
  attr_index = __builtin__.property(_get_attr_index)
  community_index = __builtin__.property(_get_community_index)
  ext_community_index = __builtin__.property(_get_ext_community_index)
  last_modified = __builtin__.property(_get_last_modified)
  valid_route = __builtin__.property(_get_valid_route)
  invalid_reason = __builtin__.property(_get_invalid_reason)
  unknown_attributes = __builtin__.property(_get_unknown_attributes) # type: yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes
  reject_reason = __builtin__.property(_get_reject_reason)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('path_id', path_id), ('attr_index', attr_index), ('community_index', community_index), ('ext_community_index', ext_community_index), ('last_modified', last_modified), ('valid_route', valid_route), ('invalid_reason', invalid_reason), ('unknown_attributes', unknown_attributes), ('reject_reason', reject_reason), ])


class yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-in-pre/routes/clear-routes/clear/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_at',)

  _yang_name = 'input'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes', 'clear-routes', 'clear', 'input']

  def _get_clear_at(self):
    """
    Getter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/input/clear_at (yang:date-and-time)

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    return self.__clear_at
      
  def _set_clear_at(self, v, load=False):
    """
    Setter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/input/clear_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_at() directly.

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_at(self):
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_at = __builtin__.property(_get_clear_at)


  _pyangbind_elements = OrderedDict([('clear_at', clear_at), ])


class yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-in-pre/routes/clear-routes/clear/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_finished_at',)

  _yang_name = 'output'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes', 'clear-routes', 'clear', 'output']

  def _get_clear_finished_at(self):
    """
    Getter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)

    YANG Description: The time when the clear operation finished.
    """
    return self.__clear_finished_at
      
  def _set_clear_finished_at(self, v, load=False):
    """
    Setter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_finished_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_finished_at() directly.

    YANG Description: The time when the clear operation finished.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_finished_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_finished_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_finished_at(self):
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_finished_at = __builtin__.property(_get_clear_finished_at)


  _pyangbind_elements = OrderedDict([('clear_finished_at', clear_finished_at), ])


class yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-in-pre/routes/clear-routes/clear. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__output',)

  _yang_name = 'clear'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes', 'clear-routes', 'clear']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/input (input)
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/input (input)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with input""",
          'defined-type': "ietf-bgp:input",
          'generated-type': """YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)


  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/output (output)
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/output (output)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with output""",
          'defined-type': "ietf-bgp:output",
          'generated-type': """YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

  input = __builtin__.property(_get_input)
  output = __builtin__.property(_get_output)


  _pyangbind_elements = OrderedDict([('input', input), ('output', output), ])


class yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-in-pre/routes/clear-routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Action commands to clear routes governed by a if-feature.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear',)

  _yang_name = 'clear-routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes', 'clear-routes']

  def _get_clear(self):
    """
    Getter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear (action)
    """
    return self.__clear
      
  def _set_clear(self, v, load=False):
    """
    Setter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear (action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear must be of a type compatible with action""",
          'defined-type': "ietf-bgp:action",
          'generated-type': """YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)""",
        })

    self.__clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear(self):
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

  clear = __builtin__.property(_get_clear)


  _pyangbind_elements = OrderedDict([('clear', clear), ])


class yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-in-pre/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of routes in the routing
table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route','__clear_routes',)

  _yang_name = 'routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route (list)

    YANG Description: List of routes in the table, keyed by a combination of
the route prefix and path-id to distinguish multiple
routes received from a neighbor for the same prefix,
e.g., when BGP add-paths is enabled.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: List of routes in the table, keyed by a combination of
the route prefix and path-id to distinguish multiple
routes received from a neighbor for the same prefix,
e.g., when BGP add-paths is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)


  def _get_clear_routes(self):
    """
    Getter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes (container)

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    return self.__clear_routes
      
  def _set_clear_routes(self, v, load=False):
    """
    Setter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_routes() directly.

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__clear_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_routes(self):
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route
  clear_routes = __builtin__.property(_get_clear_routes) # type: yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes


  _pyangbind_elements = OrderedDict([('route', route), ('clear_routes', clear_routes), ])


class yc_adj_rib_in_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-in-pre. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-neighbor table containing the NLRI updates
received from the neighbor before any local input
policy rules or filters have been applied.  This can
be considered the 'raw' updates from the neighbor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routes',)

  _yang_name = 'adj-rib-in-pre'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre']

  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes (container)

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  routes = __builtin__.property(_get_routes) # type: yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre_routes


  _pyangbind_elements = OrderedDict([('routes', routes), ])


class yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes_unknown_attribute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-in-post/routes/route/unknown-attributes/unknown-attribute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optional','__transitive','__partial','__extended','__attr_type','__attr_len','__attr_value',)

  _yang_name = 'unknown-attribute'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-in-post', 'routes', 'route', 'unknown-attributes', 'unknown-attribute']

  def _get_optional(self):
    """
    Getter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/optional (boolean)

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    return self.__optional
      
  def _set_optional(self, v, load=False):
    """
    Setter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/optional (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optional() directly.

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optional must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__optional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optional(self):
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_transitive(self):
    """
    Getter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    return self.__transitive
      
  def _set_transitive(self, v, load=False):
    """
    Setter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transitive() directly.

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transitive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__transitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transitive(self):
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_partial(self):
    """
    Getter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/partial (boolean)

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    return self.__partial
      
  def _set_partial(self, v, load=False):
    """
    Setter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/partial (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partial is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partial() directly.

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partial must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__partial = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partial(self):
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_extended(self):
    """
    Getter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/extended (boolean)

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    return self.__extended
      
  def _set_extended(self, v, load=False):
    """
    Setter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/extended (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended() directly.

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__extended = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended(self):
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_attr_type(self):
    """
    Getter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)

    YANG Description: 1-octet value encoding the attribute type code
    """
    return self.__attr_type
      
  def _set_attr_type(self, v, load=False):
    """
    Setter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_type() directly.

    YANG Description: 1-octet value encoding the attribute type code
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__attr_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_type(self):
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)


  def _get_attr_len(self):
    """
    Getter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    return self.__attr_len
      
  def _set_attr_len(self, v, load=False):
    """
    Setter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_len is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_len() directly.

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_len must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)""",
        })

    self.__attr_len = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_len(self):
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)


  def _get_attr_value(self):
    """
    Getter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    return self.__attr_value
      
  def _set_attr_value(self, v, load=False):
    """
    Setter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_value() directly.

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_value must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)""",
        })

    self.__attr_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_value(self):
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

  optional = __builtin__.property(_get_optional)
  transitive = __builtin__.property(_get_transitive)
  partial = __builtin__.property(_get_partial)
  extended = __builtin__.property(_get_extended)
  attr_type = __builtin__.property(_get_attr_type)
  attr_len = __builtin__.property(_get_attr_len)
  attr_value = __builtin__.property(_get_attr_value)


  _pyangbind_elements = OrderedDict([('optional', optional), ('transitive', transitive), ('partial', partial), ('extended', extended), ('attr_type', attr_type), ('attr_len', attr_len), ('attr_value', attr_value), ])


class yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-in-post/routes/route/unknown-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__unknown_attribute',)

  _yang_name = 'unknown-attributes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-in-post', 'routes', 'route', 'unknown-attributes']

  def _get_unknown_attribute(self):
    """
    Getter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute (list)

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    return self.__unknown_attribute
      
  def _set_unknown_attribute(self, v, load=False):
    """
    Setter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attribute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attribute() directly.

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attribute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__unknown_attribute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attribute(self):
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  unknown_attribute = __builtin__.property(_get_unknown_attribute) # type: yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes_unknown_attribute


  _pyangbind_elements = OrderedDict([('unknown_attribute', unknown_attribute), ])


class yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-in-post/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of routes in the table, keyed by a combination of
the route prefix and path-id to distinguish multiple
routes received from a neighbor for the same prefix,
e.g., when BGP add-paths is enabled.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__path_id','__attr_index','__community_index','__ext_community_index','__last_modified','__valid_route','__invalid_reason','__best_path','__unknown_attributes','__reject_reason',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    self.__best_path = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="best-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-in-post', 'routes', 'route']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/prefix (inet:ipv4-prefix)

    YANG Description: Prefix for the route
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/prefix (inet:ipv4-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Prefix for the route
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv4-prefix""",
          'defined-type': "inet:ipv4-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)


  def _get_path_id(self):
    """
    Getter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/path_id (uint32)

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    return self.__path_id
      
  def _set_path_id(self, v, load=False):
    """
    Setter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/path_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_id() directly.

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__path_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_id(self):
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_attr_index(self):
    """
    Getter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/attr_index (leafref)

    YANG Description: Reference to the common attribute group for the
route
    """
    return self.__attr_index
      
  def _set_attr_index(self, v, load=False):
    """
    Setter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/attr_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_index() directly.

    YANG Description: Reference to the common attribute group for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__attr_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_index(self):
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_community_index(self):
    """
    Getter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/community_index (leafref)

    YANG Description: Reference to the community attribute for the route
    """
    return self.__community_index
      
  def _set_community_index(self, v, load=False):
    """
    Setter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_community_index() directly.

    YANG Description: Reference to the community attribute for the route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_community_index(self):
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_ext_community_index(self):
    """
    Getter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/ext_community_index (leafref)

    YANG Description: Reference to the extended community attribute for the
route
    """
    return self.__ext_community_index
      
  def _set_ext_community_index(self, v, load=False):
    """
    Setter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/ext_community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_community_index() directly.

    YANG Description: Reference to the extended community attribute for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__ext_community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_community_index(self):
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_last_modified(self):
    """
    Getter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/last_modified (types:timeticks)

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_modified
      
  def _set_last_modified(self, v, load=False):
    """
    Setter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/last_modified (types:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_modified is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_modified() directly.

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_modified must be of a type compatible with types:timeticks""",
          'defined-type': "types:timeticks",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)""",
        })

    self.__last_modified = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_modified(self):
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)


  def _get_valid_route(self):
    """
    Getter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/valid_route (boolean)

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    return self.__valid_route
      
  def _set_valid_route(self, v, load=False):
    """
    Setter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/valid_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_route() directly.

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__valid_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_route(self):
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_invalid_reason(self):
    """
    Getter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/invalid_reason (identityref)

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    return self.__invalid_reason
      
  def _set_invalid_reason(self, v, load=False):
    """
    Setter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/invalid_reason (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invalid_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invalid_reason() directly.

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invalid_reason must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)""",
        })

    self.__invalid_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invalid_reason(self):
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)


  def _get_best_path(self):
    """
    Getter method for best_path, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/best_path (boolean)

    YANG Description: Current path was selected as the best path.
    """
    return self.__best_path
      
  def _set_best_path(self, v, load=False):
    """
    Setter method for best_path, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/best_path (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_best_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_best_path() directly.

    YANG Description: Current path was selected as the best path.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="best-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """best_path must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="best-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__best_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_best_path(self):
    self.__best_path = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="best-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_unknown_attributes(self):
    """
    Getter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes (container)

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    return self.__unknown_attributes
      
  def _set_unknown_attributes(self, v, load=False):
    """
    Setter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attributes() directly.

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attributes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__unknown_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attributes(self):
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_reject_reason(self):
    """
    Getter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/reject_reason (union)

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    return self.__reject_reason
      
  def _set_reject_reason(self, v, load=False):
    """
    Setter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/reject_reason (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reject_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reject_reason() directly.

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reject_reason must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)""",
        })

    self.__reject_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reject_reason(self):
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  path_id = __builtin__.property(_get_path_id)
  attr_index = __builtin__.property(_get_attr_index)
  community_index = __builtin__.property(_get_community_index)
  ext_community_index = __builtin__.property(_get_ext_community_index)
  last_modified = __builtin__.property(_get_last_modified)
  valid_route = __builtin__.property(_get_valid_route)
  invalid_reason = __builtin__.property(_get_invalid_reason)
  best_path = __builtin__.property(_get_best_path)
  unknown_attributes = __builtin__.property(_get_unknown_attributes) # type: yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes
  reject_reason = __builtin__.property(_get_reject_reason)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('path_id', path_id), ('attr_index', attr_index), ('community_index', community_index), ('ext_community_index', ext_community_index), ('last_modified', last_modified), ('valid_route', valid_route), ('invalid_reason', invalid_reason), ('best_path', best_path), ('unknown_attributes', unknown_attributes), ('reject_reason', reject_reason), ])


class yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-in-post/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of routes in the routing
table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-in-post', 'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route (list)

    YANG Description: List of routes in the table, keyed by a combination of
the route prefix and path-id to distinguish multiple
routes received from a neighbor for the same prefix,
e.g., when BGP add-paths is enabled.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: List of routes in the table, keyed by a combination of
the route prefix and path-id to distinguish multiple
routes received from a neighbor for the same prefix,
e.g., when BGP add-paths is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes_route


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_adj_rib_in_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-in-post. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-neighbor table containing the paths received from
the neighbor that are eligible for best-path selection
after local input policy rules have been applied.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routes',)

  _yang_name = 'adj-rib-in-post'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-in-post']

  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes (container)

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  routes = __builtin__.property(_get_routes) # type: yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post_routes


  _pyangbind_elements = OrderedDict([('routes', routes), ])


class yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes_unknown_attribute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-pre/routes/route/unknown-attributes/unknown-attribute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optional','__transitive','__partial','__extended','__attr_type','__attr_len','__attr_value',)

  _yang_name = 'unknown-attribute'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes', 'route', 'unknown-attributes', 'unknown-attribute']

  def _get_optional(self):
    """
    Getter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/optional (boolean)

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    return self.__optional
      
  def _set_optional(self, v, load=False):
    """
    Setter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/optional (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optional() directly.

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optional must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__optional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optional(self):
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_transitive(self):
    """
    Getter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    return self.__transitive
      
  def _set_transitive(self, v, load=False):
    """
    Setter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transitive() directly.

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transitive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__transitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transitive(self):
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_partial(self):
    """
    Getter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/partial (boolean)

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    return self.__partial
      
  def _set_partial(self, v, load=False):
    """
    Setter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/partial (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partial is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partial() directly.

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partial must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__partial = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partial(self):
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_extended(self):
    """
    Getter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/extended (boolean)

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    return self.__extended
      
  def _set_extended(self, v, load=False):
    """
    Setter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/extended (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended() directly.

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__extended = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended(self):
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_attr_type(self):
    """
    Getter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)

    YANG Description: 1-octet value encoding the attribute type code
    """
    return self.__attr_type
      
  def _set_attr_type(self, v, load=False):
    """
    Setter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_type() directly.

    YANG Description: 1-octet value encoding the attribute type code
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__attr_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_type(self):
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)


  def _get_attr_len(self):
    """
    Getter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    return self.__attr_len
      
  def _set_attr_len(self, v, load=False):
    """
    Setter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_len is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_len() directly.

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_len must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)""",
        })

    self.__attr_len = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_len(self):
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)


  def _get_attr_value(self):
    """
    Getter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    return self.__attr_value
      
  def _set_attr_value(self, v, load=False):
    """
    Setter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_value() directly.

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_value must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)""",
        })

    self.__attr_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_value(self):
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

  optional = __builtin__.property(_get_optional)
  transitive = __builtin__.property(_get_transitive)
  partial = __builtin__.property(_get_partial)
  extended = __builtin__.property(_get_extended)
  attr_type = __builtin__.property(_get_attr_type)
  attr_len = __builtin__.property(_get_attr_len)
  attr_value = __builtin__.property(_get_attr_value)


  _pyangbind_elements = OrderedDict([('optional', optional), ('transitive', transitive), ('partial', partial), ('extended', extended), ('attr_type', attr_type), ('attr_len', attr_len), ('attr_value', attr_value), ])


class yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-pre/routes/route/unknown-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__unknown_attribute',)

  _yang_name = 'unknown-attributes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes', 'route', 'unknown-attributes']

  def _get_unknown_attribute(self):
    """
    Getter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute (list)

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    return self.__unknown_attribute
      
  def _set_unknown_attribute(self, v, load=False):
    """
    Setter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attribute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attribute() directly.

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attribute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__unknown_attribute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attribute(self):
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  unknown_attribute = __builtin__.property(_get_unknown_attribute) # type: yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes_unknown_attribute


  _pyangbind_elements = OrderedDict([('unknown_attribute', unknown_attribute), ])


class yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-pre/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of routes in the table, keyed by a combination of
the route prefix and path-id to distinguish multiple
routes received from a neighbor for the same prefix,
e.g., when BGP add-paths is enabled.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__path_id','__attr_index','__community_index','__ext_community_index','__last_modified','__valid_route','__invalid_reason','__unknown_attributes','__reject_reason',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes', 'route']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/prefix (inet:ipv4-prefix)

    YANG Description: Prefix for the route
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/prefix (inet:ipv4-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Prefix for the route
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv4-prefix""",
          'defined-type': "inet:ipv4-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)


  def _get_path_id(self):
    """
    Getter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/path_id (uint32)

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    return self.__path_id
      
  def _set_path_id(self, v, load=False):
    """
    Setter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/path_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_id() directly.

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__path_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_id(self):
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_attr_index(self):
    """
    Getter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/attr_index (leafref)

    YANG Description: Reference to the common attribute group for the
route
    """
    return self.__attr_index
      
  def _set_attr_index(self, v, load=False):
    """
    Setter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/attr_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_index() directly.

    YANG Description: Reference to the common attribute group for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__attr_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_index(self):
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_community_index(self):
    """
    Getter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/community_index (leafref)

    YANG Description: Reference to the community attribute for the route
    """
    return self.__community_index
      
  def _set_community_index(self, v, load=False):
    """
    Setter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_community_index() directly.

    YANG Description: Reference to the community attribute for the route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_community_index(self):
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_ext_community_index(self):
    """
    Getter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/ext_community_index (leafref)

    YANG Description: Reference to the extended community attribute for the
route
    """
    return self.__ext_community_index
      
  def _set_ext_community_index(self, v, load=False):
    """
    Setter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/ext_community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_community_index() directly.

    YANG Description: Reference to the extended community attribute for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__ext_community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_community_index(self):
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_last_modified(self):
    """
    Getter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/last_modified (types:timeticks)

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_modified
      
  def _set_last_modified(self, v, load=False):
    """
    Setter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/last_modified (types:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_modified is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_modified() directly.

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_modified must be of a type compatible with types:timeticks""",
          'defined-type': "types:timeticks",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)""",
        })

    self.__last_modified = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_modified(self):
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)


  def _get_valid_route(self):
    """
    Getter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/valid_route (boolean)

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    return self.__valid_route
      
  def _set_valid_route(self, v, load=False):
    """
    Setter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/valid_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_route() directly.

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__valid_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_route(self):
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_invalid_reason(self):
    """
    Getter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/invalid_reason (identityref)

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    return self.__invalid_reason
      
  def _set_invalid_reason(self, v, load=False):
    """
    Setter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/invalid_reason (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invalid_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invalid_reason() directly.

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invalid_reason must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)""",
        })

    self.__invalid_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invalid_reason(self):
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)


  def _get_unknown_attributes(self):
    """
    Getter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes (container)

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    return self.__unknown_attributes
      
  def _set_unknown_attributes(self, v, load=False):
    """
    Setter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attributes() directly.

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attributes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__unknown_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attributes(self):
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_reject_reason(self):
    """
    Getter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/reject_reason (union)

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    return self.__reject_reason
      
  def _set_reject_reason(self, v, load=False):
    """
    Setter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/reject_reason (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reject_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reject_reason() directly.

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reject_reason must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)""",
        })

    self.__reject_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reject_reason(self):
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  path_id = __builtin__.property(_get_path_id)
  attr_index = __builtin__.property(_get_attr_index)
  community_index = __builtin__.property(_get_community_index)
  ext_community_index = __builtin__.property(_get_ext_community_index)
  last_modified = __builtin__.property(_get_last_modified)
  valid_route = __builtin__.property(_get_valid_route)
  invalid_reason = __builtin__.property(_get_invalid_reason)
  unknown_attributes = __builtin__.property(_get_unknown_attributes) # type: yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes
  reject_reason = __builtin__.property(_get_reject_reason)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('path_id', path_id), ('attr_index', attr_index), ('community_index', community_index), ('ext_community_index', ext_community_index), ('last_modified', last_modified), ('valid_route', valid_route), ('invalid_reason', invalid_reason), ('unknown_attributes', unknown_attributes), ('reject_reason', reject_reason), ])


class yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-pre/routes/clear-routes/clear/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_at',)

  _yang_name = 'input'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes', 'clear-routes', 'clear', 'input']

  def _get_clear_at(self):
    """
    Getter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/input/clear_at (yang:date-and-time)

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    return self.__clear_at
      
  def _set_clear_at(self, v, load=False):
    """
    Setter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/input/clear_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_at() directly.

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_at(self):
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_at = __builtin__.property(_get_clear_at)


  _pyangbind_elements = OrderedDict([('clear_at', clear_at), ])


class yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-pre/routes/clear-routes/clear/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_finished_at',)

  _yang_name = 'output'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes', 'clear-routes', 'clear', 'output']

  def _get_clear_finished_at(self):
    """
    Getter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)

    YANG Description: The time when the clear operation finished.
    """
    return self.__clear_finished_at
      
  def _set_clear_finished_at(self, v, load=False):
    """
    Setter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_finished_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_finished_at() directly.

    YANG Description: The time when the clear operation finished.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_finished_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_finished_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_finished_at(self):
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_finished_at = __builtin__.property(_get_clear_finished_at)


  _pyangbind_elements = OrderedDict([('clear_finished_at', clear_finished_at), ])


class yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-pre/routes/clear-routes/clear. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__output',)

  _yang_name = 'clear'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes', 'clear-routes', 'clear']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/input (input)
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/input (input)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with input""",
          'defined-type': "ietf-bgp:input",
          'generated-type': """YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)


  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/output (output)
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/output (output)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with output""",
          'defined-type': "ietf-bgp:output",
          'generated-type': """YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

  input = __builtin__.property(_get_input)
  output = __builtin__.property(_get_output)


  _pyangbind_elements = OrderedDict([('input', input), ('output', output), ])


class yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-pre/routes/clear-routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Action commands to clear routes governed by a if-feature.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear',)

  _yang_name = 'clear-routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes', 'clear-routes']

  def _get_clear(self):
    """
    Getter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear (action)
    """
    return self.__clear
      
  def _set_clear(self, v, load=False):
    """
    Setter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear (action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear must be of a type compatible with action""",
          'defined-type': "ietf-bgp:action",
          'generated-type': """YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)""",
        })

    self.__clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear(self):
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

  clear = __builtin__.property(_get_clear)


  _pyangbind_elements = OrderedDict([('clear', clear), ])


class yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-pre/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of routes in the routing
table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route','__clear_routes',)

  _yang_name = 'routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route (list)

    YANG Description: List of routes in the table, keyed by a combination of
the route prefix and path-id to distinguish multiple
routes received from a neighbor for the same prefix,
e.g., when BGP add-paths is enabled.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: List of routes in the table, keyed by a combination of
the route prefix and path-id to distinguish multiple
routes received from a neighbor for the same prefix,
e.g., when BGP add-paths is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)


  def _get_clear_routes(self):
    """
    Getter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes (container)

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    return self.__clear_routes
      
  def _set_clear_routes(self, v, load=False):
    """
    Setter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_routes() directly.

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__clear_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_routes(self):
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route
  clear_routes = __builtin__.property(_get_clear_routes) # type: yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes


  _pyangbind_elements = OrderedDict([('route', route), ('clear_routes', clear_routes), ])


class yc_adj_rib_out_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-pre. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-neighbor table containing paths eligble for
sending (advertising) to the neighbor before output
policy rules have been applied
  """
  __slots__ = ('_path_helper', '_extmethods', '__routes',)

  _yang_name = 'adj-rib-out-pre'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre']

  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes (container)

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  routes = __builtin__.property(_get_routes) # type: yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre_routes


  _pyangbind_elements = OrderedDict([('routes', routes), ])


class yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes_unknown_attribute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-post/routes/route/unknown-attributes/unknown-attribute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optional','__transitive','__partial','__extended','__attr_type','__attr_len','__attr_value',)

  _yang_name = 'unknown-attribute'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes', 'route', 'unknown-attributes', 'unknown-attribute']

  def _get_optional(self):
    """
    Getter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/optional (boolean)

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    return self.__optional
      
  def _set_optional(self, v, load=False):
    """
    Setter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/optional (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optional() directly.

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optional must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__optional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optional(self):
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_transitive(self):
    """
    Getter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    return self.__transitive
      
  def _set_transitive(self, v, load=False):
    """
    Setter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transitive() directly.

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transitive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__transitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transitive(self):
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_partial(self):
    """
    Getter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/partial (boolean)

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    return self.__partial
      
  def _set_partial(self, v, load=False):
    """
    Setter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/partial (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partial is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partial() directly.

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partial must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__partial = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partial(self):
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_extended(self):
    """
    Getter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/extended (boolean)

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    return self.__extended
      
  def _set_extended(self, v, load=False):
    """
    Setter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/extended (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended() directly.

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__extended = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended(self):
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_attr_type(self):
    """
    Getter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)

    YANG Description: 1-octet value encoding the attribute type code
    """
    return self.__attr_type
      
  def _set_attr_type(self, v, load=False):
    """
    Setter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_type() directly.

    YANG Description: 1-octet value encoding the attribute type code
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__attr_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_type(self):
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)


  def _get_attr_len(self):
    """
    Getter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    return self.__attr_len
      
  def _set_attr_len(self, v, load=False):
    """
    Setter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_len is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_len() directly.

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_len must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)""",
        })

    self.__attr_len = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_len(self):
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)


  def _get_attr_value(self):
    """
    Getter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    return self.__attr_value
      
  def _set_attr_value(self, v, load=False):
    """
    Setter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_value() directly.

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_value must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)""",
        })

    self.__attr_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_value(self):
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

  optional = __builtin__.property(_get_optional)
  transitive = __builtin__.property(_get_transitive)
  partial = __builtin__.property(_get_partial)
  extended = __builtin__.property(_get_extended)
  attr_type = __builtin__.property(_get_attr_type)
  attr_len = __builtin__.property(_get_attr_len)
  attr_value = __builtin__.property(_get_attr_value)


  _pyangbind_elements = OrderedDict([('optional', optional), ('transitive', transitive), ('partial', partial), ('extended', extended), ('attr_type', attr_type), ('attr_len', attr_len), ('attr_value', attr_value), ])


class yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-post/routes/route/unknown-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__unknown_attribute',)

  _yang_name = 'unknown-attributes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes', 'route', 'unknown-attributes']

  def _get_unknown_attribute(self):
    """
    Getter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute (list)

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    return self.__unknown_attribute
      
  def _set_unknown_attribute(self, v, load=False):
    """
    Setter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attribute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attribute() directly.

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attribute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__unknown_attribute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attribute(self):
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  unknown_attribute = __builtin__.property(_get_unknown_attribute) # type: yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes_unknown_attribute


  _pyangbind_elements = OrderedDict([('unknown_attribute', unknown_attribute), ])


class yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-post/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of routes in the table, keyed by a combination of
the route prefix and path-id to distinguish multiple
routes received from a neighbor for the same prefix,
e.g., when BGP add-paths is enabled.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__path_id','__attr_index','__community_index','__ext_community_index','__last_modified','__valid_route','__invalid_reason','__unknown_attributes','__reject_reason',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes', 'route']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/prefix (inet:ipv4-prefix)

    YANG Description: Prefix for the route
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/prefix (inet:ipv4-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Prefix for the route
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv4-prefix""",
          'defined-type': "inet:ipv4-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv4-prefix', is_config=False)


  def _get_path_id(self):
    """
    Getter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/path_id (uint32)

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    return self.__path_id
      
  def _set_path_id(self, v, load=False):
    """
    Setter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/path_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_id() directly.

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__path_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_id(self):
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_attr_index(self):
    """
    Getter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/attr_index (leafref)

    YANG Description: Reference to the common attribute group for the
route
    """
    return self.__attr_index
      
  def _set_attr_index(self, v, load=False):
    """
    Setter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/attr_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_index() directly.

    YANG Description: Reference to the common attribute group for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__attr_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_index(self):
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_community_index(self):
    """
    Getter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/community_index (leafref)

    YANG Description: Reference to the community attribute for the route
    """
    return self.__community_index
      
  def _set_community_index(self, v, load=False):
    """
    Setter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_community_index() directly.

    YANG Description: Reference to the community attribute for the route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_community_index(self):
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_ext_community_index(self):
    """
    Getter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/ext_community_index (leafref)

    YANG Description: Reference to the extended community attribute for the
route
    """
    return self.__ext_community_index
      
  def _set_ext_community_index(self, v, load=False):
    """
    Setter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/ext_community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_community_index() directly.

    YANG Description: Reference to the extended community attribute for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__ext_community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_community_index(self):
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_last_modified(self):
    """
    Getter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/last_modified (types:timeticks)

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_modified
      
  def _set_last_modified(self, v, load=False):
    """
    Setter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/last_modified (types:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_modified is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_modified() directly.

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_modified must be of a type compatible with types:timeticks""",
          'defined-type': "types:timeticks",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)""",
        })

    self.__last_modified = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_modified(self):
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)


  def _get_valid_route(self):
    """
    Getter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/valid_route (boolean)

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    return self.__valid_route
      
  def _set_valid_route(self, v, load=False):
    """
    Setter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/valid_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_route() directly.

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__valid_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_route(self):
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_invalid_reason(self):
    """
    Getter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/invalid_reason (identityref)

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    return self.__invalid_reason
      
  def _set_invalid_reason(self, v, load=False):
    """
    Setter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/invalid_reason (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invalid_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invalid_reason() directly.

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invalid_reason must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)""",
        })

    self.__invalid_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invalid_reason(self):
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)


  def _get_unknown_attributes(self):
    """
    Getter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes (container)

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    return self.__unknown_attributes
      
  def _set_unknown_attributes(self, v, load=False):
    """
    Setter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attributes() directly.

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attributes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__unknown_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attributes(self):
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_reject_reason(self):
    """
    Getter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/reject_reason (union)

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    return self.__reject_reason
      
  def _set_reject_reason(self, v, load=False):
    """
    Setter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/reject_reason (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reject_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reject_reason() directly.

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reject_reason must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)""",
        })

    self.__reject_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reject_reason(self):
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  path_id = __builtin__.property(_get_path_id)
  attr_index = __builtin__.property(_get_attr_index)
  community_index = __builtin__.property(_get_community_index)
  ext_community_index = __builtin__.property(_get_ext_community_index)
  last_modified = __builtin__.property(_get_last_modified)
  valid_route = __builtin__.property(_get_valid_route)
  invalid_reason = __builtin__.property(_get_invalid_reason)
  unknown_attributes = __builtin__.property(_get_unknown_attributes) # type: yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes
  reject_reason = __builtin__.property(_get_reject_reason)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('path_id', path_id), ('attr_index', attr_index), ('community_index', community_index), ('ext_community_index', ext_community_index), ('last_modified', last_modified), ('valid_route', valid_route), ('invalid_reason', invalid_reason), ('unknown_attributes', unknown_attributes), ('reject_reason', reject_reason), ])


class yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-post/routes/clear-routes/clear/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_at',)

  _yang_name = 'input'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes', 'clear-routes', 'clear', 'input']

  def _get_clear_at(self):
    """
    Getter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/input/clear_at (yang:date-and-time)

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    return self.__clear_at
      
  def _set_clear_at(self, v, load=False):
    """
    Setter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/input/clear_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_at() directly.

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_at(self):
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_at = __builtin__.property(_get_clear_at)


  _pyangbind_elements = OrderedDict([('clear_at', clear_at), ])


class yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-post/routes/clear-routes/clear/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_finished_at',)

  _yang_name = 'output'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes', 'clear-routes', 'clear', 'output']

  def _get_clear_finished_at(self):
    """
    Getter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)

    YANG Description: The time when the clear operation finished.
    """
    return self.__clear_finished_at
      
  def _set_clear_finished_at(self, v, load=False):
    """
    Setter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_finished_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_finished_at() directly.

    YANG Description: The time when the clear operation finished.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_finished_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_finished_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_finished_at(self):
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_finished_at = __builtin__.property(_get_clear_finished_at)


  _pyangbind_elements = OrderedDict([('clear_finished_at', clear_finished_at), ])


class yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-post/routes/clear-routes/clear. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__output',)

  _yang_name = 'clear'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes', 'clear-routes', 'clear']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/input (input)
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/input (input)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with input""",
          'defined-type': "ietf-bgp:input",
          'generated-type': """YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)


  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/output (output)
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/output (output)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with output""",
          'defined-type': "ietf-bgp:output",
          'generated-type': """YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

  input = __builtin__.property(_get_input)
  output = __builtin__.property(_get_output)


  _pyangbind_elements = OrderedDict([('input', input), ('output', output), ])


class yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-post/routes/clear-routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Action commands to clear routes governed by a if-feature.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear',)

  _yang_name = 'clear-routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes', 'clear-routes']

  def _get_clear(self):
    """
    Getter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear (action)
    """
    return self.__clear
      
  def _set_clear(self, v, load=False):
    """
    Setter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear (action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear must be of a type compatible with action""",
          'defined-type': "ietf-bgp:action",
          'generated-type': """YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)""",
        })

    self.__clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear(self):
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

  clear = __builtin__.property(_get_clear)


  _pyangbind_elements = OrderedDict([('clear', clear), ])


class yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-post/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of routes in the routing
table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route','__clear_routes',)

  _yang_name = 'routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route (list)

    YANG Description: List of routes in the table, keyed by a combination of
the route prefix and path-id to distinguish multiple
routes received from a neighbor for the same prefix,
e.g., when BGP add-paths is enabled.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: List of routes in the table, keyed by a combination of
the route prefix and path-id to distinguish multiple
routes received from a neighbor for the same prefix,
e.g., when BGP add-paths is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)


  def _get_clear_routes(self):
    """
    Getter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes (container)

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    return self.__clear_routes
      
  def _set_clear_routes(self, v, load=False):
    """
    Setter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_routes() directly.

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__clear_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_routes(self):
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_route
  clear_routes = __builtin__.property(_get_clear_routes) # type: yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes


  _pyangbind_elements = OrderedDict([('route', route), ('clear_routes', clear_routes), ])


class yc_adj_rib_out_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor/adj-rib-out-post. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-neighbor table containing paths eligble for
sending (advertising) to the neighbor after output
policy rules have been applied
  """
  __slots__ = ('_path_helper', '_extmethods', '__routes',)

  _yang_name = 'adj-rib-out-post'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post']

  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes (container)

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  routes = __builtin__.property(_get_routes) # type: yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post_routes


  _pyangbind_elements = OrderedDict([('routes', routes), ])


class yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of neighbors (peers) of the local BGP speaker
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor_address','__adj_rib_in_pre','__adj_rib_in_post','__adj_rib_out_pre','__adj_rib_out_post',)

  _yang_name = 'neighbor'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)
    self.__adj_rib_in_pre = YANGDynClass(base=yc_adj_rib_in_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre, is_container='container', yang_name="adj-rib-in-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__adj_rib_in_post = YANGDynClass(base=yc_adj_rib_in_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post, is_container='container', yang_name="adj-rib-in-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__adj_rib_out_pre = YANGDynClass(base=yc_adj_rib_out_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre, is_container='container', yang_name="adj-rib-out-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__adj_rib_out_post = YANGDynClass(base=yc_adj_rib_out_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post, is_container='container', yang_name="adj-rib-out-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors', 'neighbor']

  def _get_neighbor_address(self):
    """
    Getter method for neighbor_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/neighbor_address (inet:ip-address)

    YANG Description: IP address of the BGP neighbor or peer
    """
    return self.__neighbor_address
      
  def _set_neighbor_address(self, v, load=False):
    """
    Setter method for neighbor_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/neighbor_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_address() directly.

    YANG Description: IP address of the BGP neighbor or peer
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)""",
        })

    self.__neighbor_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_address(self):
    self.__neighbor_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)


  def _get_adj_rib_in_pre(self):
    """
    Getter method for adj_rib_in_pre, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre (container)

    YANG Description: Per-neighbor table containing the NLRI updates
received from the neighbor before any local input
policy rules or filters have been applied.  This can
be considered the 'raw' updates from the neighbor.
    """
    return self.__adj_rib_in_pre
      
  def _set_adj_rib_in_pre(self, v, load=False):
    """
    Setter method for adj_rib_in_pre, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_pre (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_rib_in_pre is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_rib_in_pre() directly.

    YANG Description: Per-neighbor table containing the NLRI updates
received from the neighbor before any local input
policy rules or filters have been applied.  This can
be considered the 'raw' updates from the neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_adj_rib_in_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre, is_container='container', yang_name="adj-rib-in-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_rib_in_pre must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_adj_rib_in_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre, is_container='container', yang_name="adj-rib-in-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__adj_rib_in_pre = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_rib_in_pre(self):
    self.__adj_rib_in_pre = YANGDynClass(base=yc_adj_rib_in_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre, is_container='container', yang_name="adj-rib-in-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_adj_rib_in_post(self):
    """
    Getter method for adj_rib_in_post, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post (container)

    YANG Description: Per-neighbor table containing the paths received from
the neighbor that are eligible for best-path selection
after local input policy rules have been applied.
    """
    return self.__adj_rib_in_post
      
  def _set_adj_rib_in_post(self, v, load=False):
    """
    Setter method for adj_rib_in_post, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_in_post (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_rib_in_post is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_rib_in_post() directly.

    YANG Description: Per-neighbor table containing the paths received from
the neighbor that are eligible for best-path selection
after local input policy rules have been applied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_adj_rib_in_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post, is_container='container', yang_name="adj-rib-in-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_rib_in_post must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_adj_rib_in_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post, is_container='container', yang_name="adj-rib-in-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__adj_rib_in_post = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_rib_in_post(self):
    self.__adj_rib_in_post = YANGDynClass(base=yc_adj_rib_in_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post, is_container='container', yang_name="adj-rib-in-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_adj_rib_out_pre(self):
    """
    Getter method for adj_rib_out_pre, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre (container)

    YANG Description: Per-neighbor table containing paths eligble for
sending (advertising) to the neighbor before output
policy rules have been applied
    """
    return self.__adj_rib_out_pre
      
  def _set_adj_rib_out_pre(self, v, load=False):
    """
    Setter method for adj_rib_out_pre, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_pre (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_rib_out_pre is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_rib_out_pre() directly.

    YANG Description: Per-neighbor table containing paths eligble for
sending (advertising) to the neighbor before output
policy rules have been applied
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_adj_rib_out_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre, is_container='container', yang_name="adj-rib-out-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_rib_out_pre must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_adj_rib_out_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre, is_container='container', yang_name="adj-rib-out-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__adj_rib_out_pre = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_rib_out_pre(self):
    self.__adj_rib_out_pre = YANGDynClass(base=yc_adj_rib_out_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre, is_container='container', yang_name="adj-rib-out-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_adj_rib_out_post(self):
    """
    Getter method for adj_rib_out_post, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post (container)

    YANG Description: Per-neighbor table containing paths eligble for
sending (advertising) to the neighbor after output
policy rules have been applied
    """
    return self.__adj_rib_out_post
      
  def _set_adj_rib_out_post(self, v, load=False):
    """
    Setter method for adj_rib_out_post, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor/adj_rib_out_post (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_rib_out_post is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_rib_out_post() directly.

    YANG Description: Per-neighbor table containing paths eligble for
sending (advertising) to the neighbor after output
policy rules have been applied
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_adj_rib_out_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post, is_container='container', yang_name="adj-rib-out-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_rib_out_post must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_adj_rib_out_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post, is_container='container', yang_name="adj-rib-out-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__adj_rib_out_post = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_rib_out_post(self):
    self.__adj_rib_out_post = YANGDynClass(base=yc_adj_rib_out_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post, is_container='container', yang_name="adj-rib-out-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  neighbor_address = __builtin__.property(_get_neighbor_address)
  adj_rib_in_pre = __builtin__.property(_get_adj_rib_in_pre) # type: yc_adj_rib_in_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_pre
  adj_rib_in_post = __builtin__.property(_get_adj_rib_in_post) # type: yc_adj_rib_in_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_in_post
  adj_rib_out_pre = __builtin__.property(_get_adj_rib_out_pre) # type: yc_adj_rib_out_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_pre
  adj_rib_out_post = __builtin__.property(_get_adj_rib_out_post) # type: yc_adj_rib_out_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor_adj_rib_out_post


  _pyangbind_elements = OrderedDict([('neighbor_address', neighbor_address), ('adj_rib_in_pre', adj_rib_in_pre), ('adj_rib_in_post', adj_rib_in_post), ('adj_rib_out_pre', adj_rib_out_pre), ('adj_rib_out_post', adj_rib_out_post), ])


class yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for neighbor list
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor',)

  _yang_name = 'neighbors'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor = YANGDynClass(base=YANGListType("neighbor_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbor-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast', 'neighbors']

  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor (list)

    YANG Description: List of neighbors (peers) of the local BGP speaker
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: List of neighbors (peers) of the local BGP speaker
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("neighbor_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbor-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("neighbor_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbor-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("neighbor_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbor-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  neighbor = __builtin__.property(_get_neighbor) # type: yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors_neighbor


  _pyangbind_elements = OrderedDict([('neighbor', neighbor), ])


class yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Routing tables for IPv4 unicast -- active when the
      afi-safi name is ipv4-unicast
  """
  __slots__ = ('_path_helper', '_extmethods', '__loc_rib','__neighbors',)

  _yang_name = 'ipv4-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__loc_rib = YANGDynClass(base=yc_loc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib, is_container='container', yang_name="loc-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__neighbors = YANGDynClass(base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv4-unicast']

  def _get_loc_rib(self):
    """
    Getter method for loc_rib, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib (container)

    YANG Description: Container for the IPv4 BGP LOC-RIB data
    """
    return self.__loc_rib
      
  def _set_loc_rib(self, v, load=False):
    """
    Setter method for loc_rib, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/loc_rib (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loc_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loc_rib() directly.

    YANG Description: Container for the IPv4 BGP LOC-RIB data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_loc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib, is_container='container', yang_name="loc-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loc_rib must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_loc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib, is_container='container', yang_name="loc-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__loc_rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loc_rib(self):
    self.__loc_rib = YANGDynClass(base=yc_loc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib, is_container='container', yang_name="loc-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_neighbors(self):
    """
    Getter method for neighbors, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors (container)

    YANG Description: Enclosing container for neighbor list
    """
    return self.__neighbors
      
  def _set_neighbors(self, v, load=False):
    """
    Setter method for neighbors, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast/neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbors() directly.

    YANG Description: Enclosing container for neighbor list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbors(self):
    self.__neighbors = YANGDynClass(base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  loc_rib = __builtin__.property(_get_loc_rib) # type: yc_loc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_loc_rib
  neighbors = __builtin__.property(_get_neighbors) # type: yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast_neighbors


  _pyangbind_elements = OrderedDict([('loc_rib', loc_rib), ('neighbors', neighbors), ])


class yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route_unknown_attributes_unknown_attribute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/loc-rib/routes/route/unknown-attributes/unknown-attribute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optional','__transitive','__partial','__extended','__attr_type','__attr_len','__attr_value',)

  _yang_name = 'unknown-attribute'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'loc-rib', 'routes', 'route', 'unknown-attributes', 'unknown-attribute']

  def _get_optional(self):
    """
    Getter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/optional (boolean)

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    return self.__optional
      
  def _set_optional(self, v, load=False):
    """
    Setter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/optional (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optional() directly.

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optional must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__optional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optional(self):
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_transitive(self):
    """
    Getter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    return self.__transitive
      
  def _set_transitive(self, v, load=False):
    """
    Setter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transitive() directly.

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transitive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__transitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transitive(self):
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_partial(self):
    """
    Getter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/partial (boolean)

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    return self.__partial
      
  def _set_partial(self, v, load=False):
    """
    Setter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/partial (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partial is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partial() directly.

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partial must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__partial = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partial(self):
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_extended(self):
    """
    Getter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/extended (boolean)

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    return self.__extended
      
  def _set_extended(self, v, load=False):
    """
    Setter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/extended (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended() directly.

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__extended = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended(self):
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_attr_type(self):
    """
    Getter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)

    YANG Description: 1-octet value encoding the attribute type code
    """
    return self.__attr_type
      
  def _set_attr_type(self, v, load=False):
    """
    Setter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_type() directly.

    YANG Description: 1-octet value encoding the attribute type code
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__attr_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_type(self):
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)


  def _get_attr_len(self):
    """
    Getter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    return self.__attr_len
      
  def _set_attr_len(self, v, load=False):
    """
    Setter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_len is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_len() directly.

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_len must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)""",
        })

    self.__attr_len = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_len(self):
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)


  def _get_attr_value(self):
    """
    Getter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    return self.__attr_value
      
  def _set_attr_value(self, v, load=False):
    """
    Setter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_value() directly.

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_value must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)""",
        })

    self.__attr_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_value(self):
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

  optional = __builtin__.property(_get_optional)
  transitive = __builtin__.property(_get_transitive)
  partial = __builtin__.property(_get_partial)
  extended = __builtin__.property(_get_extended)
  attr_type = __builtin__.property(_get_attr_type)
  attr_len = __builtin__.property(_get_attr_len)
  attr_value = __builtin__.property(_get_attr_value)


  _pyangbind_elements = OrderedDict([('optional', optional), ('transitive', transitive), ('partial', partial), ('extended', extended), ('attr_type', attr_type), ('attr_len', attr_len), ('attr_value', attr_value), ])


class yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route_unknown_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/loc-rib/routes/route/unknown-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__unknown_attribute',)

  _yang_name = 'unknown-attributes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'loc-rib', 'routes', 'route', 'unknown-attributes']

  def _get_unknown_attribute(self):
    """
    Getter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute (list)

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    return self.__unknown_attribute
      
  def _set_unknown_attribute(self, v, load=False):
    """
    Setter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes/unknown_attribute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attribute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attribute() directly.

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attribute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__unknown_attribute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attribute(self):
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  unknown_attribute = __builtin__.property(_get_unknown_attribute) # type: yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route_unknown_attributes_unknown_attribute


  _pyangbind_elements = OrderedDict([('unknown_attribute', unknown_attribute), ])


class yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/loc-rib/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of routes in the table, keyed by the route
prefix, the route origin, and path-id.  The route
origin can be either the neighbor address from which
the route was learned, or the source protocol that
injected the route.  The path-id distinguishes routes
for the same prefix received from a neighbor (e.g.,
if add-paths is enabled).
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__origin','__path_id','__attr_index','__community_index','__ext_community_index','__last_modified','__valid_route','__invalid_reason','__unknown_attributes','__reject_reason',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)
    self.__origin = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'loc-rib', 'routes', 'route']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/prefix (inet:ipv6-prefix)

    YANG Description: The IPv6 prefix corresponding to the route
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/prefix (inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: The IPv6 prefix corresponding to the route
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv6-prefix""",
          'defined-type': "inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)


  def _get_origin(self):
    """
    Getter method for origin, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/origin (union)

    YANG Description: Indicates the origin of the route.  If the route is learned
from a neighbor, this value is the neighbor address.  If
the route was injected or redistributed from another
protocol, the origin indicates the source protocol for the
route.
    """
    return self.__origin
      
  def _set_origin(self, v, load=False):
    """
    Setter method for origin, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/origin (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_origin is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_origin() directly.

    YANG Description: Indicates the origin of the route.  If the route is learned
from a neighbor, this value is the neighbor address.  If
the route was injected or redistributed from another
protocol, the origin indicates the source protocol for the
route.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """origin must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)""",
        })

    self.__origin = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_origin(self):
    self.__origin = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="origin", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)


  def _get_path_id(self):
    """
    Getter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/path_id (uint32)

    YANG Description: If the route is learned from a neighbor, the path-id
corresponds to the path-id for the route in the
corresponding adj-rib-in-post table.  If the route is
injected from another protocol, or the neighbor does not
support BGP add-paths, the path-id should be set
to zero, also the default value.

However, YANG does not allow default values to be set
for parameters that form the key, so a default value
cannot be set here.
    """
    return self.__path_id
      
  def _set_path_id(self, v, load=False):
    """
    Setter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/path_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_id() directly.

    YANG Description: If the route is learned from a neighbor, the path-id
corresponds to the path-id for the route in the
corresponding adj-rib-in-post table.  If the route is
injected from another protocol, or the neighbor does not
support BGP add-paths, the path-id should be set
to zero, also the default value.

However, YANG does not allow default values to be set
for parameters that form the key, so a default value
cannot be set here.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__path_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_id(self):
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_attr_index(self):
    """
    Getter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/attr_index (leafref)

    YANG Description: Reference to the common attribute group for the
route
    """
    return self.__attr_index
      
  def _set_attr_index(self, v, load=False):
    """
    Setter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/attr_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_index() directly.

    YANG Description: Reference to the common attribute group for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__attr_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_index(self):
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_community_index(self):
    """
    Getter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/community_index (leafref)

    YANG Description: Reference to the community attribute for the route
    """
    return self.__community_index
      
  def _set_community_index(self, v, load=False):
    """
    Setter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_community_index() directly.

    YANG Description: Reference to the community attribute for the route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_community_index(self):
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_ext_community_index(self):
    """
    Getter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/ext_community_index (leafref)

    YANG Description: Reference to the extended community attribute for the
route
    """
    return self.__ext_community_index
      
  def _set_ext_community_index(self, v, load=False):
    """
    Setter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/ext_community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_community_index() directly.

    YANG Description: Reference to the extended community attribute for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__ext_community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_community_index(self):
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_last_modified(self):
    """
    Getter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/last_modified (types:timeticks)

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_modified
      
  def _set_last_modified(self, v, load=False):
    """
    Setter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/last_modified (types:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_modified is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_modified() directly.

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_modified must be of a type compatible with types:timeticks""",
          'defined-type': "types:timeticks",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)""",
        })

    self.__last_modified = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_modified(self):
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)


  def _get_valid_route(self):
    """
    Getter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/valid_route (boolean)

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    return self.__valid_route
      
  def _set_valid_route(self, v, load=False):
    """
    Setter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/valid_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_route() directly.

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__valid_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_route(self):
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_invalid_reason(self):
    """
    Getter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/invalid_reason (identityref)

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    return self.__invalid_reason
      
  def _set_invalid_reason(self, v, load=False):
    """
    Setter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/invalid_reason (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invalid_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invalid_reason() directly.

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invalid_reason must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)""",
        })

    self.__invalid_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invalid_reason(self):
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)


  def _get_unknown_attributes(self):
    """
    Getter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes (container)

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    return self.__unknown_attributes
      
  def _set_unknown_attributes(self, v, load=False):
    """
    Setter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/unknown_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attributes() directly.

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attributes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__unknown_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attributes(self):
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_reject_reason(self):
    """
    Getter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/reject_reason (union)

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    return self.__reject_reason
      
  def _set_reject_reason(self, v, load=False):
    """
    Setter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route/reject_reason (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reject_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reject_reason() directly.

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reject_reason must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)""",
        })

    self.__reject_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reject_reason(self):
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  origin = __builtin__.property(_get_origin)
  path_id = __builtin__.property(_get_path_id)
  attr_index = __builtin__.property(_get_attr_index)
  community_index = __builtin__.property(_get_community_index)
  ext_community_index = __builtin__.property(_get_ext_community_index)
  last_modified = __builtin__.property(_get_last_modified)
  valid_route = __builtin__.property(_get_valid_route)
  invalid_reason = __builtin__.property(_get_invalid_reason)
  unknown_attributes = __builtin__.property(_get_unknown_attributes) # type: yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route_unknown_attributes
  reject_reason = __builtin__.property(_get_reject_reason)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('origin', origin), ('path_id', path_id), ('attr_index', attr_index), ('community_index', community_index), ('ext_community_index', ext_community_index), ('last_modified', last_modified), ('valid_route', valid_route), ('invalid_reason', invalid_reason), ('unknown_attributes', unknown_attributes), ('reject_reason', reject_reason), ])


class yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/loc-rib/routes/clear-routes/clear/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_at',)

  _yang_name = 'input'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'loc-rib', 'routes', 'clear-routes', 'clear', 'input']

  def _get_clear_at(self):
    """
    Getter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/clear_routes/clear/input/clear_at (yang:date-and-time)

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    return self.__clear_at
      
  def _set_clear_at(self, v, load=False):
    """
    Setter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/clear_routes/clear/input/clear_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_at() directly.

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_at(self):
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_at = __builtin__.property(_get_clear_at)


  _pyangbind_elements = OrderedDict([('clear_at', clear_at), ])


class yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/loc-rib/routes/clear-routes/clear/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_finished_at',)

  _yang_name = 'output'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'loc-rib', 'routes', 'clear-routes', 'clear', 'output']

  def _get_clear_finished_at(self):
    """
    Getter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)

    YANG Description: The time when the clear operation finished.
    """
    return self.__clear_finished_at
      
  def _set_clear_finished_at(self, v, load=False):
    """
    Setter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_finished_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_finished_at() directly.

    YANG Description: The time when the clear operation finished.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_finished_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_finished_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_finished_at(self):
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_finished_at = __builtin__.property(_get_clear_finished_at)


  _pyangbind_elements = OrderedDict([('clear_finished_at', clear_finished_at), ])


class yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/loc-rib/routes/clear-routes/clear. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__output',)

  _yang_name = 'clear'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'loc-rib', 'routes', 'clear-routes', 'clear']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/clear_routes/clear/input (input)
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/clear_routes/clear/input (input)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with input""",
          'defined-type': "ietf-bgp:input",
          'generated-type': """YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)


  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/clear_routes/clear/output (output)
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/clear_routes/clear/output (output)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with output""",
          'defined-type': "ietf-bgp:output",
          'generated-type': """YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

  input = __builtin__.property(_get_input)
  output = __builtin__.property(_get_output)


  _pyangbind_elements = OrderedDict([('input', input), ('output', output), ])


class yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/loc-rib/routes/clear-routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Action commands to clear routes governed by a if-feature.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear',)

  _yang_name = 'clear-routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'loc-rib', 'routes', 'clear-routes']

  def _get_clear(self):
    """
    Getter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/clear_routes/clear (action)
    """
    return self.__clear
      
  def _set_clear(self, v, load=False):
    """
    Setter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/clear_routes/clear (action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear must be of a type compatible with action""",
          'defined-type': "ietf-bgp:action",
          'generated-type': """YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)""",
        })

    self.__clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear(self):
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

  clear = __builtin__.property(_get_clear)


  _pyangbind_elements = OrderedDict([('clear', clear), ])


class yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/loc-rib/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of routes in the routing
table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route','__clear_routes',)

  _yang_name = 'routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType("prefix origin path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix origin path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'loc-rib', 'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route (list)

    YANG Description: List of routes in the table, keyed by the route
prefix, the route origin, and path-id.  The route
origin can be either the neighbor address from which
the route was learned, or the source protocol that
injected the route.  The path-id distinguishes routes
for the same prefix received from a neighbor (e.g.,
if add-paths is enabled).
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: List of routes in the table, keyed by the route
prefix, the route origin, and path-id.  The route
origin can be either the neighbor address from which
the route was learned, or the source protocol that
injected the route.  The path-id distinguishes routes
for the same prefix received from a neighbor (e.g.,
if add-paths is enabled).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix origin path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix origin path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix origin path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix origin path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType("prefix origin path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix origin path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)


  def _get_clear_routes(self):
    """
    Getter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/clear_routes (container)

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    return self.__clear_routes
      
  def _set_clear_routes(self, v, load=False):
    """
    Setter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes/clear_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_routes() directly.

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__clear_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_routes(self):
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_route
  clear_routes = __builtin__.property(_get_clear_routes) # type: yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes_clear_routes


  _pyangbind_elements = OrderedDict([('route', route), ('clear_routes', clear_routes), ])


class yc_loc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/loc-rib. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the IPv6 BGP LOC-RIB data
  """
  __slots__ = ('_path_helper', '_extmethods', '__routes',)

  _yang_name = 'loc-rib'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'loc-rib']

  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes (container)

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  routes = __builtin__.property(_get_routes) # type: yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib_routes


  _pyangbind_elements = OrderedDict([('routes', routes), ])


class yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes_unknown_attribute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-in-pre/routes/route/unknown-attributes/unknown-attribute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optional','__transitive','__partial','__extended','__attr_type','__attr_len','__attr_value',)

  _yang_name = 'unknown-attribute'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes', 'route', 'unknown-attributes', 'unknown-attribute']

  def _get_optional(self):
    """
    Getter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/optional (boolean)

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    return self.__optional
      
  def _set_optional(self, v, load=False):
    """
    Setter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/optional (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optional() directly.

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optional must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__optional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optional(self):
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_transitive(self):
    """
    Getter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    return self.__transitive
      
  def _set_transitive(self, v, load=False):
    """
    Setter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transitive() directly.

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transitive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__transitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transitive(self):
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_partial(self):
    """
    Getter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/partial (boolean)

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    return self.__partial
      
  def _set_partial(self, v, load=False):
    """
    Setter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/partial (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partial is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partial() directly.

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partial must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__partial = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partial(self):
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_extended(self):
    """
    Getter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/extended (boolean)

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    return self.__extended
      
  def _set_extended(self, v, load=False):
    """
    Setter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/extended (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended() directly.

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__extended = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended(self):
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_attr_type(self):
    """
    Getter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)

    YANG Description: 1-octet value encoding the attribute type code
    """
    return self.__attr_type
      
  def _set_attr_type(self, v, load=False):
    """
    Setter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_type() directly.

    YANG Description: 1-octet value encoding the attribute type code
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__attr_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_type(self):
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)


  def _get_attr_len(self):
    """
    Getter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    return self.__attr_len
      
  def _set_attr_len(self, v, load=False):
    """
    Setter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_len is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_len() directly.

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_len must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)""",
        })

    self.__attr_len = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_len(self):
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)


  def _get_attr_value(self):
    """
    Getter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    return self.__attr_value
      
  def _set_attr_value(self, v, load=False):
    """
    Setter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_value() directly.

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_value must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)""",
        })

    self.__attr_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_value(self):
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

  optional = __builtin__.property(_get_optional)
  transitive = __builtin__.property(_get_transitive)
  partial = __builtin__.property(_get_partial)
  extended = __builtin__.property(_get_extended)
  attr_type = __builtin__.property(_get_attr_type)
  attr_len = __builtin__.property(_get_attr_len)
  attr_value = __builtin__.property(_get_attr_value)


  _pyangbind_elements = OrderedDict([('optional', optional), ('transitive', transitive), ('partial', partial), ('extended', extended), ('attr_type', attr_type), ('attr_len', attr_len), ('attr_value', attr_value), ])


class yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-in-pre/routes/route/unknown-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__unknown_attribute',)

  _yang_name = 'unknown-attributes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes', 'route', 'unknown-attributes']

  def _get_unknown_attribute(self):
    """
    Getter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute (list)

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    return self.__unknown_attribute
      
  def _set_unknown_attribute(self, v, load=False):
    """
    Setter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes/unknown_attribute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attribute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attribute() directly.

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attribute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__unknown_attribute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attribute(self):
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  unknown_attribute = __builtin__.property(_get_unknown_attribute) # type: yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes_unknown_attribute


  _pyangbind_elements = OrderedDict([('unknown_attribute', unknown_attribute), ])


class yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-in-pre/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of routes in the table
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__path_id','__attr_index','__community_index','__ext_community_index','__last_modified','__valid_route','__invalid_reason','__unknown_attributes','__reject_reason',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes', 'route']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/prefix (inet:ipv6-prefix)

    YANG Description: Prefix for the route
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/prefix (inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Prefix for the route
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv6-prefix""",
          'defined-type': "inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)


  def _get_path_id(self):
    """
    Getter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/path_id (uint32)

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    return self.__path_id
      
  def _set_path_id(self, v, load=False):
    """
    Setter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/path_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_id() directly.

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__path_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_id(self):
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_attr_index(self):
    """
    Getter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/attr_index (leafref)

    YANG Description: Reference to the common attribute group for the
route
    """
    return self.__attr_index
      
  def _set_attr_index(self, v, load=False):
    """
    Setter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/attr_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_index() directly.

    YANG Description: Reference to the common attribute group for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__attr_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_index(self):
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_community_index(self):
    """
    Getter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/community_index (leafref)

    YANG Description: Reference to the community attribute for the route
    """
    return self.__community_index
      
  def _set_community_index(self, v, load=False):
    """
    Setter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_community_index() directly.

    YANG Description: Reference to the community attribute for the route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_community_index(self):
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_ext_community_index(self):
    """
    Getter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/ext_community_index (leafref)

    YANG Description: Reference to the extended community attribute for the
route
    """
    return self.__ext_community_index
      
  def _set_ext_community_index(self, v, load=False):
    """
    Setter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/ext_community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_community_index() directly.

    YANG Description: Reference to the extended community attribute for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__ext_community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_community_index(self):
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_last_modified(self):
    """
    Getter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/last_modified (types:timeticks)

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_modified
      
  def _set_last_modified(self, v, load=False):
    """
    Setter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/last_modified (types:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_modified is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_modified() directly.

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_modified must be of a type compatible with types:timeticks""",
          'defined-type': "types:timeticks",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)""",
        })

    self.__last_modified = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_modified(self):
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)


  def _get_valid_route(self):
    """
    Getter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/valid_route (boolean)

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    return self.__valid_route
      
  def _set_valid_route(self, v, load=False):
    """
    Setter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/valid_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_route() directly.

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__valid_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_route(self):
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_invalid_reason(self):
    """
    Getter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/invalid_reason (identityref)

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    return self.__invalid_reason
      
  def _set_invalid_reason(self, v, load=False):
    """
    Setter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/invalid_reason (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invalid_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invalid_reason() directly.

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invalid_reason must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)""",
        })

    self.__invalid_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invalid_reason(self):
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)


  def _get_unknown_attributes(self):
    """
    Getter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes (container)

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    return self.__unknown_attributes
      
  def _set_unknown_attributes(self, v, load=False):
    """
    Setter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/unknown_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attributes() directly.

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attributes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__unknown_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attributes(self):
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_reject_reason(self):
    """
    Getter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/reject_reason (union)

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    return self.__reject_reason
      
  def _set_reject_reason(self, v, load=False):
    """
    Setter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route/reject_reason (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reject_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reject_reason() directly.

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reject_reason must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)""",
        })

    self.__reject_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reject_reason(self):
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  path_id = __builtin__.property(_get_path_id)
  attr_index = __builtin__.property(_get_attr_index)
  community_index = __builtin__.property(_get_community_index)
  ext_community_index = __builtin__.property(_get_ext_community_index)
  last_modified = __builtin__.property(_get_last_modified)
  valid_route = __builtin__.property(_get_valid_route)
  invalid_reason = __builtin__.property(_get_invalid_reason)
  unknown_attributes = __builtin__.property(_get_unknown_attributes) # type: yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route_unknown_attributes
  reject_reason = __builtin__.property(_get_reject_reason)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('path_id', path_id), ('attr_index', attr_index), ('community_index', community_index), ('ext_community_index', ext_community_index), ('last_modified', last_modified), ('valid_route', valid_route), ('invalid_reason', invalid_reason), ('unknown_attributes', unknown_attributes), ('reject_reason', reject_reason), ])


class yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-in-pre/routes/clear-routes/clear/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_at',)

  _yang_name = 'input'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes', 'clear-routes', 'clear', 'input']

  def _get_clear_at(self):
    """
    Getter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/input/clear_at (yang:date-and-time)

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    return self.__clear_at
      
  def _set_clear_at(self, v, load=False):
    """
    Setter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/input/clear_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_at() directly.

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_at(self):
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_at = __builtin__.property(_get_clear_at)


  _pyangbind_elements = OrderedDict([('clear_at', clear_at), ])


class yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-in-pre/routes/clear-routes/clear/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_finished_at',)

  _yang_name = 'output'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes', 'clear-routes', 'clear', 'output']

  def _get_clear_finished_at(self):
    """
    Getter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)

    YANG Description: The time when the clear operation finished.
    """
    return self.__clear_finished_at
      
  def _set_clear_finished_at(self, v, load=False):
    """
    Setter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_finished_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_finished_at() directly.

    YANG Description: The time when the clear operation finished.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_finished_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_finished_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_finished_at(self):
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_finished_at = __builtin__.property(_get_clear_finished_at)


  _pyangbind_elements = OrderedDict([('clear_finished_at', clear_finished_at), ])


class yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-in-pre/routes/clear-routes/clear. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__output',)

  _yang_name = 'clear'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes', 'clear-routes', 'clear']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/input (input)
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/input (input)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with input""",
          'defined-type': "ietf-bgp:input",
          'generated-type': """YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)


  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/output (output)
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear/output (output)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with output""",
          'defined-type': "ietf-bgp:output",
          'generated-type': """YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

  input = __builtin__.property(_get_input)
  output = __builtin__.property(_get_output)


  _pyangbind_elements = OrderedDict([('input', input), ('output', output), ])


class yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-in-pre/routes/clear-routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Action commands to clear routes governed by a if-feature.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear',)

  _yang_name = 'clear-routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes', 'clear-routes']

  def _get_clear(self):
    """
    Getter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear (action)
    """
    return self.__clear
      
  def _set_clear(self, v, load=False):
    """
    Setter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes/clear (action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear must be of a type compatible with action""",
          'defined-type': "ietf-bgp:action",
          'generated-type': """YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)""",
        })

    self.__clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear(self):
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

  clear = __builtin__.property(_get_clear)


  _pyangbind_elements = OrderedDict([('clear', clear), ])


class yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-in-pre/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of routes in the routing
table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route','__clear_routes',)

  _yang_name = 'routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre', 'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route (list)

    YANG Description: List of routes in the table
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: List of routes in the table
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)


  def _get_clear_routes(self):
    """
    Getter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes (container)

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    return self.__clear_routes
      
  def _set_clear_routes(self, v, load=False):
    """
    Setter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes/clear_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_routes() directly.

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__clear_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_routes(self):
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_route
  clear_routes = __builtin__.property(_get_clear_routes) # type: yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes_clear_routes


  _pyangbind_elements = OrderedDict([('route', route), ('clear_routes', clear_routes), ])


class yc_adj_rib_in_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-in-pre. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-neighbor table containing the NLRI updates
received from the neighbor before any local input
policy rules or filters have been applied.  This can
be considered the 'raw' updates from the neighbor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routes',)

  _yang_name = 'adj-rib-in-pre'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-in-pre']

  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes (container)

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  routes = __builtin__.property(_get_routes) # type: yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre_routes


  _pyangbind_elements = OrderedDict([('routes', routes), ])


class yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes_unknown_attribute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-in-post/routes/route/unknown-attributes/unknown-attribute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optional','__transitive','__partial','__extended','__attr_type','__attr_len','__attr_value',)

  _yang_name = 'unknown-attribute'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-in-post', 'routes', 'route', 'unknown-attributes', 'unknown-attribute']

  def _get_optional(self):
    """
    Getter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/optional (boolean)

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    return self.__optional
      
  def _set_optional(self, v, load=False):
    """
    Setter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/optional (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optional() directly.

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optional must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__optional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optional(self):
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_transitive(self):
    """
    Getter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    return self.__transitive
      
  def _set_transitive(self, v, load=False):
    """
    Setter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transitive() directly.

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transitive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__transitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transitive(self):
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_partial(self):
    """
    Getter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/partial (boolean)

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    return self.__partial
      
  def _set_partial(self, v, load=False):
    """
    Setter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/partial (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partial is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partial() directly.

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partial must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__partial = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partial(self):
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_extended(self):
    """
    Getter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/extended (boolean)

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    return self.__extended
      
  def _set_extended(self, v, load=False):
    """
    Setter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/extended (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended() directly.

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__extended = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended(self):
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_attr_type(self):
    """
    Getter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)

    YANG Description: 1-octet value encoding the attribute type code
    """
    return self.__attr_type
      
  def _set_attr_type(self, v, load=False):
    """
    Setter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_type() directly.

    YANG Description: 1-octet value encoding the attribute type code
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__attr_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_type(self):
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)


  def _get_attr_len(self):
    """
    Getter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    return self.__attr_len
      
  def _set_attr_len(self, v, load=False):
    """
    Setter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_len is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_len() directly.

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_len must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)""",
        })

    self.__attr_len = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_len(self):
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)


  def _get_attr_value(self):
    """
    Getter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    return self.__attr_value
      
  def _set_attr_value(self, v, load=False):
    """
    Setter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_value() directly.

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_value must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)""",
        })

    self.__attr_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_value(self):
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

  optional = __builtin__.property(_get_optional)
  transitive = __builtin__.property(_get_transitive)
  partial = __builtin__.property(_get_partial)
  extended = __builtin__.property(_get_extended)
  attr_type = __builtin__.property(_get_attr_type)
  attr_len = __builtin__.property(_get_attr_len)
  attr_value = __builtin__.property(_get_attr_value)


  _pyangbind_elements = OrderedDict([('optional', optional), ('transitive', transitive), ('partial', partial), ('extended', extended), ('attr_type', attr_type), ('attr_len', attr_len), ('attr_value', attr_value), ])


class yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-in-post/routes/route/unknown-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__unknown_attribute',)

  _yang_name = 'unknown-attributes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-in-post', 'routes', 'route', 'unknown-attributes']

  def _get_unknown_attribute(self):
    """
    Getter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute (list)

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    return self.__unknown_attribute
      
  def _set_unknown_attribute(self, v, load=False):
    """
    Setter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes/unknown_attribute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attribute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attribute() directly.

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attribute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__unknown_attribute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attribute(self):
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  unknown_attribute = __builtin__.property(_get_unknown_attribute) # type: yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes_unknown_attribute


  _pyangbind_elements = OrderedDict([('unknown_attribute', unknown_attribute), ])


class yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-in-post/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of routes in the table
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__path_id','__attr_index','__community_index','__ext_community_index','__last_modified','__valid_route','__invalid_reason','__best_path','__unknown_attributes','__reject_reason',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    self.__best_path = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="best-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-in-post', 'routes', 'route']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/prefix (inet:ipv6-prefix)

    YANG Description: Prefix for the route
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/prefix (inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Prefix for the route
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv6-prefix""",
          'defined-type': "inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)


  def _get_path_id(self):
    """
    Getter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/path_id (uint32)

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    return self.__path_id
      
  def _set_path_id(self, v, load=False):
    """
    Setter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/path_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_id() directly.

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__path_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_id(self):
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_attr_index(self):
    """
    Getter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/attr_index (leafref)

    YANG Description: Reference to the common attribute group for the
route
    """
    return self.__attr_index
      
  def _set_attr_index(self, v, load=False):
    """
    Setter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/attr_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_index() directly.

    YANG Description: Reference to the common attribute group for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__attr_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_index(self):
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_community_index(self):
    """
    Getter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/community_index (leafref)

    YANG Description: Reference to the community attribute for the route
    """
    return self.__community_index
      
  def _set_community_index(self, v, load=False):
    """
    Setter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_community_index() directly.

    YANG Description: Reference to the community attribute for the route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_community_index(self):
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_ext_community_index(self):
    """
    Getter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/ext_community_index (leafref)

    YANG Description: Reference to the extended community attribute for the
route
    """
    return self.__ext_community_index
      
  def _set_ext_community_index(self, v, load=False):
    """
    Setter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/ext_community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_community_index() directly.

    YANG Description: Reference to the extended community attribute for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__ext_community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_community_index(self):
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_last_modified(self):
    """
    Getter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/last_modified (types:timeticks)

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_modified
      
  def _set_last_modified(self, v, load=False):
    """
    Setter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/last_modified (types:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_modified is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_modified() directly.

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_modified must be of a type compatible with types:timeticks""",
          'defined-type': "types:timeticks",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)""",
        })

    self.__last_modified = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_modified(self):
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)


  def _get_valid_route(self):
    """
    Getter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/valid_route (boolean)

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    return self.__valid_route
      
  def _set_valid_route(self, v, load=False):
    """
    Setter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/valid_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_route() directly.

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__valid_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_route(self):
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_invalid_reason(self):
    """
    Getter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/invalid_reason (identityref)

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    return self.__invalid_reason
      
  def _set_invalid_reason(self, v, load=False):
    """
    Setter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/invalid_reason (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invalid_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invalid_reason() directly.

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invalid_reason must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)""",
        })

    self.__invalid_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invalid_reason(self):
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)


  def _get_best_path(self):
    """
    Getter method for best_path, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/best_path (boolean)

    YANG Description: Current path was selected as the best path.
    """
    return self.__best_path
      
  def _set_best_path(self, v, load=False):
    """
    Setter method for best_path, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/best_path (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_best_path is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_best_path() directly.

    YANG Description: Current path was selected as the best path.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="best-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """best_path must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="best-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__best_path = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_best_path(self):
    self.__best_path = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="best-path", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_unknown_attributes(self):
    """
    Getter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes (container)

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    return self.__unknown_attributes
      
  def _set_unknown_attributes(self, v, load=False):
    """
    Setter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/unknown_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attributes() directly.

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attributes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__unknown_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attributes(self):
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_reject_reason(self):
    """
    Getter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/reject_reason (union)

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    return self.__reject_reason
      
  def _set_reject_reason(self, v, load=False):
    """
    Setter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route/reject_reason (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reject_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reject_reason() directly.

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reject_reason must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)""",
        })

    self.__reject_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reject_reason(self):
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  path_id = __builtin__.property(_get_path_id)
  attr_index = __builtin__.property(_get_attr_index)
  community_index = __builtin__.property(_get_community_index)
  ext_community_index = __builtin__.property(_get_ext_community_index)
  last_modified = __builtin__.property(_get_last_modified)
  valid_route = __builtin__.property(_get_valid_route)
  invalid_reason = __builtin__.property(_get_invalid_reason)
  best_path = __builtin__.property(_get_best_path)
  unknown_attributes = __builtin__.property(_get_unknown_attributes) # type: yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route_unknown_attributes
  reject_reason = __builtin__.property(_get_reject_reason)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('path_id', path_id), ('attr_index', attr_index), ('community_index', community_index), ('ext_community_index', ext_community_index), ('last_modified', last_modified), ('valid_route', valid_route), ('invalid_reason', invalid_reason), ('best_path', best_path), ('unknown_attributes', unknown_attributes), ('reject_reason', reject_reason), ])


class yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-in-post/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of routes in the routing
table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-in-post', 'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route (list)

    YANG Description: List of routes in the table
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: List of routes in the table
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes_route


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_adj_rib_in_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-in-post. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-neighbor table containing the paths received from
the neighbor that are eligible for best-path selection
after local input policy rules have been applied.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routes',)

  _yang_name = 'adj-rib-in-post'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-in-post']

  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes (container)

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  routes = __builtin__.property(_get_routes) # type: yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post_routes


  _pyangbind_elements = OrderedDict([('routes', routes), ])


class yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes_unknown_attribute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-pre/routes/route/unknown-attributes/unknown-attribute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optional','__transitive','__partial','__extended','__attr_type','__attr_len','__attr_value',)

  _yang_name = 'unknown-attribute'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes', 'route', 'unknown-attributes', 'unknown-attribute']

  def _get_optional(self):
    """
    Getter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/optional (boolean)

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    return self.__optional
      
  def _set_optional(self, v, load=False):
    """
    Setter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/optional (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optional() directly.

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optional must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__optional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optional(self):
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_transitive(self):
    """
    Getter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    return self.__transitive
      
  def _set_transitive(self, v, load=False):
    """
    Setter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transitive() directly.

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transitive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__transitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transitive(self):
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_partial(self):
    """
    Getter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/partial (boolean)

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    return self.__partial
      
  def _set_partial(self, v, load=False):
    """
    Setter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/partial (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partial is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partial() directly.

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partial must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__partial = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partial(self):
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_extended(self):
    """
    Getter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/extended (boolean)

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    return self.__extended
      
  def _set_extended(self, v, load=False):
    """
    Setter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/extended (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended() directly.

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__extended = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended(self):
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_attr_type(self):
    """
    Getter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)

    YANG Description: 1-octet value encoding the attribute type code
    """
    return self.__attr_type
      
  def _set_attr_type(self, v, load=False):
    """
    Setter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_type() directly.

    YANG Description: 1-octet value encoding the attribute type code
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__attr_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_type(self):
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)


  def _get_attr_len(self):
    """
    Getter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    return self.__attr_len
      
  def _set_attr_len(self, v, load=False):
    """
    Setter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_len is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_len() directly.

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_len must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)""",
        })

    self.__attr_len = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_len(self):
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)


  def _get_attr_value(self):
    """
    Getter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    return self.__attr_value
      
  def _set_attr_value(self, v, load=False):
    """
    Setter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_value() directly.

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_value must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)""",
        })

    self.__attr_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_value(self):
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

  optional = __builtin__.property(_get_optional)
  transitive = __builtin__.property(_get_transitive)
  partial = __builtin__.property(_get_partial)
  extended = __builtin__.property(_get_extended)
  attr_type = __builtin__.property(_get_attr_type)
  attr_len = __builtin__.property(_get_attr_len)
  attr_value = __builtin__.property(_get_attr_value)


  _pyangbind_elements = OrderedDict([('optional', optional), ('transitive', transitive), ('partial', partial), ('extended', extended), ('attr_type', attr_type), ('attr_len', attr_len), ('attr_value', attr_value), ])


class yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-pre/routes/route/unknown-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__unknown_attribute',)

  _yang_name = 'unknown-attributes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes', 'route', 'unknown-attributes']

  def _get_unknown_attribute(self):
    """
    Getter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute (list)

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    return self.__unknown_attribute
      
  def _set_unknown_attribute(self, v, load=False):
    """
    Setter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes/unknown_attribute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attribute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attribute() directly.

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attribute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__unknown_attribute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attribute(self):
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  unknown_attribute = __builtin__.property(_get_unknown_attribute) # type: yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes_unknown_attribute


  _pyangbind_elements = OrderedDict([('unknown_attribute', unknown_attribute), ])


class yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-pre/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of routes in the table
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__path_id','__attr_index','__community_index','__ext_community_index','__last_modified','__valid_route','__invalid_reason','__unknown_attributes','__reject_reason',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes', 'route']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/prefix (inet:ipv6-prefix)

    YANG Description: Prefix for the route
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/prefix (inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Prefix for the route
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv6-prefix""",
          'defined-type': "inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)


  def _get_path_id(self):
    """
    Getter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/path_id (uint32)

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    return self.__path_id
      
  def _set_path_id(self, v, load=False):
    """
    Setter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/path_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_id() directly.

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__path_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_id(self):
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_attr_index(self):
    """
    Getter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/attr_index (leafref)

    YANG Description: Reference to the common attribute group for the
route
    """
    return self.__attr_index
      
  def _set_attr_index(self, v, load=False):
    """
    Setter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/attr_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_index() directly.

    YANG Description: Reference to the common attribute group for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__attr_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_index(self):
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_community_index(self):
    """
    Getter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/community_index (leafref)

    YANG Description: Reference to the community attribute for the route
    """
    return self.__community_index
      
  def _set_community_index(self, v, load=False):
    """
    Setter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_community_index() directly.

    YANG Description: Reference to the community attribute for the route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_community_index(self):
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_ext_community_index(self):
    """
    Getter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/ext_community_index (leafref)

    YANG Description: Reference to the extended community attribute for the
route
    """
    return self.__ext_community_index
      
  def _set_ext_community_index(self, v, load=False):
    """
    Setter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/ext_community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_community_index() directly.

    YANG Description: Reference to the extended community attribute for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__ext_community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_community_index(self):
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_last_modified(self):
    """
    Getter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/last_modified (types:timeticks)

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_modified
      
  def _set_last_modified(self, v, load=False):
    """
    Setter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/last_modified (types:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_modified is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_modified() directly.

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_modified must be of a type compatible with types:timeticks""",
          'defined-type': "types:timeticks",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)""",
        })

    self.__last_modified = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_modified(self):
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)


  def _get_valid_route(self):
    """
    Getter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/valid_route (boolean)

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    return self.__valid_route
      
  def _set_valid_route(self, v, load=False):
    """
    Setter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/valid_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_route() directly.

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__valid_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_route(self):
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_invalid_reason(self):
    """
    Getter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/invalid_reason (identityref)

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    return self.__invalid_reason
      
  def _set_invalid_reason(self, v, load=False):
    """
    Setter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/invalid_reason (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invalid_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invalid_reason() directly.

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invalid_reason must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)""",
        })

    self.__invalid_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invalid_reason(self):
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)


  def _get_unknown_attributes(self):
    """
    Getter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes (container)

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    return self.__unknown_attributes
      
  def _set_unknown_attributes(self, v, load=False):
    """
    Setter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/unknown_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attributes() directly.

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attributes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__unknown_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attributes(self):
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_reject_reason(self):
    """
    Getter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/reject_reason (union)

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    return self.__reject_reason
      
  def _set_reject_reason(self, v, load=False):
    """
    Setter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route/reject_reason (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reject_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reject_reason() directly.

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reject_reason must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)""",
        })

    self.__reject_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reject_reason(self):
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  path_id = __builtin__.property(_get_path_id)
  attr_index = __builtin__.property(_get_attr_index)
  community_index = __builtin__.property(_get_community_index)
  ext_community_index = __builtin__.property(_get_ext_community_index)
  last_modified = __builtin__.property(_get_last_modified)
  valid_route = __builtin__.property(_get_valid_route)
  invalid_reason = __builtin__.property(_get_invalid_reason)
  unknown_attributes = __builtin__.property(_get_unknown_attributes) # type: yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route_unknown_attributes
  reject_reason = __builtin__.property(_get_reject_reason)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('path_id', path_id), ('attr_index', attr_index), ('community_index', community_index), ('ext_community_index', ext_community_index), ('last_modified', last_modified), ('valid_route', valid_route), ('invalid_reason', invalid_reason), ('unknown_attributes', unknown_attributes), ('reject_reason', reject_reason), ])


class yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-pre/routes/clear-routes/clear/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_at',)

  _yang_name = 'input'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes', 'clear-routes', 'clear', 'input']

  def _get_clear_at(self):
    """
    Getter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/input/clear_at (yang:date-and-time)

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    return self.__clear_at
      
  def _set_clear_at(self, v, load=False):
    """
    Setter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/input/clear_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_at() directly.

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_at(self):
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_at = __builtin__.property(_get_clear_at)


  _pyangbind_elements = OrderedDict([('clear_at', clear_at), ])


class yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-pre/routes/clear-routes/clear/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_finished_at',)

  _yang_name = 'output'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes', 'clear-routes', 'clear', 'output']

  def _get_clear_finished_at(self):
    """
    Getter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)

    YANG Description: The time when the clear operation finished.
    """
    return self.__clear_finished_at
      
  def _set_clear_finished_at(self, v, load=False):
    """
    Setter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_finished_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_finished_at() directly.

    YANG Description: The time when the clear operation finished.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_finished_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_finished_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_finished_at(self):
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_finished_at = __builtin__.property(_get_clear_finished_at)


  _pyangbind_elements = OrderedDict([('clear_finished_at', clear_finished_at), ])


class yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-pre/routes/clear-routes/clear. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__output',)

  _yang_name = 'clear'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes', 'clear-routes', 'clear']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/input (input)
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/input (input)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with input""",
          'defined-type': "ietf-bgp:input",
          'generated-type': """YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)


  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/output (output)
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear/output (output)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with output""",
          'defined-type': "ietf-bgp:output",
          'generated-type': """YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

  input = __builtin__.property(_get_input)
  output = __builtin__.property(_get_output)


  _pyangbind_elements = OrderedDict([('input', input), ('output', output), ])


class yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-pre/routes/clear-routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Action commands to clear routes governed by a if-feature.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear',)

  _yang_name = 'clear-routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes', 'clear-routes']

  def _get_clear(self):
    """
    Getter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear (action)
    """
    return self.__clear
      
  def _set_clear(self, v, load=False):
    """
    Setter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes/clear (action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear must be of a type compatible with action""",
          'defined-type': "ietf-bgp:action",
          'generated-type': """YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)""",
        })

    self.__clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear(self):
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

  clear = __builtin__.property(_get_clear)


  _pyangbind_elements = OrderedDict([('clear', clear), ])


class yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-pre/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of routes in the routing
table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route','__clear_routes',)

  _yang_name = 'routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre', 'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route (list)

    YANG Description: List of routes in the table
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: List of routes in the table
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)


  def _get_clear_routes(self):
    """
    Getter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes (container)

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    return self.__clear_routes
      
  def _set_clear_routes(self, v, load=False):
    """
    Setter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes/clear_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_routes() directly.

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__clear_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_routes(self):
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_route
  clear_routes = __builtin__.property(_get_clear_routes) # type: yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes_clear_routes


  _pyangbind_elements = OrderedDict([('route', route), ('clear_routes', clear_routes), ])


class yc_adj_rib_out_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-pre. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-neighbor table containing paths eligble for
sending (advertising) to the neighbor before output
policy rules have been applied
  """
  __slots__ = ('_path_helper', '_extmethods', '__routes',)

  _yang_name = 'adj-rib-out-pre'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-pre']

  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes (container)

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  routes = __builtin__.property(_get_routes) # type: yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre_routes


  _pyangbind_elements = OrderedDict([('routes', routes), ])


class yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes_unknown_attribute(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-post/routes/route/unknown-attributes/unknown-attribute. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optional','__transitive','__partial','__extended','__attr_type','__attr_len','__attr_value',)

  _yang_name = 'unknown-attribute'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes', 'route', 'unknown-attributes', 'unknown-attribute']

  def _get_optional(self):
    """
    Getter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/optional (boolean)

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    return self.__optional
      
  def _set_optional(self, v, load=False):
    """
    Setter method for optional, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/optional (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optional is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optional() directly.

    YANG Description: Defines whether the attribute is optional (if
set to true) or well-known (if set to false).
Set in the high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optional must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__optional = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optional(self):
    self.__optional = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="optional", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_transitive(self):
    """
    Getter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    return self.__transitive
      
  def _set_transitive(self, v, load=False):
    """
    Setter method for transitive, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/transitive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transitive() directly.

    YANG Description: Defines whether an optional attribute is transitive
(if set to true) or non-transitive (if set to false).  For
well-known attributes, the transitive flag must be set to
true.  Set in the second high-order bit of the BGP attribute
flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transitive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__transitive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transitive(self):
    self.__transitive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="transitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_partial(self):
    """
    Getter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/partial (boolean)

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    return self.__partial
      
  def _set_partial(self, v, load=False):
    """
    Setter method for partial, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/partial (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partial is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partial() directly.

    YANG Description: Defines whether the information contained in the optional
transitive attribute is partial (if set to true) or complete
(if set to false).  For well-known attributes and for
optional non-transitive attributes, the partial flag
must be set to false.  Set in the third high-order bit of
the BGP attribute flags octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partial must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__partial = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partial(self):
    self.__partial = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="partial", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_extended(self):
    """
    Getter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/extended (boolean)

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    return self.__extended
      
  def _set_extended(self, v, load=False):
    """
    Setter method for extended, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/extended (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extended is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extended() directly.

    YANG Description: Defines whether the attribute length is one octet
(if set to false) or two octets (if set to true).  Set in
the fourth high-order bit of the BGP attribute flags
octet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """extended must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__extended = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_extended(self):
    self.__extended = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="extended", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_attr_type(self):
    """
    Getter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)

    YANG Description: 1-octet value encoding the attribute type code
    """
    return self.__attr_type
      
  def _set_attr_type(self, v, load=False):
    """
    Setter method for attr_type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/attr_type (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_type() directly.

    YANG Description: 1-octet value encoding the attribute type code
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_type must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)""",
        })

    self.__attr_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_type(self):
    self.__attr_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="attr-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint8', is_config=False)


  def _get_attr_len(self):
    """
    Getter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    return self.__attr_len
      
  def _set_attr_len(self, v, load=False):
    """
    Setter method for attr_len, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/attr_len (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_len is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_len() directly.

    YANG Description: One or two octet attribute length field indicating the
length of the attribute data in octets.  If the Extended
Length attribute flag is set, the length field is 2 octets,
otherwise it is 1 octet
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_len must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)""",
        })

    self.__attr_len = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_len(self):
    self.__attr_len = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="attr-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint16', is_config=False)


  def _get_attr_value(self):
    """
    Getter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    return self.__attr_value
      
  def _set_attr_value(self, v, load=False):
    """
    Setter method for attr_value, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute/attr_value (binary)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_value() directly.

    YANG Description: Raw attribute value, not including the attribute
flags, type, or length.  The maximum length
of the attribute value data is 2^16-1 per the max value
of the attr-len field (2 octets).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_value must be of a type compatible with binary""",
          'defined-type': "binary",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)""",
        })

    self.__attr_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_value(self):
    self.__attr_value = YANGDynClass(base=RestrictedClassType(base_type=bitarray, restriction_dict={'length': ['0..65535']}), is_leaf=True, yang_name="attr-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='binary', is_config=False)

  optional = __builtin__.property(_get_optional)
  transitive = __builtin__.property(_get_transitive)
  partial = __builtin__.property(_get_partial)
  extended = __builtin__.property(_get_extended)
  attr_type = __builtin__.property(_get_attr_type)
  attr_len = __builtin__.property(_get_attr_len)
  attr_value = __builtin__.property(_get_attr_value)


  _pyangbind_elements = OrderedDict([('optional', optional), ('transitive', transitive), ('partial', partial), ('extended', extended), ('attr_type', attr_type), ('attr_len', attr_len), ('attr_value', attr_value), ])


class yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-post/routes/route/unknown-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__unknown_attribute',)

  _yang_name = 'unknown-attributes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes', 'route', 'unknown-attributes']

  def _get_unknown_attribute(self):
    """
    Getter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute (list)

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    return self.__unknown_attribute
      
  def _set_unknown_attribute(self, v, load=False):
    """
    Setter method for unknown_attribute, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes/unknown_attribute (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attribute is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attribute() directly.

    YANG Description: This list contains received attributes that are unrecognized
or unsupported by the local router.  The list may be empty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attribute must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__unknown_attribute = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attribute(self):
    self.__unknown_attribute = YANGDynClass(base=YANGListType("attr_type",yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes_unknown_attribute, yang_name="unknown-attribute", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='attr-type', extensions=None), is_container='list', yang_name="unknown-attribute", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  unknown_attribute = __builtin__.property(_get_unknown_attribute) # type: yc_unknown_attribute_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes_unknown_attribute


  _pyangbind_elements = OrderedDict([('unknown_attribute', unknown_attribute), ])


class yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-post/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of routes in the table
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__path_id','__attr_index','__community_index','__ext_community_index','__last_modified','__valid_route','__invalid_reason','__unknown_attributes','__reject_reason',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes', 'route']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/prefix (inet:ipv6-prefix)

    YANG Description: Prefix for the route
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/prefix (inet:ipv6-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Prefix for the route
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv6-prefix""",
          'defined-type': "inet:ipv6-prefix",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ipv6-prefix', is_config=False)


  def _get_path_id(self):
    """
    Getter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/path_id (uint32)

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    return self.__path_id
      
  def _set_path_id(self, v, load=False):
    """
    Setter method for path_id, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/path_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_id() directly.

    YANG Description: When the BGP speaker supports advertisement of multiple
paths for a prefix, the path identifier is used to
uniquely identify a route based on the combination of the
prefix and path id.  In the Adj-RIB-In, the path-id value is
the value received in the update message.   In the Loc-RIB,
if used, it should represent a locally generated path-id
value for the corresponding route.  In Adj-RIB-Out, it
should be the value sent to a neighbor when add-paths is
used, i.e., the capability has been negotiated.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)""",
        })

    self.__path_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_id(self):
    self.__path_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="path-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='uint32', is_config=False)


  def _get_attr_index(self):
    """
    Getter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/attr_index (leafref)

    YANG Description: Reference to the common attribute group for the
route
    """
    return self.__attr_index
      
  def _set_attr_index(self, v, load=False):
    """
    Setter method for attr_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/attr_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_index() directly.

    YANG Description: Reference to the common attribute group for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__attr_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_index(self):
    self.__attr_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="attr-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_community_index(self):
    """
    Getter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/community_index (leafref)

    YANG Description: Reference to the community attribute for the route
    """
    return self.__community_index
      
  def _set_community_index(self, v, load=False):
    """
    Setter method for community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_community_index() directly.

    YANG Description: Reference to the community attribute for the route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_community_index(self):
    self.__community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_ext_community_index(self):
    """
    Getter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/ext_community_index (leafref)

    YANG Description: Reference to the extended community attribute for the
route
    """
    return self.__ext_community_index
      
  def _set_ext_community_index(self, v, load=False):
    """
    Setter method for ext_community_index, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/ext_community_index (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_community_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_community_index() directly.

    YANG Description: Reference to the extended community attribute for the
route
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_community_index must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)""",
        })

    self.__ext_community_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_community_index(self):
    self.__ext_community_index = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-community-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='leafref', is_config=False)


  def _get_last_modified(self):
    """
    Getter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/last_modified (types:timeticks)

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__last_modified
      
  def _set_last_modified(self, v, load=False):
    """
    Setter method for last_modified, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/last_modified (types:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_modified is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_modified() directly.

    YANG Description: Timestamp when this path was last modified.

The value is the timestamp in seconds relative to
the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_modified must be of a type compatible with types:timeticks""",
          'defined-type': "types:timeticks",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)""",
        })

    self.__last_modified = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_modified(self):
    self.__last_modified = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="last-modified", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='types:timeticks', is_config=False)


  def _get_valid_route(self):
    """
    Getter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/valid_route (boolean)

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    return self.__valid_route
      
  def _set_valid_route(self, v, load=False):
    """
    Setter method for valid_route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/valid_route (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_route() directly.

    YANG Description: Indicates that the route is considered valid by the
local router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_route must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)""",
        })

    self.__valid_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_route(self):
    self.__valid_route = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="valid-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='boolean', is_config=False)


  def _get_invalid_reason(self):
    """
    Getter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/invalid_reason (identityref)

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    return self.__invalid_reason
      
  def _set_invalid_reason(self, v, load=False):
    """
    Setter method for invalid_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/invalid_reason (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invalid_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invalid_reason() directly.

    YANG Description: If the route is rejected as invalid, this indicates the
reason.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """invalid_reason must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)""",
        })

    self.__invalid_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_invalid_reason(self):
    self.__invalid_reason = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-cluster-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-as-loop': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-originator': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:invalid-confed': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="invalid-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)


  def _get_unknown_attributes(self):
    """
    Getter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes (container)

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    return self.__unknown_attributes
      
  def _set_unknown_attributes(self, v, load=False):
    """
    Setter method for unknown_attributes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/unknown_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unknown_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unknown_attributes() directly.

    YANG Description: Unknown path attributes that were received in the UPDATE
message which contained the prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unknown_attributes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__unknown_attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unknown_attributes(self):
    self.__unknown_attributes = YANGDynClass(base=yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes, is_container='container', yang_name="unknown-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_reject_reason(self):
    """
    Getter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/reject_reason (union)

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    return self.__reject_reason
      
  def _set_reject_reason(self, v, load=False):
    """
    Setter method for reject_reason, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route/reject_reason (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reject_reason is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reject_reason() directly.

    YANG Description: Indicates the reason the route is not used, either due to
policy filtering or bestpath selection
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reject_reason must be of a type compatible with union""",
          'defined-type': "ietf-bgp:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)""",
        })

    self.__reject_reason = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reject_reason(self):
    self.__reject_reason = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:local-pref-lower': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:as-path-longer': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:origin-type-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:med-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:prefer-external': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:nexthop-cost-higher': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-router-id': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:higher-peer-address': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:rejected-import-policy': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},),], is_leaf=True, yang_name="reject-reason", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='union', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  path_id = __builtin__.property(_get_path_id)
  attr_index = __builtin__.property(_get_attr_index)
  community_index = __builtin__.property(_get_community_index)
  ext_community_index = __builtin__.property(_get_ext_community_index)
  last_modified = __builtin__.property(_get_last_modified)
  valid_route = __builtin__.property(_get_valid_route)
  invalid_reason = __builtin__.property(_get_invalid_reason)
  unknown_attributes = __builtin__.property(_get_unknown_attributes) # type: yc_unknown_attributes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route_unknown_attributes
  reject_reason = __builtin__.property(_get_reject_reason)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('path_id', path_id), ('attr_index', attr_index), ('community_index', community_index), ('ext_community_index', ext_community_index), ('last_modified', last_modified), ('valid_route', valid_route), ('invalid_reason', invalid_reason), ('unknown_attributes', unknown_attributes), ('reject_reason', reject_reason), ])


class yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_input(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-post/routes/clear-routes/clear/input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_at',)

  _yang_name = 'input'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes', 'clear-routes', 'clear', 'input']

  def _get_clear_at(self):
    """
    Getter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/input/clear_at (yang:date-and-time)

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    return self.__clear_at
      
  def _set_clear_at(self, v, load=False):
    """
    Setter method for clear_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/input/clear_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_at() directly.

    YANG Description: The time, in the future when the clear operation will
       be initiated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_at(self):
    self.__clear_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_at = __builtin__.property(_get_clear_at)


  _pyangbind_elements = OrderedDict([('clear_at', clear_at), ])


class yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-post/routes/clear-routes/clear/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear_finished_at',)

  _yang_name = 'output'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes', 'clear-routes', 'clear', 'output']

  def _get_clear_finished_at(self):
    """
    Getter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)

    YANG Description: The time when the clear operation finished.
    """
    return self.__clear_finished_at
      
  def _set_clear_finished_at(self, v, load=False):
    """
    Setter method for clear_finished_at, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/output/clear_finished_at (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_finished_at is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_finished_at() directly.

    YANG Description: The time when the clear operation finished.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_finished_at must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__clear_finished_at = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_finished_at(self):
    self.__clear_finished_at = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="clear-finished-at", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='yang:date-and-time', is_config=False)

  clear_finished_at = __builtin__.property(_get_clear_finished_at)


  _pyangbind_elements = OrderedDict([('clear_finished_at', clear_finished_at), ])


class yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-post/routes/clear-routes/clear. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input','__output',)

  _yang_name = 'clear'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes', 'clear-routes', 'clear']

  def _get_input(self):
    """
    Getter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/input (input)
    """
    return self.__input
      
  def _set_input(self, v, load=False):
    """
    Setter method for input, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/input (input)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input must be of a type compatible with input""",
          'defined-type': "ietf-bgp:input",
          'generated-type': """YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)""",
        })

    self.__input = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input(self):
    self.__input = YANGDynClass(base=yc_input_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_input, is_leaf=True, yang_name="input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='input', is_config=False)


  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/output (output)
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear/output (output)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with output""",
          'defined-type': "ietf-bgp:output",
          'generated-type': """YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='output', is_config=False)

  input = __builtin__.property(_get_input)
  output = __builtin__.property(_get_output)


  _pyangbind_elements = OrderedDict([('input', input), ('output', output), ])


class yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-post/routes/clear-routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Action commands to clear routes governed by a if-feature.
  """
  __slots__ = ('_path_helper', '_extmethods', '__clear',)

  _yang_name = 'clear-routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes', 'clear-routes']

  def _get_clear(self):
    """
    Getter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear (action)
    """
    return self.__clear
      
  def _set_clear(self, v, load=False):
    """
    Setter method for clear, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes/clear (action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear must be of a type compatible with action""",
          'defined-type': "ietf-bgp:action",
          'generated-type': """YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)""",
        })

    self.__clear = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear(self):
    self.__clear = YANGDynClass(base=yc_clear_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes_clear, is_leaf=True, yang_name="clear", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='action', is_config=False)

  clear = __builtin__.property(_get_clear)


  _pyangbind_elements = OrderedDict([('clear', clear), ])


class yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-post/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for list of routes in the routing
table.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route','__clear_routes',)

  _yang_name = 'routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post', 'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route (list)

    YANG Description: List of routes in the table
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: List of routes in the table
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType("prefix path_id",yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix path-id', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)


  def _get_clear_routes(self):
    """
    Getter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes (container)

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    return self.__clear_routes
      
  def _set_clear_routes(self, v, load=False):
    """
    Setter method for clear_routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes/clear_routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_routes() directly.

    YANG Description: Action commands to clear routes governed by a if-feature.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__clear_routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_routes(self):
    self.__clear_routes = YANGDynClass(base=yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes, is_container='container', yang_name="clear-routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_route
  clear_routes = __builtin__.property(_get_clear_routes) # type: yc_clear_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes_clear_routes


  _pyangbind_elements = OrderedDict([('route', route), ('clear_routes', clear_routes), ])


class yc_adj_rib_out_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor/adj-rib-out-post. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Per-neighbor table containing paths eligble for
sending (advertising) to the neighbor after output
policy rules have been applied
  """
  __slots__ = ('_path_helper', '_extmethods', '__routes',)

  _yang_name = 'adj-rib-out-post'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor', 'adj-rib-out-post']

  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes (container)

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Enclosing container for list of routes in the routing
table.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  routes = __builtin__.property(_get_routes) # type: yc_routes_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post_routes


  _pyangbind_elements = OrderedDict([('routes', routes), ])


class yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors/neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of neighbors (peers) of the local BGP speaker
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor_address','__adj_rib_in_pre','__adj_rib_in_post','__adj_rib_out_pre','__adj_rib_out_post',)

  _yang_name = 'neighbor'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)
    self.__adj_rib_in_pre = YANGDynClass(base=yc_adj_rib_in_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre, is_container='container', yang_name="adj-rib-in-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__adj_rib_in_post = YANGDynClass(base=yc_adj_rib_in_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post, is_container='container', yang_name="adj-rib-in-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__adj_rib_out_pre = YANGDynClass(base=yc_adj_rib_out_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre, is_container='container', yang_name="adj-rib-out-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__adj_rib_out_post = YANGDynClass(base=yc_adj_rib_out_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post, is_container='container', yang_name="adj-rib-out-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors', 'neighbor']

  def _get_neighbor_address(self):
    """
    Getter method for neighbor_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/neighbor_address (inet:ip-address)

    YANG Description: IP address of the BGP neighbor or peer
    """
    return self.__neighbor_address
      
  def _set_neighbor_address(self, v, load=False):
    """
    Setter method for neighbor_address, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/neighbor_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor_address() directly.

    YANG Description: IP address of the BGP neighbor or peer
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor_address must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)""",
        })

    self.__neighbor_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor_address(self):
    self.__neighbor_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="neighbor-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='inet:ip-address', is_config=False)


  def _get_adj_rib_in_pre(self):
    """
    Getter method for adj_rib_in_pre, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre (container)

    YANG Description: Per-neighbor table containing the NLRI updates
received from the neighbor before any local input
policy rules or filters have been applied.  This can
be considered the 'raw' updates from the neighbor.
    """
    return self.__adj_rib_in_pre
      
  def _set_adj_rib_in_pre(self, v, load=False):
    """
    Setter method for adj_rib_in_pre, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_pre (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_rib_in_pre is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_rib_in_pre() directly.

    YANG Description: Per-neighbor table containing the NLRI updates
received from the neighbor before any local input
policy rules or filters have been applied.  This can
be considered the 'raw' updates from the neighbor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_adj_rib_in_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre, is_container='container', yang_name="adj-rib-in-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_rib_in_pre must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_adj_rib_in_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre, is_container='container', yang_name="adj-rib-in-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__adj_rib_in_pre = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_rib_in_pre(self):
    self.__adj_rib_in_pre = YANGDynClass(base=yc_adj_rib_in_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre, is_container='container', yang_name="adj-rib-in-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_adj_rib_in_post(self):
    """
    Getter method for adj_rib_in_post, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post (container)

    YANG Description: Per-neighbor table containing the paths received from
the neighbor that are eligible for best-path selection
after local input policy rules have been applied.
    """
    return self.__adj_rib_in_post
      
  def _set_adj_rib_in_post(self, v, load=False):
    """
    Setter method for adj_rib_in_post, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_in_post (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_rib_in_post is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_rib_in_post() directly.

    YANG Description: Per-neighbor table containing the paths received from
the neighbor that are eligible for best-path selection
after local input policy rules have been applied.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_adj_rib_in_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post, is_container='container', yang_name="adj-rib-in-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_rib_in_post must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_adj_rib_in_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post, is_container='container', yang_name="adj-rib-in-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__adj_rib_in_post = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_rib_in_post(self):
    self.__adj_rib_in_post = YANGDynClass(base=yc_adj_rib_in_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post, is_container='container', yang_name="adj-rib-in-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_adj_rib_out_pre(self):
    """
    Getter method for adj_rib_out_pre, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre (container)

    YANG Description: Per-neighbor table containing paths eligble for
sending (advertising) to the neighbor before output
policy rules have been applied
    """
    return self.__adj_rib_out_pre
      
  def _set_adj_rib_out_pre(self, v, load=False):
    """
    Setter method for adj_rib_out_pre, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_pre (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_rib_out_pre is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_rib_out_pre() directly.

    YANG Description: Per-neighbor table containing paths eligble for
sending (advertising) to the neighbor before output
policy rules have been applied
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_adj_rib_out_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre, is_container='container', yang_name="adj-rib-out-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_rib_out_pre must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_adj_rib_out_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre, is_container='container', yang_name="adj-rib-out-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__adj_rib_out_pre = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_rib_out_pre(self):
    self.__adj_rib_out_pre = YANGDynClass(base=yc_adj_rib_out_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre, is_container='container', yang_name="adj-rib-out-pre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_adj_rib_out_post(self):
    """
    Getter method for adj_rib_out_post, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post (container)

    YANG Description: Per-neighbor table containing paths eligble for
sending (advertising) to the neighbor after output
policy rules have been applied
    """
    return self.__adj_rib_out_post
      
  def _set_adj_rib_out_post(self, v, load=False):
    """
    Setter method for adj_rib_out_post, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor/adj_rib_out_post (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adj_rib_out_post is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adj_rib_out_post() directly.

    YANG Description: Per-neighbor table containing paths eligble for
sending (advertising) to the neighbor after output
policy rules have been applied
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_adj_rib_out_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post, is_container='container', yang_name="adj-rib-out-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adj_rib_out_post must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_adj_rib_out_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post, is_container='container', yang_name="adj-rib-out-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__adj_rib_out_post = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adj_rib_out_post(self):
    self.__adj_rib_out_post = YANGDynClass(base=yc_adj_rib_out_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post, is_container='container', yang_name="adj-rib-out-post", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  neighbor_address = __builtin__.property(_get_neighbor_address)
  adj_rib_in_pre = __builtin__.property(_get_adj_rib_in_pre) # type: yc_adj_rib_in_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_pre
  adj_rib_in_post = __builtin__.property(_get_adj_rib_in_post) # type: yc_adj_rib_in_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_in_post
  adj_rib_out_pre = __builtin__.property(_get_adj_rib_out_pre) # type: yc_adj_rib_out_pre_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_pre
  adj_rib_out_post = __builtin__.property(_get_adj_rib_out_post) # type: yc_adj_rib_out_post_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor_adj_rib_out_post


  _pyangbind_elements = OrderedDict([('neighbor_address', neighbor_address), ('adj_rib_in_pre', adj_rib_in_pre), ('adj_rib_in_post', adj_rib_in_post), ('adj_rib_out_pre', adj_rib_out_pre), ('adj_rib_out_post', adj_rib_out_post), ])


class yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/neighbors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for neighbor list
  """
  __slots__ = ('_path_helper', '_extmethods', '__neighbor',)

  _yang_name = 'neighbors'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neighbor = YANGDynClass(base=YANGListType("neighbor_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbor-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast', 'neighbors']

  def _get_neighbor(self):
    """
    Getter method for neighbor, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor (list)

    YANG Description: List of neighbors (peers) of the local BGP speaker
    """
    return self.__neighbor
      
  def _set_neighbor(self, v, load=False):
    """
    Setter method for neighbor, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors/neighbor (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbor() directly.

    YANG Description: List of neighbors (peers) of the local BGP speaker
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("neighbor_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbor-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbor must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("neighbor_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbor-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__neighbor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbor(self):
    self.__neighbor = YANGDynClass(base=YANGListType("neighbor_address",yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor, yang_name="neighbor", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='neighbor-address', extensions=None), is_container='list', yang_name="neighbor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  neighbor = __builtin__.property(_get_neighbor) # type: yc_neighbor_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors_neighbor


  _pyangbind_elements = OrderedDict([('neighbor', neighbor), ])


class yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Routing tables for IPv6 unicast -- active when the
       afi-safi name is ipv6-unicast
  """
  __slots__ = ('_path_helper', '_extmethods', '__loc_rib','__neighbors',)

  _yang_name = 'ipv6-unicast'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__loc_rib = YANGDynClass(base=yc_loc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib, is_container='container', yang_name="loc-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__neighbors = YANGDynClass(base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'ipv6-unicast']

  def _get_loc_rib(self):
    """
    Getter method for loc_rib, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib (container)

    YANG Description: Container for the IPv6 BGP LOC-RIB data
    """
    return self.__loc_rib
      
  def _set_loc_rib(self, v, load=False):
    """
    Setter method for loc_rib, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/loc_rib (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_loc_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_loc_rib() directly.

    YANG Description: Container for the IPv6 BGP LOC-RIB data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_loc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib, is_container='container', yang_name="loc-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """loc_rib must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_loc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib, is_container='container', yang_name="loc-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__loc_rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_loc_rib(self):
    self.__loc_rib = YANGDynClass(base=yc_loc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib, is_container='container', yang_name="loc-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_neighbors(self):
    """
    Getter method for neighbors, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors (container)

    YANG Description: Enclosing container for neighbor list
    """
    return self.__neighbors
      
  def _set_neighbors(self, v, load=False):
    """
    Setter method for neighbors, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast/neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbors() directly.

    YANG Description: Enclosing container for neighbor list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbors(self):
    self.__neighbors = YANGDynClass(base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  loc_rib = __builtin__.property(_get_loc_rib) # type: yc_loc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_loc_rib
  neighbors = __builtin__.property(_get_neighbors) # type: yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast_neighbors


  _pyangbind_elements = OrderedDict([('loc_rib', loc_rib), ('neighbors', neighbors), ])


class yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis/afi-safi. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of afi-safi types.
  """
  __slots__ = ('_path_helper', '_extmethods', '__afi_safi_name','__ipv4_unicast','__ipv6_unicast',)

  _yang_name = 'afi-safi'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afi_safi_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    self.__ipv4_unicast = YANGDynClass(base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__ipv6_unicast = YANGDynClass(base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi']

  def _get_afi_safi_name(self):
    """
    Getter method for afi_safi_name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/afi_safi_name (identityref)

    YANG Description: AFI,SAFI name.
    """
    return self.__afi_safi_name
      
  def _set_afi_safi_name(self, v, load=False):
    """
    Setter method for afi_safi_name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/afi_safi_name (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safi_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safi_name() directly.

    YANG Description: AFI,SAFI name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safi_name must be of a type compatible with identityref""",
          'defined-type': "ietf-bgp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)""",
        })

    self.__afi_safi_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safi_name(self):
    self.__afi_safi_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv4-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:ipv6-labeled-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-unicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv4-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l3vpn-ipv6-multicast': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-vpls': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}, 'bgpt:l2vpn-evpn': {'@module': 'ietf-bgp-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp-types'}},), is_leaf=True, yang_name="afi-safi-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='identityref', is_config=False)


  def _get_ipv4_unicast(self):
    """
    Getter method for ipv4_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast (container)

    YANG Description: Routing tables for IPv4 unicast -- active when the
      afi-safi name is ipv4-unicast
    """
    return self.__ipv4_unicast
      
  def _set_ipv4_unicast(self, v, load=False):
    """
    Setter method for ipv4_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv4_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_unicast() directly.

    YANG Description: Routing tables for IPv4 unicast -- active when the
      afi-safi name is ipv4-unicast
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__ipv4_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_unicast(self):
    self.__ipv4_unicast = YANGDynClass(base=yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast, is_container='container', yang_name="ipv4-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_ipv6_unicast(self):
    """
    Getter method for ipv6_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast (container)

    YANG Description: Routing tables for IPv6 unicast -- active when the
       afi-safi name is ipv6-unicast
    """
    return self.__ipv6_unicast
      
  def _set_ipv6_unicast(self, v, load=False):
    """
    Setter method for ipv6_unicast, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi/ipv6_unicast (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_unicast is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_unicast() directly.

    YANG Description: Routing tables for IPv6 unicast -- active when the
       afi-safi name is ipv6-unicast
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_unicast must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__ipv6_unicast = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_unicast(self):
    self.__ipv6_unicast = YANGDynClass(base=yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast, is_container='container', yang_name="ipv6-unicast", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  afi_safi_name = __builtin__.property(_get_afi_safi_name)
  ipv4_unicast = __builtin__.property(_get_ipv4_unicast) # type: yc_ipv4_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv4_unicast
  ipv6_unicast = __builtin__.property(_get_ipv6_unicast) # type: yc_ipv6_unicast_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi_ipv6_unicast


  _pyangbind_elements = OrderedDict([('afi_safi_name', afi_safi_name), ('ipv4_unicast', ipv4_unicast), ('ipv6_unicast', ipv6_unicast), ])


class yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib/afi-safis. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for address family list
  """
  __slots__ = ('_path_helper', '_extmethods', '__afi_safi',)

  _yang_name = 'afi-safis'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__afi_safi = YANGDynClass(base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib', 'afi-safis']

  def _get_afi_safi(self):
    """
    Getter method for afi_safi, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi (list)

    YANG Description: List of afi-safi types.
    """
    return self.__afi_safi
      
  def _set_afi_safi(self, v, load=False):
    """
    Setter method for afi_safi, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis/afi_safi (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safi() directly.

    YANG Description: List of afi-safi types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safi must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)""",
        })

    self.__afi_safi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safi(self):
    self.__afi_safi = YANGDynClass(base=YANGListType("afi_safi_name",yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi, yang_name="afi-safi", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='afi-safi-name', extensions=None), is_container='list', yang_name="afi-safi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='list', is_config=False)

  afi_safi = __builtin__.property(_get_afi_safi) # type: yc_afi_safi_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis_afi_safi


  _pyangbind_elements = OrderedDict([('afi_safi', afi_safi), ])


class yc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp/rib. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top level container for BGP RIB
  """
  __slots__ = ('_path_helper', '_extmethods', '__attr_sets','__communities','__ext_communities','__afi_safis',)

  _yang_name = 'rib'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__attr_sets = YANGDynClass(base=yc_attr_sets_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets, is_container='container', yang_name="attr-sets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__communities = YANGDynClass(base=yc_communities_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_communities, is_container='container', yang_name="communities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__ext_communities = YANGDynClass(base=yc_ext_communities_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_ext_communities, is_container='container', yang_name="ext-communities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    self.__afi_safis = YANGDynClass(base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp', 'rib']

  def _get_attr_sets(self):
    """
    Getter method for attr_sets, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets (container)

    YANG Description: Enclosing container for the list of path attribute sets
    """
    return self.__attr_sets
      
  def _set_attr_sets(self, v, load=False):
    """
    Setter method for attr_sets, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/attr_sets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attr_sets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attr_sets() directly.

    YANG Description: Enclosing container for the list of path attribute sets
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_attr_sets_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets, is_container='container', yang_name="attr-sets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attr_sets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_attr_sets_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets, is_container='container', yang_name="attr-sets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__attr_sets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attr_sets(self):
    self.__attr_sets = YANGDynClass(base=yc_attr_sets_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets, is_container='container', yang_name="attr-sets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_communities(self):
    """
    Getter method for communities, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/communities (container)

    YANG Description: Enclosing container for the list of community attribute
sets
    """
    return self.__communities
      
  def _set_communities(self, v, load=False):
    """
    Setter method for communities, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/communities (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_communities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_communities() directly.

    YANG Description: Enclosing container for the list of community attribute
sets
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_communities_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_communities, is_container='container', yang_name="communities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """communities must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_communities_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_communities, is_container='container', yang_name="communities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__communities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_communities(self):
    self.__communities = YANGDynClass(base=yc_communities_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_communities, is_container='container', yang_name="communities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_ext_communities(self):
    """
    Getter method for ext_communities, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/ext_communities (container)

    YANG Description: Enclosing container for the list of extended community
attribute sets
    """
    return self.__ext_communities
      
  def _set_ext_communities(self, v, load=False):
    """
    Setter method for ext_communities, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/ext_communities (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_communities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_communities() directly.

    YANG Description: Enclosing container for the list of extended community
attribute sets
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ext_communities_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_ext_communities, is_container='container', yang_name="ext-communities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_communities must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ext_communities_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_ext_communities, is_container='container', yang_name="ext-communities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__ext_communities = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_communities(self):
    self.__ext_communities = YANGDynClass(base=yc_ext_communities_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_ext_communities, is_container='container', yang_name="ext-communities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)


  def _get_afi_safis(self):
    """
    Getter method for afi_safis, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis (container)

    YANG Description: Enclosing container for address family list
    """
    return self.__afi_safis
      
  def _set_afi_safis(self, v, load=False):
    """
    Setter method for afi_safis, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib/afi_safis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afi_safis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afi_safis() directly.

    YANG Description: Enclosing container for address family list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afi_safis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)""",
        })

    self.__afi_safis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afi_safis(self):
    self.__afi_safis = YANGDynClass(base=yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis, is_container='container', yang_name="afi-safis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=False)

  attr_sets = __builtin__.property(_get_attr_sets) # type: yc_attr_sets_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_attr_sets
  communities = __builtin__.property(_get_communities) # type: yc_communities_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_communities
  ext_communities = __builtin__.property(_get_ext_communities) # type: yc_ext_communities_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_ext_communities
  afi_safis = __builtin__.property(_get_afi_safis) # type: yc_afi_safis_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib_afi_safis


  _pyangbind_elements = OrderedDict([('attr_sets', attr_sets), ('communities', communities), ('ext_communities', ext_communities), ('afi_safis', afi_safis), ])


class yc_bgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol/bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Top-level configuration for the BGP router
  """
  __slots__ = ('_path_helper', '_extmethods', '__global_','__neighbors','__peer_groups','__interfaces','__rib',)

  _yang_name = 'bgp'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__global_ = YANGDynClass(base=yc_global__ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__neighbors = YANGDynClass(base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__peer_groups = YANGDynClass(base=yc_peer_groups_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups, is_container='container', yang_name="peer-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    self.__rib = YANGDynClass(base=yc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib, is_container='container', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol', 'bgp']

  def _get_global_(self):
    """
    Getter method for global_, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global (container)

    YANG Description: Global configuration for the BGP router
    """
    return self.__global_
      
  def _set_global_(self, v, load=False):
    """
    Setter method for global_, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/global (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_() directly.

    YANG Description: Global configuration for the BGP router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_global__ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_ must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_global__ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__global_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_(self):
    self.__global_ = YANGDynClass(base=yc_global__ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_neighbors(self):
    """
    Getter method for neighbors, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors (container)

    YANG Description: Configuration for BGP neighbors
    """
    return self.__neighbors
      
  def _set_neighbors(self, v, load=False):
    """
    Setter method for neighbors, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/neighbors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neighbors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neighbors() directly.

    YANG Description: Configuration for BGP neighbors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neighbors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__neighbors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neighbors(self):
    self.__neighbors = YANGDynClass(base=yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors, is_container='container', yang_name="neighbors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_peer_groups(self):
    """
    Getter method for peer_groups, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups (container)

    YANG Description: Configuration for BGP peer-groups
    """
    return self.__peer_groups
      
  def _set_peer_groups(self, v, load=False):
    """
    Setter method for peer_groups, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/peer_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_groups() directly.

    YANG Description: Configuration for BGP peer-groups
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_peer_groups_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups, is_container='container', yang_name="peer-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_peer_groups_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups, is_container='container', yang_name="peer-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__peer_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_groups(self):
    self.__peer_groups = YANGDynClass(base=yc_peer_groups_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups, is_container='container', yang_name="peer-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces (container)

    YANG Description: Interface specific parameters.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Interface specific parameters.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)


  def _get_rib(self):
    """
    Getter method for rib, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib (container)

    YANG Description: Top level container for BGP RIB
    """
    return self.__rib
      
  def _set_rib(self, v, load=False):
    """
    Setter method for rib, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp/rib (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rib() directly.

    YANG Description: Top level container for BGP RIB
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib, is_container='container', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rib must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib, is_container='container', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rib(self):
    self.__rib = YANGDynClass(base=yc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib, is_container='container', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  global_ = __builtin__.property(_get_global_, _set_global_) # type: yc_global__ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_global
  neighbors = __builtin__.property(_get_neighbors, _set_neighbors) # type: yc_neighbors_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_neighbors
  peer_groups = __builtin__.property(_get_peer_groups, _set_peer_groups) # type: yc_peer_groups_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_peer_groups
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces) # type: yc_interfaces_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_interfaces
  rib = __builtin__.property(_get_rib, _set_rib) # type: yc_rib_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp_rib


  _pyangbind_elements = OrderedDict([('global_', global_), ('neighbors', neighbors), ('peer_groups', peer_groups), ('interfaces', interfaces), ('rib', rib), ])


class yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols/control-plane-protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry contains a control-plane protocol instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__name','__description','__bgp',)

  _yang_name = 'control-plane-protocol'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd-types:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__bgp = YANGDynClass(base=yc_bgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols', 'control-plane-protocol']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/type (identityref)

    YANG Description: Type of the control-plane protocol - an identity derived
from the 'control-plane-protocol' base identity.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the control-plane protocol - an identity derived
from the 'control-plane-protocol' base identity.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd-types:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd-types:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd-types:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/name (string)

    YANG Description: An arbitrary name of the control-plane protocol
instance.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: An arbitrary name of the control-plane protocol
instance.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/description (string)

    YANG Description: Textual description of the control-plane protocol
instance.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Textual description of the control-plane protocol
instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)


  def _get_bgp(self):
    """
    Getter method for bgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp (container)

    YANG Description: Top-level configuration for the BGP router
    """
    return self.__bgp
      
  def _set_bgp(self, v, load=False):
    """
    Setter method for bgp, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol/bgp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bgp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bgp() directly.

    YANG Description: Top-level configuration for the BGP router
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bgp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)""",
        })

    self.__bgp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bgp(self):
    self.__bgp = YANGDynClass(base=yc_bgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp, is_container='container', yang_name="bgp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-bgp', defining_module='ietf-bgp', yang_type='container', is_config=True)

  type = __builtin__.property(_get_type, _set_type)
  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  bgp = __builtin__.property(_get_bgp, _set_bgp) # type: yc_bgp_ietf_routing__routing_control_plane_protocols_control_plane_protocol_bgp


  _pyangbind_elements = OrderedDict([('type', type), ('name', name), ('description', description), ('bgp', bgp), ])


class yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/control-plane-protocols. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Support for control-plane protocol instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__control_plane_protocol',)

  _yang_name = 'control-plane-protocols'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'control-plane-protocols']

  def _get_control_plane_protocol(self):
    """
    Getter method for control_plane_protocol, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol (list)

    YANG Description: Each entry contains a control-plane protocol instance.
    """
    return self.__control_plane_protocol
      
  def _set_control_plane_protocol(self, v, load=False):
    """
    Setter method for control_plane_protocol, mapped from YANG variable /routing/control_plane_protocols/control_plane_protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocol() directly.

    YANG Description: Each entry contains a control-plane protocol instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocol must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)""",
        })

    self.__control_plane_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocol(self):
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

  control_plane_protocol = __builtin__.property(_get_control_plane_protocol, _set_control_plane_protocol) # type: yc_control_plane_protocol_ietf_routing__routing_control_plane_protocols_control_plane_protocol


  _pyangbind_elements = OrderedDict([('control_plane_protocol', control_plane_protocol), ])


class yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route/next-hop/next-hop-list/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'routes', 'route', 'next-hop', 'next-hop-list', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)

  __choices__ = {'next-hop-options': {'next-hop-list': ['outgoing_interface']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ])


class yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route/next-hop/next-hop-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for multiple next hops.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop',)

  _yang_name = 'next-hop-list'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'routes', 'route', 'next-hop', 'next-hop-list']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  next_hop = __builtin__.property(_get_next_hop) # type: yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list_next_hop

  __choices__ = {'next-hop-options': {'next-hop-list': ['next_hop']}}
  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ])


class yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route's next-hop attribute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface','__special_next_hop','__next_hop_list',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'routes', 'route', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)


  def _get_special_next_hop(self):
    """
    Getter method for special_next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)

    YANG Description: Options for special next hops.
    """
    return self.__special_next_hop
      
  def _set_special_next_hop(self, v, load=False):
    """
    Setter method for special_next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_special_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_special_next_hop() directly.

    YANG Description: Options for special next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """special_next_hop must be of a type compatible with enumeration""",
          'defined-type': "ietf-routing:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)""",
        })

    self.__special_next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_special_next_hop(self):
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)


  def _get_next_hop_list(self):
    """
    Getter method for next_hop_list, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list (container)

    YANG Description: Container for multiple next hops.
    """
    return self.__next_hop_list
      
  def _set_next_hop_list(self, v, load=False):
    """
    Setter method for next_hop_list, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop/next_hop_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_list() directly.

    YANG Description: Container for multiple next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_list(self):
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)
  special_next_hop = __builtin__.property(_get_special_next_hop)
  next_hop_list = __builtin__.property(_get_next_hop_list) # type: yc_next_hop_list_ietf_routing__routing_ribs_rib_routes_route_next_hop_next_hop_list

  __choices__ = {'next-hop-options': {'simple-next-hop': ['outgoing_interface'], 'special-next-hop': ['special_next_hop'], 'next-hop-list': ['next_hop_list']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ('special_next_hop', special_next_hop), ('next_hop_list', next_hop_list), ])


class yc_route_ietf_routing__routing_ribs_rib_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_preference','__next_hop','__source_protocol','__active','__last_updated',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'routes', 'route']

  def _get_route_preference(self):
    """
    Getter method for route_preference, mapped from YANG variable /routing/ribs/rib/routes/route/route_preference (route-preference)

    YANG Description: This route attribute, also known as administrative
distance, allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value means a more preferred route.
    """
    return self.__route_preference
      
  def _set_route_preference(self, v, load=False):
    """
    Setter method for route_preference, mapped from YANG variable /routing/ribs/rib/routes/route/route_preference (route-preference)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_preference() directly.

    YANG Description: This route attribute, also known as administrative
distance, allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value means a more preferred route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_preference must be of a type compatible with route-preference""",
          'defined-type': "ietf-routing:route-preference",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)""",
        })

    self.__route_preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_preference(self):
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop (container)

    YANG Description: Route's next-hop attribute.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing/ribs/rib/routes/route/next_hop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Route's next-hop attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_source_protocol(self):
    """
    Getter method for source_protocol, mapped from YANG variable /routing/ribs/rib/routes/route/source_protocol (identityref)

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    return self.__source_protocol
      
  def _set_source_protocol(self, v, load=False):
    """
    Setter method for source_protocol, mapped from YANG variable /routing/ribs/rib/routes/route/source_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_protocol() directly.

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__source_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_protocol(self):
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /routing/ribs/rib/routes/route/active (empty)

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /routing/ribs/rib/routes/route/active (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /routing/ribs/rib/routes/route/last_updated (yang:date-and-time)

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /routing/ribs/rib/routes/route/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

  route_preference = __builtin__.property(_get_route_preference)
  next_hop = __builtin__.property(_get_next_hop) # type: yc_next_hop_ietf_routing__routing_ribs_rib_routes_route_next_hop
  source_protocol = __builtin__.property(_get_source_protocol)
  active = __builtin__.property(_get_active)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('route_preference', route_preference), ('next_hop', next_hop), ('source_protocol', source_protocol), ('active', active), ('last_updated', last_updated), ])


class yc_routes_ietf_routing__routing_ribs_rib_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Current content of the RIB.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/ribs/rib/routes/route (list)

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/ribs/rib/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_ribs_rib_routes_route


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/active-route/output/route/next-hop/next-hop-list/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'active-route', 'output', 'route', 'next-hop', 'next-hop-list', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)

  outgoing_interface = __builtin__.property(_get_outgoing_interface, _set_outgoing_interface)

  __choices__ = {'next-hop-options': {'next-hop-list': ['outgoing_interface']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ])


class yc_next_hop_list_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/active-route/output/route/next-hop/next-hop-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for multiple next hops.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop',)

  _yang_name = 'next-hop-list'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'active-route', 'output', 'route', 'next-hop', 'next-hop-list']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop (list)

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

  next_hop = __builtin__.property(_get_next_hop, _set_next_hop) # type: yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop

  __choices__ = {'next-hop-options': {'next-hop-list': ['next_hop']}}
  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ])


class yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/active-route/output/route/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route's next-hop attribute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface','__special_next_hop','__next_hop_list',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=True)
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'active-route', 'output', 'route', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=True)


  def _get_special_next_hop(self):
    """
    Getter method for special_next_hop, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/special_next_hop (enumeration)

    YANG Description: Options for special next hops.
    """
    return self.__special_next_hop
      
  def _set_special_next_hop(self, v, load=False):
    """
    Setter method for special_next_hop, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/special_next_hop (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_special_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_special_next_hop() directly.

    YANG Description: Options for special next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """special_next_hop must be of a type compatible with enumeration""",
          'defined-type': "ietf-routing:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=True)""",
        })

    self.__special_next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_special_next_hop(self):
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=True)


  def _get_next_hop_list(self):
    """
    Getter method for next_hop_list, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/next_hop_list (container)

    YANG Description: Container for multiple next hops.
    """
    return self.__next_hop_list
      
  def _set_next_hop_list(self, v, load=False):
    """
    Setter method for next_hop_list, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop/next_hop_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_list() directly.

    YANG Description: Container for multiple next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_list_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__next_hop_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_list(self):
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  outgoing_interface = __builtin__.property(_get_outgoing_interface, _set_outgoing_interface)
  special_next_hop = __builtin__.property(_get_special_next_hop, _set_special_next_hop)
  next_hop_list = __builtin__.property(_get_next_hop_list, _set_next_hop_list) # type: yc_next_hop_list_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop_next_hop_list

  __choices__ = {'next-hop-options': {'simple-next-hop': ['outgoing_interface'], 'special-next-hop': ['special_next_hop'], 'next-hop-list': ['next_hop_list']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ('special_next_hop', special_next_hop), ('next_hop_list', next_hop_list), ])


class yc_route_ietf_routing__routing_ribs_rib_active_route_output_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/active-route/output/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The active RIB route for the specified destination.

If no route exists in the RIB for the destination
address, no output is returned.

Address-family-specific modules MUST augment this
container with appropriate route contents.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop','__source_protocol','__active','__last_updated',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=True)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'active-route', 'output', 'route']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop (container)

    YANG Description: Route's next-hop attribute.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing/ribs/rib/active_route/output/route/next_hop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Route's next-hop attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_source_protocol(self):
    """
    Getter method for source_protocol, mapped from YANG variable /routing/ribs/rib/active_route/output/route/source_protocol (identityref)

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    return self.__source_protocol
      
  def _set_source_protocol(self, v, load=False):
    """
    Setter method for source_protocol, mapped from YANG variable /routing/ribs/rib/active_route/output/route/source_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_protocol() directly.

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)""",
        })

    self.__source_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_protocol(self):
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /routing/ribs/rib/active_route/output/route/active (empty)

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /routing/ribs/rib/active_route/output/route/active (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=True)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=True)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /routing/ribs/rib/active_route/output/route/last_updated (yang:date-and-time)

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /routing/ribs/rib/active_route/output/route/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=True)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=True)

  next_hop = __builtin__.property(_get_next_hop, _set_next_hop) # type: yc_next_hop_ietf_routing__routing_ribs_rib_active_route_output_route_next_hop
  source_protocol = __builtin__.property(_get_source_protocol, _set_source_protocol)
  active = __builtin__.property(_get_active, _set_active)
  last_updated = __builtin__.property(_get_last_updated, _set_last_updated)


  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ('source_protocol', source_protocol), ('active', active), ('last_updated', last_updated), ])


class yc_output_ietf_routing__routing_ribs_rib_active_route_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/active-route/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'output'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=yc_route_ietf_routing__routing_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'active-route', 'output']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing/ribs/rib/active_route/output/route (container)

    YANG Description: The active RIB route for the specified destination.

If no route exists in the RIB for the destination
address, no output is returned.

Address-family-specific modules MUST augment this
container with appropriate route contents.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing/ribs/rib/active_route/output/route (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: The active RIB route for the specified destination.

If no route exists in the RIB for the destination
address, no output is returned.

Address-family-specific modules MUST augment this
container with appropriate route contents.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_route_ietf_routing__routing_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_route_ietf_routing__routing_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=yc_route_ietf_routing__routing_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  route = __builtin__.property(_get_route, _set_route) # type: yc_route_ietf_routing__routing_ribs_rib_active_route_output_route


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_active_route_ietf_routing__routing_ribs_rib_active_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib/active-route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Return the active RIB route that is used for the
destination address.

Address-family-specific modules MUST augment input
parameters with a leaf named 'destination-address'.
  """
  __slots__ = ('_path_helper', '_extmethods', '__output',)

  _yang_name = 'active-route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib', 'active-route']

  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing/ribs/rib/active_route/output (output)
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing/ribs/rib/active_route/output (output)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_ietf_routing__routing_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with output""",
          'defined-type': "ietf-routing:output",
          'generated-type': """YANGDynClass(base=yc_output_ietf_routing__routing_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=True)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=True)

  output = __builtin__.property(_get_output, _set_output)


  _pyangbind_elements = OrderedDict([('output', output), ])


class yc_rib_ietf_routing__routing_ribs_rib(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs/rib. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry contains configuration for a RIB identified by
the 'name' key.

Entries having the same key as a system-controlled entry
of the list /routing/ribs/rib are used for
configuring parameters of that entry.  Other entries
define additional user-controlled RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__address_family','__default_rib','__routes','__active_route','__description',)

  _yang_name = 'rib'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__active_route = YANGDynClass(base=yc_active_route_ietf_routing__routing_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs', 'rib']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing/ribs/rib/name (string)

    YANG Description: The name of the RIB.

For system-controlled entries, the value of this leaf
must be the same as the name of the corresponding entry
in operational state.

For user-controlled entries, an arbitrary name can be
used.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing/ribs/rib/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the RIB.

For system-controlled entries, the value of this leaf
must be the same as the name of the corresponding entry
in operational state.

For user-controlled entries, an arbitrary name can be
used.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)


  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /routing/ribs/rib/address_family (identityref)

    YANG Description: Address family.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /routing/ribs/rib/address_family (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: Address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=True)


  def _get_default_rib(self):
    """
    Getter method for default_rib, mapped from YANG variable /routing/ribs/rib/default_rib (boolean)

    YANG Description: This flag has the value of 'true' if and only if the RIB
is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    return self.__default_rib
      
  def _set_default_rib(self, v, load=False):
    """
    Setter method for default_rib, mapped from YANG variable /routing/ribs/rib/default_rib (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_rib() directly.

    YANG Description: This flag has the value of 'true' if and only if the RIB
is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_rib must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)""",
        })

    self.__default_rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_rib(self):
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)


  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing/ribs/rib/routes (container)

    YANG Description: Current content of the RIB.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing/ribs/rib/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Current content of the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_active_route(self):
    """
    Getter method for active_route, mapped from YANG variable /routing/ribs/rib/active_route (action)

    YANG Description: Return the active RIB route that is used for the
destination address.

Address-family-specific modules MUST augment input
parameters with a leaf named 'destination-address'.
    """
    return self.__active_route
      
  def _set_active_route(self, v, load=False):
    """
    Setter method for active_route, mapped from YANG variable /routing/ribs/rib/active_route (action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_route() directly.

    YANG Description: Return the active RIB route that is used for the
destination address.

Address-family-specific modules MUST augment input
parameters with a leaf named 'destination-address'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_active_route_ietf_routing__routing_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_route must be of a type compatible with action""",
          'defined-type': "ietf-routing:action",
          'generated-type': """YANGDynClass(base=yc_active_route_ietf_routing__routing_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=True)""",
        })

    self.__active_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_route(self):
    self.__active_route = YANGDynClass(base=yc_active_route_ietf_routing__routing_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /routing/ribs/rib/description (string)

    YANG Description: Textual description of the RIB.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /routing/ribs/rib/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Textual description of the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  address_family = __builtin__.property(_get_address_family, _set_address_family)
  default_rib = __builtin__.property(_get_default_rib)
  routes = __builtin__.property(_get_routes, _set_routes) # type: yc_routes_ietf_routing__routing_ribs_rib_routes
  active_route = __builtin__.property(_get_active_route, _set_active_route)
  description = __builtin__.property(_get_description, _set_description)


  _pyangbind_elements = OrderedDict([('name', name), ('address_family', address_family), ('default_rib', default_rib), ('routes', routes), ('active_route', active_route), ('description', description), ])


class yc_ribs_ietf_routing__routing_ribs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing/ribs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Support for RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rib',)

  _yang_name = 'ribs'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing', 'ribs']

  def _get_rib(self):
    """
    Getter method for rib, mapped from YANG variable /routing/ribs/rib (list)

    YANG Description: Each entry contains configuration for a RIB identified by
the 'name' key.

Entries having the same key as a system-controlled entry
of the list /routing/ribs/rib are used for
configuring parameters of that entry.  Other entries
define additional user-controlled RIBs.
    """
    return self.__rib
      
  def _set_rib(self, v, load=False):
    """
    Setter method for rib, mapped from YANG variable /routing/ribs/rib (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rib() directly.

    YANG Description: Each entry contains configuration for a RIB identified by
the 'name' key.

Entries having the same key as a system-controlled entry
of the list /routing/ribs/rib are used for
configuring parameters of that entry.  Other entries
define additional user-controlled RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rib must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)""",
        })

    self.__rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rib(self):
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=True)

  rib = __builtin__.property(_get_rib, _set_rib) # type: yc_rib_ietf_routing__routing_ribs_rib


  _pyangbind_elements = OrderedDict([('rib', rib), ])


class yc_routing_ietf_routing__routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the routing subsystem.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__interfaces','__control_plane_protocols','__ribs',)

  _yang_name = 'routing'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /routing/router_id (yang:dotted-quad)

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /routing/router_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /routing/interfaces (container)

    YANG Description: Network-layer interfaces used for routing.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /routing/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Network-layer interfaces used for routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_control_plane_protocols(self):
    """
    Getter method for control_plane_protocols, mapped from YANG variable /routing/control_plane_protocols (container)

    YANG Description: Support for control-plane protocol instances.
    """
    return self.__control_plane_protocols
      
  def _set_control_plane_protocols(self, v, load=False):
    """
    Setter method for control_plane_protocols, mapped from YANG variable /routing/control_plane_protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocols() directly.

    YANG Description: Support for control-plane protocol instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__control_plane_protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocols(self):
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_ribs(self):
    """
    Getter method for ribs, mapped from YANG variable /routing/ribs (container)

    YANG Description: Support for RIBs.
    """
    return self.__ribs
      
  def _set_ribs(self, v, load=False):
    """
    Setter method for ribs, mapped from YANG variable /routing/ribs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ribs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ribs() directly.

    YANG Description: Support for RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ribs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__ribs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ribs(self):
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  router_id = __builtin__.property(_get_router_id, _set_router_id)
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces) # type: yc_interfaces_ietf_routing__routing_interfaces
  control_plane_protocols = __builtin__.property(_get_control_plane_protocols, _set_control_plane_protocols) # type: yc_control_plane_protocols_ietf_routing__routing_control_plane_protocols
  ribs = __builtin__.property(_get_ribs, _set_ribs) # type: yc_ribs_ietf_routing__routing_ribs


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('interfaces', interfaces), ('control_plane_protocols', control_plane_protocols), ('ribs', ribs), ])


class yc_interfaces_ietf_routing__routing_state_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network-layer interfaces used for routing.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /routing_state/interfaces/interface (if:interface-state-ref)

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /routing_state/interfaces/interface (if:interface-state-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Each entry is a reference to the name of a configured
network-layer interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with if:interface-state-ref""",
          'defined-type': "if:interface-state-ref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-state-ref', is_config=False)

  interface = __builtin__.property(_get_interface)


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/control-plane-protocols/control-plane-protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data of a control-plane protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the 'direct'
pseudo-protocol.  Instances of other control-plane
protocols MAY be created by configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__name',)

  _yang_name = 'control-plane-protocol'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd-types:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'control-plane-protocols', 'control-plane-protocol']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/type (identityref)

    YANG Description: Type of the control-plane protocol.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of the control-plane protocol.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd-types:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd-types:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:routing-protocol': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd-types:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}, 'bfd:bfdv1': {'@module': 'ietf-bfd-types', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bfd-types'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/name (string)

    YANG Description: The name of the control-plane protocol instance.

For system-controlled instances this name is
persistent, i.e., it SHOULD NOT change across
reboots.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the control-plane protocol instance.

For system-controlled instances this name is
persistent, i.e., it SHOULD NOT change across
reboots.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)

  type = __builtin__.property(_get_type)
  name = __builtin__.property(_get_name)


  _pyangbind_elements = OrderedDict([('type', type), ('name', name), ])


class yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/control-plane-protocols. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the list of routing protocol instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__control_plane_protocol',)

  _yang_name = 'control-plane-protocols'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'control-plane-protocols']

  def _get_control_plane_protocol(self):
    """
    Getter method for control_plane_protocol, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol (list)

    YANG Description: State data of a control-plane protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the 'direct'
pseudo-protocol.  Instances of other control-plane
protocols MAY be created by configuration.
    """
    return self.__control_plane_protocol
      
  def _set_control_plane_protocol(self, v, load=False):
    """
    Setter method for control_plane_protocol, mapped from YANG variable /routing_state/control_plane_protocols/control_plane_protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocol() directly.

    YANG Description: State data of a control-plane protocol instance.

An implementation MUST provide exactly one
system-controlled instance of the 'direct'
pseudo-protocol.  Instances of other control-plane
protocols MAY be created by configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocol must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__control_plane_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocol(self):
    self.__control_plane_protocol = YANGDynClass(base=YANGListType("type name",yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol, yang_name="control-plane-protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type name', extensions=None), is_container='list', yang_name="control-plane-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  control_plane_protocol = __builtin__.property(_get_control_plane_protocol) # type: yc_control_plane_protocol_ietf_routing__routing_state_control_plane_protocols_control_plane_protocol


  _pyangbind_elements = OrderedDict([('control_plane_protocol', control_plane_protocol), ])


class yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route/next-hop/next-hop-list/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'routes', 'route', 'next-hop', 'next-hop-list', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)

  __choices__ = {'next-hop-options': {'next-hop-list': ['outgoing_interface']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ])


class yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route/next-hop/next-hop-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for multiple next hops.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop',)

  _yang_name = 'next-hop-list'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'routes', 'route', 'next-hop', 'next-hop-list']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list/next_hop (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  next_hop = __builtin__.property(_get_next_hop) # type: yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list_next_hop

  __choices__ = {'next-hop-options': {'next-hop-list': ['next_hop']}}
  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ])


class yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route's next-hop attribute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface','__special_next_hop','__next_hop_list',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'routes', 'route', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)


  def _get_special_next_hop(self):
    """
    Getter method for special_next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)

    YANG Description: Options for special next hops.
    """
    return self.__special_next_hop
      
  def _set_special_next_hop(self, v, load=False):
    """
    Setter method for special_next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/special_next_hop (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_special_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_special_next_hop() directly.

    YANG Description: Options for special next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """special_next_hop must be of a type compatible with enumeration""",
          'defined-type': "ietf-routing:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)""",
        })

    self.__special_next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_special_next_hop(self):
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)


  def _get_next_hop_list(self):
    """
    Getter method for next_hop_list, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list (container)

    YANG Description: Container for multiple next hops.
    """
    return self.__next_hop_list
      
  def _set_next_hop_list(self, v, load=False):
    """
    Setter method for next_hop_list, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop/next_hop_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_list() directly.

    YANG Description: Container for multiple next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_list(self):
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)
  special_next_hop = __builtin__.property(_get_special_next_hop)
  next_hop_list = __builtin__.property(_get_next_hop_list) # type: yc_next_hop_list_ietf_routing__routing_state_ribs_rib_routes_route_next_hop_next_hop_list

  __choices__ = {'next-hop-options': {'simple-next-hop': ['outgoing_interface'], 'special-next-hop': ['special_next_hop'], 'next-hop-list': ['next_hop_list']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ('special_next_hop', special_next_hop), ('next_hop_list', next_hop_list), ])


class yc_route_ietf_routing__routing_state_ribs_rib_routes_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_preference','__next_hop','__source_protocol','__active','__last_updated',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'routes', 'route']

  def _get_route_preference(self):
    """
    Getter method for route_preference, mapped from YANG variable /routing_state/ribs/rib/routes/route/route_preference (route-preference)

    YANG Description: This route attribute, also known as administrative
distance, allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value means a more preferred route.
    """
    return self.__route_preference
      
  def _set_route_preference(self, v, load=False):
    """
    Setter method for route_preference, mapped from YANG variable /routing_state/ribs/rib/routes/route/route_preference (route-preference)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_preference() directly.

    YANG Description: This route attribute, also known as administrative
distance, allows for selecting the preferred route
among routes with the same destination prefix.  A
smaller value means a more preferred route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_preference must be of a type compatible with route-preference""",
          'defined-type': "ietf-routing:route-preference",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)""",
        })

    self.__route_preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_preference(self):
    self.__route_preference = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="route-preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='route-preference', is_config=False)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop (container)

    YANG Description: Route's next-hop attribute.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/routes/route/next_hop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Route's next-hop attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_source_protocol(self):
    """
    Getter method for source_protocol, mapped from YANG variable /routing_state/ribs/rib/routes/route/source_protocol (identityref)

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    return self.__source_protocol
      
  def _set_source_protocol(self, v, load=False):
    """
    Setter method for source_protocol, mapped from YANG variable /routing_state/ribs/rib/routes/route/source_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_protocol() directly.

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__source_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_protocol(self):
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /routing_state/ribs/rib/routes/route/active (empty)

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /routing_state/ribs/rib/routes/route/active (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /routing_state/ribs/rib/routes/route/last_updated (yang:date-and-time)

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /routing_state/ribs/rib/routes/route/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

  route_preference = __builtin__.property(_get_route_preference)
  next_hop = __builtin__.property(_get_next_hop) # type: yc_next_hop_ietf_routing__routing_state_ribs_rib_routes_route_next_hop
  source_protocol = __builtin__.property(_get_source_protocol)
  active = __builtin__.property(_get_active)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('route_preference', route_preference), ('next_hop', next_hop), ('source_protocol', source_protocol), ('active', active), ('last_updated', last_updated), ])


class yc_routes_ietf_routing__routing_state_ribs_rib_routes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/routes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Current content of the RIB.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'routes'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'routes']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing_state/ribs/rib/routes/route (list)

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing_state/ribs/rib/routes/route (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: A RIB route entry.  This data node MUST be augmented
with information specific for routes of each address
family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=YANGListType(False,yc_route_ietf_routing__routing_state_ribs_rib_routes_route, yang_name="route", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None), is_container='list', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_state_ribs_rib_routes_route


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/active-route/output/route/next-hop/next-hop-list/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'active-route', 'output', 'route', 'next-hop', 'next-hop-list', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)

  __choices__ = {'next-hop-options': {'next-hop-list': ['outgoing_interface']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ])


class yc_next_hop_list_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/active-route/output/route/next-hop/next-hop-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for multiple next hops.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop',)

  _yang_name = 'next-hop-list'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'active-route', 'output', 'route', 'next-hop', 'next-hop-list']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop (list)

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/next_hop_list/next_hop (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: An entry of a next-hop list.

Modules for address families MUST augment this list
with a leaf containing a next-hop address of that
address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=YANGListType(False,yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop, yang_name="next-hop", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='False', extensions=None, choice=('next-hop-options', 'next-hop-list')), is_container='list', yang_name="next-hop", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  next_hop = __builtin__.property(_get_next_hop) # type: yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list_next_hop

  __choices__ = {'next-hop-options': {'next-hop-list': ['next_hop']}}
  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ])


class yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/active-route/output/route/next-hop. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Route's next-hop attribute.
  """
  __slots__ = ('_path_helper', '_extmethods', '__outgoing_interface','__special_next_hop','__next_hop_list',)

  _yang_name = 'next-hop'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'active-route', 'output', 'route', 'next-hop']

  def _get_outgoing_interface(self):
    """
    Getter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/outgoing_interface (if:interface-ref)

    YANG Description: Name of the outgoing interface.
    """
    return self.__outgoing_interface
      
  def _set_outgoing_interface(self, v, load=False):
    """
    Setter method for outgoing_interface, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/outgoing_interface (if:interface-ref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outgoing_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outgoing_interface() directly.

    YANG Description: Name of the outgoing interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outgoing_interface must be of a type compatible with if:interface-ref""",
          'defined-type': "if:interface-ref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)""",
        })

    self.__outgoing_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outgoing_interface(self):
    self.__outgoing_interface = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="outgoing-interface", parent=self, choice=('next-hop-options', 'simple-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='if:interface-ref', is_config=False)


  def _get_special_next_hop(self):
    """
    Getter method for special_next_hop, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/special_next_hop (enumeration)

    YANG Description: Options for special next hops.
    """
    return self.__special_next_hop
      
  def _set_special_next_hop(self, v, load=False):
    """
    Setter method for special_next_hop, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/special_next_hop (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_special_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_special_next_hop() directly.

    YANG Description: Options for special next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """special_next_hop must be of a type compatible with enumeration""",
          'defined-type': "ietf-routing:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)""",
        })

    self.__special_next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_special_next_hop(self):
    self.__special_next_hop = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'blackhole': {}, 'unreachable': {}, 'prohibit': {}, 'receive': {}},), is_leaf=True, yang_name="special-next-hop", parent=self, choice=('next-hop-options', 'special-next-hop'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='enumeration', is_config=False)


  def _get_next_hop_list(self):
    """
    Getter method for next_hop_list, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/next_hop_list (container)

    YANG Description: Container for multiple next hops.
    """
    return self.__next_hop_list
      
  def _set_next_hop_list(self, v, load=False):
    """
    Setter method for next_hop_list, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop/next_hop_list (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop_list() directly.

    YANG Description: Container for multiple next hops.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop_list must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop_list = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop_list(self):
    self.__next_hop_list = YANGDynClass(base=yc_next_hop_list_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list, is_container='container', yang_name="next-hop-list", parent=self, choice=('next-hop-options', 'next-hop-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  outgoing_interface = __builtin__.property(_get_outgoing_interface)
  special_next_hop = __builtin__.property(_get_special_next_hop)
  next_hop_list = __builtin__.property(_get_next_hop_list) # type: yc_next_hop_list_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop_next_hop_list

  __choices__ = {'next-hop-options': {'simple-next-hop': ['outgoing_interface'], 'special-next-hop': ['special_next_hop'], 'next-hop-list': ['next_hop_list']}}
  _pyangbind_elements = OrderedDict([('outgoing_interface', outgoing_interface), ('special_next_hop', special_next_hop), ('next_hop_list', next_hop_list), ])


class yc_route_ietf_routing__routing_state_ribs_rib_active_route_output_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/active-route/output/route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The active RIB route for the specified
destination.

If no route exists in the RIB for the destination
address, no output is returned.

Address-family-specific modules MUST augment this
container with appropriate route contents.
  """
  __slots__ = ('_path_helper', '_extmethods', '__next_hop','__source_protocol','__active','__last_updated',)

  _yang_name = 'route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'active-route', 'output', 'route']

  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop (container)

    YANG Description: Route's next-hop attribute.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/next_hop (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: Route's next-hop attribute.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop, is_container='container', yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_source_protocol(self):
    """
    Getter method for source_protocol, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/source_protocol (identityref)

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    return self.__source_protocol
      
  def _set_source_protocol(self, v, load=False):
    """
    Setter method for source_protocol, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/source_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_protocol() directly.

    YANG Description: Type of the routing protocol from which the route
originated.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_protocol must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__source_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_protocol(self):
    self.__source_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:direct': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:static': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}, 'bgp:bgp': {'@module': 'ietf-bgp', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-bgp'}},), is_leaf=True, yang_name="source-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/active (empty)

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/active (empty)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: Presence of this leaf indicates that the route is preferred
among all routes in the same RIB that have the same
destination prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with empty""",
          'defined-type': "empty",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='empty', is_config=False)


  def _get_last_updated(self):
    """
    Getter method for last_updated, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/last_updated (yang:date-and-time)

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    return self.__last_updated
      
  def _set_last_updated(self, v, load=False):
    """
    Setter method for last_updated, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route/last_updated (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_updated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_updated() directly.

    YANG Description: Time stamp of the last modification of the route.  If the
route was never modified, it is the time when the route was
inserted into the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_updated must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__last_updated = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_updated(self):
    self.__last_updated = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-(1[0-2]|0[1-9])-(0[1-9]|[1|2][0-9]|3[0-1])T(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.\\d+)?(Z|[\\+\\-]((1[0-3]|0[0-9]):([0-5][0-9])|14:00))?'}), is_leaf=True, yang_name="last-updated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:date-and-time', is_config=False)

  next_hop = __builtin__.property(_get_next_hop) # type: yc_next_hop_ietf_routing__routing_state_ribs_rib_active_route_output_route_next_hop
  source_protocol = __builtin__.property(_get_source_protocol)
  active = __builtin__.property(_get_active)
  last_updated = __builtin__.property(_get_last_updated)


  _pyangbind_elements = OrderedDict([('next_hop', next_hop), ('source_protocol', source_protocol), ('active', active), ('last_updated', last_updated), ])


class yc_output_ietf_routing__routing_state_ribs_rib_active_route_output(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/active-route/output. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__route',)

  _yang_name = 'output'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route = YANGDynClass(base=yc_route_ietf_routing__routing_state_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'active-route', 'output']

  def _get_route(self):
    """
    Getter method for route, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route (container)

    YANG Description: The active RIB route for the specified
destination.

If no route exists in the RIB for the destination
address, no output is returned.

Address-family-specific modules MUST augment this
container with appropriate route contents.
    """
    return self.__route
      
  def _set_route(self, v, load=False):
    """
    Setter method for route, mapped from YANG variable /routing_state/ribs/rib/active_route/output/route (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route() directly.

    YANG Description: The active RIB route for the specified
destination.

If no route exists in the RIB for the destination
address, no output is returned.

Address-family-specific modules MUST augment this
container with appropriate route contents.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_route_ietf_routing__routing_state_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_route_ietf_routing__routing_state_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route(self):
    self.__route = YANGDynClass(base=yc_route_ietf_routing__routing_state_ribs_rib_active_route_output_route, is_container='container', yang_name="route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  route = __builtin__.property(_get_route) # type: yc_route_ietf_routing__routing_state_ribs_rib_active_route_output_route


  _pyangbind_elements = OrderedDict([('route', route), ])


class yc_active_route_ietf_routing__routing_state_ribs_rib_active_route(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib/active-route. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Return the active RIB route that is used for the
destination address.

Address-family-specific modules MUST augment input
parameters with a leaf named 'destination-address'.
  """
  __slots__ = ('_path_helper', '_extmethods', '__output',)

  _yang_name = 'active-route'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_state_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib', 'active-route']

  def _get_output(self):
    """
    Getter method for output, mapped from YANG variable /routing_state/ribs/rib/active_route/output (output)
    """
    return self.__output
      
  def _set_output(self, v, load=False):
    """
    Setter method for output, mapped from YANG variable /routing_state/ribs/rib/active_route/output (output)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_output_ietf_routing__routing_state_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output must be of a type compatible with output""",
          'defined-type': "ietf-routing:output",
          'generated-type': """YANGDynClass(base=yc_output_ietf_routing__routing_state_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=False)""",
        })

    self.__output = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output(self):
    self.__output = YANGDynClass(base=yc_output_ietf_routing__routing_state_ribs_rib_active_route_output, is_leaf=True, yang_name="output", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='output', is_config=False)

  output = __builtin__.property(_get_output)


  _pyangbind_elements = OrderedDict([('output', output), ])


class yc_rib_ietf_routing__routing_state_ribs_rib(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs/rib. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry represents a RIB identified by the 'name'
key. All routes in a RIB MUST belong to the same address
family.

An implementation SHOULD provide one system-controlled
default RIB for each supported address family.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__address_family','__default_rib','__routes','__active_route',)

  _yang_name = 'rib'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__active_route = YANGDynClass(base=yc_active_route_ietf_routing__routing_state_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs', 'rib']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /routing_state/ribs/rib/name (string)

    YANG Description: The name of the RIB.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /routing_state/ribs/rib/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of the RIB.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='string', is_config=False)


  def _get_address_family(self):
    """
    Getter method for address_family, mapped from YANG variable /routing_state/ribs/rib/address_family (identityref)

    YANG Description: Address family.
    """
    return self.__address_family
      
  def _set_address_family(self, v, load=False):
    """
    Setter method for address_family, mapped from YANG variable /routing_state/ribs/rib/address_family (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_family is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_family() directly.

    YANG Description: Address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address_family must be of a type compatible with identityref""",
          'defined-type': "ietf-routing:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)""",
        })

    self.__address_family = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address_family(self):
    self.__address_family = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv4': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}, 'rt:ipv6': {'@module': 'ietf-routing', '@namespace': 'urn:ietf:params:xml:ns:yang:ietf-routing'}},), is_leaf=True, yang_name="address-family", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='identityref', is_config=False)


  def _get_default_rib(self):
    """
    Getter method for default_rib, mapped from YANG variable /routing_state/ribs/rib/default_rib (boolean)

    YANG Description: This flag has the value of 'true' if and only if the
RIB is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    return self.__default_rib
      
  def _set_default_rib(self, v, load=False):
    """
    Setter method for default_rib, mapped from YANG variable /routing_state/ribs/rib/default_rib (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_rib() directly.

    YANG Description: This flag has the value of 'true' if and only if the
RIB is the default RIB for the given address family.

By default, control-plane protocols place their routes
in the default RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_rib must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)""",
        })

    self.__default_rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_rib(self):
    self.__default_rib = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="default-rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='boolean', is_config=False)


  def _get_routes(self):
    """
    Getter method for routes, mapped from YANG variable /routing_state/ribs/rib/routes (container)

    YANG Description: Current content of the RIB.
    """
    return self.__routes
      
  def _set_routes(self, v, load=False):
    """
    Setter method for routes, mapped from YANG variable /routing_state/ribs/rib/routes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routes() directly.

    YANG Description: Current content of the RIB.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__routes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routes(self):
    self.__routes = YANGDynClass(base=yc_routes_ietf_routing__routing_state_ribs_rib_routes, is_container='container', yang_name="routes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_active_route(self):
    """
    Getter method for active_route, mapped from YANG variable /routing_state/ribs/rib/active_route (action)

    YANG Description: Return the active RIB route that is used for the
destination address.

Address-family-specific modules MUST augment input
parameters with a leaf named 'destination-address'.
    """
    return self.__active_route
      
  def _set_active_route(self, v, load=False):
    """
    Setter method for active_route, mapped from YANG variable /routing_state/ribs/rib/active_route (action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active_route() directly.

    YANG Description: Return the active RIB route that is used for the
destination address.

Address-family-specific modules MUST augment input
parameters with a leaf named 'destination-address'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_active_route_ietf_routing__routing_state_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active_route must be of a type compatible with action""",
          'defined-type': "ietf-routing:action",
          'generated-type': """YANGDynClass(base=yc_active_route_ietf_routing__routing_state_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=False)""",
        })

    self.__active_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active_route(self):
    self.__active_route = YANGDynClass(base=yc_active_route_ietf_routing__routing_state_ribs_rib_active_route, is_leaf=True, yang_name="active-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='action', is_config=False)

  name = __builtin__.property(_get_name)
  address_family = __builtin__.property(_get_address_family)
  default_rib = __builtin__.property(_get_default_rib)
  routes = __builtin__.property(_get_routes) # type: yc_routes_ietf_routing__routing_state_ribs_rib_routes
  active_route = __builtin__.property(_get_active_route)


  _pyangbind_elements = OrderedDict([('name', name), ('address_family', address_family), ('default_rib', default_rib), ('routes', routes), ('active_route', active_route), ])


class yc_ribs_ietf_routing__routing_state_ribs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state/ribs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for RIBs.
  """
  __slots__ = ('_path_helper', '_extmethods', '__rib',)

  _yang_name = 'ribs'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state', 'ribs']

  def _get_rib(self):
    """
    Getter method for rib, mapped from YANG variable /routing_state/ribs/rib (list)

    YANG Description: Each entry represents a RIB identified by the 'name'
key. All routes in a RIB MUST belong to the same address
family.

An implementation SHOULD provide one system-controlled
default RIB for each supported address family.
    """
    return self.__rib
      
  def _set_rib(self, v, load=False):
    """
    Setter method for rib, mapped from YANG variable /routing_state/ribs/rib (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rib is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rib() directly.

    YANG Description: Each entry represents a RIB identified by the 'name'
key. All routes in a RIB MUST belong to the same address
family.

An implementation SHOULD provide one system-controlled
default RIB for each supported address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """rib must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)""",
        })

    self.__rib = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_rib(self):
    self.__rib = YANGDynClass(base=YANGListType("name",yc_rib_ietf_routing__routing_state_ribs_rib, yang_name="rib", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="rib", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='list', is_config=False)

  rib = __builtin__.property(_get_rib) # type: yc_rib_ietf_routing__routing_state_ribs_rib


  _pyangbind_elements = OrderedDict([('rib', rib), ])


class yc_routing_state_ietf_routing__routing_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /routing-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data of the routing subsystem.
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__interfaces','__control_plane_protocols','__ribs',)

  _yang_name = 'routing-state'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['routing-state']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /routing_state/router_id (yang:dotted-quad)

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /routing_state/router_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: A 32-bit number in the form of a dotted quad that is used by
some routing protocols identifying a router.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='yang:dotted-quad', is_config=False)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /routing_state/interfaces (container)

    YANG Description: Network-layer interfaces used for routing.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /routing_state/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Network-layer interfaces used for routing.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_ietf_routing__routing_state_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_control_plane_protocols(self):
    """
    Getter method for control_plane_protocols, mapped from YANG variable /routing_state/control_plane_protocols (container)

    YANG Description: Container for the list of routing protocol instances.
    """
    return self.__control_plane_protocols
      
  def _set_control_plane_protocols(self, v, load=False):
    """
    Setter method for control_plane_protocols, mapped from YANG variable /routing_state/control_plane_protocols (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_protocols is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_protocols() directly.

    YANG Description: Container for the list of routing protocol instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_protocols must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__control_plane_protocols = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_protocols(self):
    self.__control_plane_protocols = YANGDynClass(base=yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols, is_container='container', yang_name="control-plane-protocols", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)


  def _get_ribs(self):
    """
    Getter method for ribs, mapped from YANG variable /routing_state/ribs (container)

    YANG Description: Container for RIBs.
    """
    return self.__ribs
      
  def _set_ribs(self, v, load=False):
    """
    Setter method for ribs, mapped from YANG variable /routing_state/ribs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ribs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ribs() directly.

    YANG Description: Container for RIBs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ribs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)""",
        })

    self.__ribs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ribs(self):
    self.__ribs = YANGDynClass(base=yc_ribs_ietf_routing__routing_state_ribs, is_container='container', yang_name="ribs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=False)

  router_id = __builtin__.property(_get_router_id)
  interfaces = __builtin__.property(_get_interfaces) # type: yc_interfaces_ietf_routing__routing_state_interfaces
  control_plane_protocols = __builtin__.property(_get_control_plane_protocols) # type: yc_control_plane_protocols_ietf_routing__routing_state_control_plane_protocols
  ribs = __builtin__.property(_get_ribs) # type: yc_ribs_ietf_routing__routing_state_ribs


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('interfaces', interfaces), ('control_plane_protocols', control_plane_protocols), ('ribs', ribs), ])


class ietf_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-routing - based on the path /ietf-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines essential components for the management
of a routing subsystem. The model fully conforms to the Network
Management Datastore Architecture (NMDA).

Copyright (c) 2017 IETF Trust and the persons
identified as authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX; see
the RFC itself for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routing','__routing_state',)

  _yang_name = 'ietf-routing'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-routing'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routing = YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    self.__routing_state = YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_routing(self):
    """
    Getter method for routing, mapped from YANG variable /routing (container)

    YANG Description: Configuration parameters for the routing subsystem.
    """
    return self.__routing
      
  def _set_routing(self, v, load=False):
    """
    Setter method for routing, mapped from YANG variable /routing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing() directly.

    YANG Description: Configuration parameters for the routing subsystem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing(self):
    self.__routing = YANGDynClass(base=yc_routing_ietf_routing__routing, is_container='container', yang_name="routing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)


  def _get_routing_state(self):
    """
    Getter method for routing_state, mapped from YANG variable /routing_state (container)

    YANG Description: State data of the routing subsystem.
    """
    return self.__routing_state
      
  def _set_routing_state(self, v, load=False):
    """
    Setter method for routing_state, mapped from YANG variable /routing_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_state() directly.

    YANG Description: State data of the routing subsystem.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)""",
        })

    self.__routing_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_state(self):
    self.__routing_state = YANGDynClass(base=yc_routing_state_ietf_routing__routing_state, is_container='container', yang_name="routing-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-routing', defining_module='ietf-routing', yang_type='container', is_config=True)

  routing = __builtin__.property(_get_routing, _set_routing) # type: yc_routing_ietf_routing__routing
  routing_state = __builtin__.property(_get_routing_state, _set_routing_state) # type: yc_routing_state_ietf_routing__routing_state


  _pyangbind_elements = OrderedDict([('routing', routing), ('routing_state', routing_state), ])


class ietf_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-bgp - based on the path /ietf-bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a YANG model for BGP protocol
configuration. It is a limited subset of all of the configuration
parameters available in the variety of vendor implementations,
hence it is expected that it would be augmented with vendor-
specific configuration data as needed. Additional modules or
submodules to handle other aspects of BGP configuration,
including policy, VRFs, VPNs, and additional address families
are also expected.

This model supports the following BGP configuration level
hierarchy:

 BGP
   |
   +-> [ global BGP configuration ]
     +-> AFI / SAFI global
   +-> peer group
     +-> [ peer group config ]
     +-> AFI / SAFI [ per-AFI overrides ]
   +-> neighbor
     +-> [ neighbor config ]
     +-> [ optional pointer to peer-group ]
     +-> AFI / SAFI [ per-AFI overrides ]

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.
  """
  _pyangbind_elements = {}

  

class ietf_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-bgp-common - based on the path /ietf-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that
they may be application to a subset of global, peer-group or
neighbor contexts.

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.
  """
  _pyangbind_elements = {}

  

class ietf_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-bgp-common-multiprotocol - based on the path /ietf-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.
  """
  _pyangbind_elements = {}

  

class ietf_bgp_common_structure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-bgp-common-structure - based on the path /ietf-bgp-common-structure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are common across
multiple BGP contexts and provide structure around other
primitive groupings.

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.
  """
  _pyangbind_elements = {}

  

class ietf_bgp_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-bgp-neighbor - based on the path /ietf-bgp-neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
neighbor context of the BGP module.

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.
  """
  _pyangbind_elements = {}

  

class ietf_bgp_peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-bgp-peer-group - based on the path /ietf-bgp-peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
peer-group context of the BGP module.

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.
  """
  _pyangbind_elements = {}

  

class ietf_bgp_rib_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-bgp-rib-types - based on the path /ietf-bgp-rib-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines identity and type definitions associated with
the BGP RIB modules.

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.
  """
  _pyangbind_elements = {}

  

class ietf_bgp_rib(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-bgp-rib - based on the path /ietf-bgp-rib. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines a submodule for representing BGP routing table (RIB)
contents.  The submodule supports 5 logical RIBs per address
family:

loc-rib: This is the main BGP routing table for the local routing
instance, containing best-path selections for each prefix. The
loc-rib table may contain multiple routes for a given prefix,
with an attribute to indicate which was selected as the best
path.  Note that multiple paths may be used or advertised even if
only one path is marked as best, e.g., when using BGP
add-paths.  An implementation may choose to mark multiple
paths in the RIB as best path by setting the flag to true for
multiple entries.

adj-rib-in-pre: This is a per-neighbor table containing the NLRI
updates received from the neighbor before any local input policy
rules or filters have been applied.  This can be considered the
'raw' updates from a given neighbor.

adj-rib-in-post: This is a per-neighbor table containing the
routes received from the neighbor that are eligible for
best-path selection after local input policy rules have been
applied.

adj-rib-out-pre: This is a per-neighbor table containing routes
eligible for sending (advertising) to the neighbor before output
policy rules have been applied.

adj-rib-out-post: This is a per-neighbor table containing routes
eligible for sending (advertising) to the neighbor after output
policy rules have been applied.

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.
The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.
  """
  _pyangbind_elements = {}

  

class ietf_bgp_rib_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-bgp-rib-ext - based on the path /ietf-bgp-rib-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines additional data nodes for the BGP RIB model.
These items reflect extensions that are desirable features but
are not currently supported in a majority of BGP
implementations.

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.
  """
  _pyangbind_elements = {}

  

class ietf_bgp_rib_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-bgp-rib-attributes - based on the path /ietf-bgp-rib-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for BGP
attributes for use in BGP RIB tables.

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.
  """
  _pyangbind_elements = {}

  

class ietf_bgp_rib_table_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-bgp-rib-table-attributes - based on the path /ietf-bgp-rib-table-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for data
related to a RIB entry, or RIB table.

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.
  """
  _pyangbind_elements = {}

  

class ietf_bgp_rib_tables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-bgp-rib-tables - based on the path /ietf-bgp-rib-tables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains structural data definitions for
BGP routing tables.

Copyright (c) 2019 IETF Trust and the persons identified as
authors of the code. All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC XXXX
(https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
for full legal notices.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in this document are to be interpreted as
described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
they appear in all capitals, as shown here.
  """
  _pyangbind_elements = {}

  

class ietf_bgp_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-bgp-types - based on the path /ietf-bgp-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in BGP
policy. It can be imported by modules that make use of BGP
attributes
  """
  _pyangbind_elements = {}

  

