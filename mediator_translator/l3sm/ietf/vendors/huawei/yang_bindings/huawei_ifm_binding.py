# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_ipv4_conflict_enable_huawei_ifm__ifm_global_ipv4_conflict_enable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/global/ipv4-conflict-enable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable/disable ip conflict function.
  """
  __slots__ = ('_path_helper', '_extmethods', '__preempt_enable',)

  _yang_name = 'ipv4-conflict-enable'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__preempt_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'global', 'ipv4-conflict-enable']

  def _get_preempt_enable(self):
    """
    Getter method for preempt_enable, mapped from YANG variable /ifm/global/ipv4_conflict_enable/preempt_enable (boolean)

    YANG Description: Enable/disable IPv4 address conflict preemption.
    """
    return self.__preempt_enable
      
  def _set_preempt_enable(self, v, load=False):
    """
    Setter method for preempt_enable, mapped from YANG variable /ifm/global/ipv4_conflict_enable/preempt_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt_enable() directly.

    YANG Description: Enable/disable IPv4 address conflict preemption.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__preempt_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt_enable(self):
    self.__preempt_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)

  preempt_enable = __builtin__.property(_get_preempt_enable, _set_preempt_enable)


  _pyangbind_elements = OrderedDict([('preempt_enable', preempt_enable), ])


class yc_ipv6_conflict_enable_huawei_ifm__ifm_global_ipv6_conflict_enable(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/global/ipv6-conflict-enable. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable/disable IPv6 conflict function.
  """
  __slots__ = ('_path_helper', '_extmethods', '__preempt_enable',)

  _yang_name = 'ipv6-conflict-enable'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__preempt_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'global', 'ipv6-conflict-enable']

  def _get_preempt_enable(self):
    """
    Getter method for preempt_enable, mapped from YANG variable /ifm/global/ipv6_conflict_enable/preempt_enable (boolean)

    YANG Description: Enable/disable IPv6 address conflict preemption.
    """
    return self.__preempt_enable
      
  def _set_preempt_enable(self, v, load=False):
    """
    Setter method for preempt_enable, mapped from YANG variable /ifm/global/ipv6_conflict_enable/preempt_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt_enable() directly.

    YANG Description: Enable/disable IPv6 address conflict preemption.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__preempt_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt_enable(self):
    self.__preempt_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)

  preempt_enable = __builtin__.property(_get_preempt_enable, _set_preempt_enable)


  _pyangbind_elements = OrderedDict([('preempt_enable', preempt_enable), ])


class yc_global__huawei_ifm__ifm_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure globally configured attributes.
  """
  __slots__ = ('_path_helper', '_extmethods', '__statistic_interval','__ipv4_ignore_primary_sub','__sub_interface_link_trap_enable','__ipv4_conflict_enable','__ipv6_conflict_enable',)

  _yang_name = 'global'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__statistic_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__ipv4_ignore_primary_sub = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv4-ignore-primary-sub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__sub_interface_link_trap_enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sub-interface-link-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__ipv4_conflict_enable = YANGDynClass(base=yc_ipv4_conflict_enable_huawei_ifm__ifm_global_ipv4_conflict_enable, is_container='container', yang_name="ipv4-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__ipv6_conflict_enable = YANGDynClass(base=yc_ipv6_conflict_enable_huawei_ifm__ifm_global_ipv6_conflict_enable, is_container='container', yang_name="ipv6-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'global']

  def _get_statistic_interval(self):
    """
    Getter method for statistic_interval, mapped from YANG variable /ifm/global/statistic_interval (uint32)

    YANG Description: Set the interval at which global flow statistics are collected.
    """
    return self.__statistic_interval
      
  def _set_statistic_interval(self, v, load=False):
    """
    Setter method for statistic_interval, mapped from YANG variable /ifm/global/statistic_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistic_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistic_interval() directly.

    YANG Description: Set the interval at which global flow statistics are collected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistic_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__statistic_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistic_interval(self):
    self.__statistic_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_ipv4_ignore_primary_sub(self):
    """
    Getter method for ipv4_ignore_primary_sub, mapped from YANG variable /ifm/global/ipv4_ignore_primary_sub (boolean)

    YANG Description: Enable/disable the function of ignoring primary/secondary of IPv4 address type. All secondary addresses must be deleted before this function is enabled.
    """
    return self.__ipv4_ignore_primary_sub
      
  def _set_ipv4_ignore_primary_sub(self, v, load=False):
    """
    Setter method for ipv4_ignore_primary_sub, mapped from YANG variable /ifm/global/ipv4_ignore_primary_sub (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_ignore_primary_sub is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_ignore_primary_sub() directly.

    YANG Description: Enable/disable the function of ignoring primary/secondary of IPv4 address type. All secondary addresses must be deleted before this function is enabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv4-ignore-primary-sub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_ignore_primary_sub must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv4-ignore-primary-sub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__ipv4_ignore_primary_sub = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_ignore_primary_sub(self):
    self.__ipv4_ignore_primary_sub = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ipv4-ignore-primary-sub", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_sub_interface_link_trap_enable(self):
    """
    Getter method for sub_interface_link_trap_enable, mapped from YANG variable /ifm/global/sub_interface_link_trap_enable (boolean)

    YANG Description: Enable/disable the trap function on all Sub-interface.
    """
    return self.__sub_interface_link_trap_enable
      
  def _set_sub_interface_link_trap_enable(self, v, load=False):
    """
    Setter method for sub_interface_link_trap_enable, mapped from YANG variable /ifm/global/sub_interface_link_trap_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sub_interface_link_trap_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sub_interface_link_trap_enable() directly.

    YANG Description: Enable/disable the trap function on all Sub-interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sub-interface-link-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sub_interface_link_trap_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sub-interface-link-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__sub_interface_link_trap_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sub_interface_link_trap_enable(self):
    self.__sub_interface_link_trap_enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="sub-interface-link-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_ipv4_conflict_enable(self):
    """
    Getter method for ipv4_conflict_enable, mapped from YANG variable /ifm/global/ipv4_conflict_enable (container)

    YANG Description: Enable/disable ip conflict function.
    """
    return self.__ipv4_conflict_enable
      
  def _set_ipv4_conflict_enable(self, v, load=False):
    """
    Setter method for ipv4_conflict_enable, mapped from YANG variable /ifm/global/ipv4_conflict_enable (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_conflict_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_conflict_enable() directly.

    YANG Description: Enable/disable ip conflict function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_conflict_enable_huawei_ifm__ifm_global_ipv4_conflict_enable, is_container='container', yang_name="ipv4-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_conflict_enable must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_conflict_enable_huawei_ifm__ifm_global_ipv4_conflict_enable, is_container='container', yang_name="ipv4-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__ipv4_conflict_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_conflict_enable(self):
    self.__ipv4_conflict_enable = YANGDynClass(base=yc_ipv4_conflict_enable_huawei_ifm__ifm_global_ipv4_conflict_enable, is_container='container', yang_name="ipv4-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_ipv6_conflict_enable(self):
    """
    Getter method for ipv6_conflict_enable, mapped from YANG variable /ifm/global/ipv6_conflict_enable (container)

    YANG Description: Enable/disable IPv6 conflict function.
    """
    return self.__ipv6_conflict_enable
      
  def _set_ipv6_conflict_enable(self, v, load=False):
    """
    Setter method for ipv6_conflict_enable, mapped from YANG variable /ifm/global/ipv6_conflict_enable (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_conflict_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_conflict_enable() directly.

    YANG Description: Enable/disable IPv6 conflict function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_conflict_enable_huawei_ifm__ifm_global_ipv6_conflict_enable, is_container='container', yang_name="ipv6-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_conflict_enable must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_conflict_enable_huawei_ifm__ifm_global_ipv6_conflict_enable, is_container='container', yang_name="ipv6-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__ipv6_conflict_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_conflict_enable(self):
    self.__ipv6_conflict_enable = YANGDynClass(base=yc_ipv6_conflict_enable_huawei_ifm__ifm_global_ipv6_conflict_enable, is_container='container', yang_name="ipv6-conflict-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

  statistic_interval = __builtin__.property(_get_statistic_interval, _set_statistic_interval)
  ipv4_ignore_primary_sub = __builtin__.property(_get_ipv4_ignore_primary_sub, _set_ipv4_ignore_primary_sub)
  sub_interface_link_trap_enable = __builtin__.property(_get_sub_interface_link_trap_enable, _set_sub_interface_link_trap_enable)
  ipv4_conflict_enable = __builtin__.property(_get_ipv4_conflict_enable, _set_ipv4_conflict_enable) # type: yc_ipv4_conflict_enable_huawei_ifm__ifm_global_ipv4_conflict_enable
  ipv6_conflict_enable = __builtin__.property(_get_ipv6_conflict_enable, _set_ipv6_conflict_enable) # type: yc_ipv6_conflict_enable_huawei_ifm__ifm_global_ipv6_conflict_enable


  _pyangbind_elements = OrderedDict([('statistic_interval', statistic_interval), ('ipv4_ignore_primary_sub', ipv4_ignore_primary_sub), ('sub_interface_link_trap_enable', sub_interface_link_trap_enable), ('ipv4_conflict_enable', ipv4_conflict_enable), ('ipv6_conflict_enable', ipv6_conflict_enable), ])


class yc_auto_huawei_ifm__ifm_damp_auto(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/damp/auto. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure an auto suppression level.
  """
  __slots__ = ('_path_helper', '_extmethods', '__level',)

  _yang_name = 'auto'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'damp', 'auto']

  def _get_level(self):
    """
    Getter method for level, mapped from YANG variable /ifm/damp/auto/level (damp-level-type)

    YANG Description: Auto damping level.
    """
    return self.__level
      
  def _set_level(self, v, load=False):
    """
    Setter method for level, mapped from YANG variable /ifm/damp/auto/level (damp-level-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level() directly.

    YANG Description: Auto damping level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level must be of a type compatible with damp-level-type""",
          'defined-type': "huawei-ifm:damp-level-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)""",
        })

    self.__level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level(self):
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)

  level = __builtin__.property(_get_level, _set_level)

  __choices__ = {'level': {'auto': ['level']}}
  _pyangbind_elements = OrderedDict([('level', level), ])


class yc_manual_huawei_ifm__ifm_damp_manual(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/damp/manual. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure a manual suppression level.
  """
  __slots__ = ('_path_helper', '_extmethods', '__suppress','__reuse','__max_suppress_time','__half_life_period',)

  _yang_name = 'manual'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__max_suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)
    self.__half_life_period = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'damp', 'manual']

  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /ifm/damp/manual/suppress (uint32)

    YANG Description: 1000 times of suppress threshold.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /ifm/damp/manual/suppress (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: 1000 times of suppress threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_reuse(self):
    """
    Getter method for reuse, mapped from YANG variable /ifm/damp/manual/reuse (uint32)

    YANG Description: 1000 times of reuse threshold.
    """
    return self.__reuse
      
  def _set_reuse(self, v, load=False):
    """
    Setter method for reuse, mapped from YANG variable /ifm/damp/manual/reuse (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse() directly.

    YANG Description: 1000 times of reuse threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__reuse = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse(self):
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_max_suppress_time(self):
    """
    Getter method for max_suppress_time, mapped from YANG variable /ifm/damp/manual/max_suppress_time (uint16)

    YANG Description: Max suppress time.
    """
    return self.__max_suppress_time
      
  def _set_max_suppress_time(self, v, load=False):
    """
    Setter method for max_suppress_time, mapped from YANG variable /ifm/damp/manual/max_suppress_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_suppress_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_suppress_time() directly.

    YANG Description: Max suppress time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_suppress_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)""",
        })

    self.__max_suppress_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_suppress_time(self):
    self.__max_suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)


  def _get_half_life_period(self):
    """
    Getter method for half_life_period, mapped from YANG variable /ifm/damp/manual/half_life_period (uint16)

    YANG Description: Half life time.
    """
    return self.__half_life_period
      
  def _set_half_life_period(self, v, load=False):
    """
    Setter method for half_life_period, mapped from YANG variable /ifm/damp/manual/half_life_period (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_half_life_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_half_life_period() directly.

    YANG Description: Half life time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """half_life_period must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)""",
        })

    self.__half_life_period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_half_life_period(self):
    self.__half_life_period = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)

  suppress = __builtin__.property(_get_suppress, _set_suppress)
  reuse = __builtin__.property(_get_reuse, _set_reuse)
  max_suppress_time = __builtin__.property(_get_max_suppress_time, _set_max_suppress_time)
  half_life_period = __builtin__.property(_get_half_life_period, _set_half_life_period)

  __choices__ = {'level': {'manual': ['suppress', 'reuse', 'max_suppress_time', 'half_life_period']}}
  _pyangbind_elements = OrderedDict([('suppress', suppress), ('reuse', reuse), ('max_suppress_time', max_suppress_time), ('half_life_period', half_life_period), ])


class yc_damp_huawei_ifm__ifm_damp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/damp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable/disable suppression on interfaces' physical status flappings.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tx_off','__auto','__manual',)

  _yang_name = 'damp'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tx_off = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__auto = YANGDynClass(base=yc_auto_huawei_ifm__ifm_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__manual = YANGDynClass(base=yc_manual_huawei_ifm__ifm_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'damp']

  def _get_tx_off(self):
    """
    Getter method for tx_off, mapped from YANG variable /ifm/damp/tx_off (boolean)

    YANG Description: Enable/disable interfaces from sending signals if the interfaces' physical status flappings are suppressed.
    """
    return self.__tx_off
      
  def _set_tx_off(self, v, load=False):
    """
    Setter method for tx_off, mapped from YANG variable /ifm/damp/tx_off (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_off is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_off() directly.

    YANG Description: Enable/disable interfaces from sending signals if the interfaces' physical status flappings are suppressed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_off must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__tx_off = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_off(self):
    self.__tx_off = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_auto(self):
    """
    Getter method for auto, mapped from YANG variable /ifm/damp/auto (container)

    YANG Description: Configure an auto suppression level.
    """
    return self.__auto
      
  def _set_auto(self, v, load=False):
    """
    Setter method for auto, mapped from YANG variable /ifm/damp/auto (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto() directly.

    YANG Description: Configure an auto suppression level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_auto_huawei_ifm__ifm_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_auto_huawei_ifm__ifm_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__auto = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto(self):
    self.__auto = YANGDynClass(base=yc_auto_huawei_ifm__ifm_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_manual(self):
    """
    Getter method for manual, mapped from YANG variable /ifm/damp/manual (container)

    YANG Description: Configure a manual suppression level.
    """
    return self.__manual
      
  def _set_manual(self, v, load=False):
    """
    Setter method for manual, mapped from YANG variable /ifm/damp/manual (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_manual is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_manual() directly.

    YANG Description: Configure a manual suppression level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_manual_huawei_ifm__ifm_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """manual must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_manual_huawei_ifm__ifm_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__manual = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_manual(self):
    self.__manual = YANGDynClass(base=yc_manual_huawei_ifm__ifm_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

  tx_off = __builtin__.property(_get_tx_off, _set_tx_off)
  auto = __builtin__.property(_get_auto, _set_auto) # type: yc_auto_huawei_ifm__ifm_damp_auto
  manual = __builtin__.property(_get_manual, _set_manual) # type: yc_manual_huawei_ifm__ifm_damp_manual

  __choices__ = {'level': {'auto': ['auto'], 'manual': ['manual']}}
  _pyangbind_elements = OrderedDict([('tx_off', tx_off), ('auto', auto), ('manual', manual), ])


class yc_auto_recovery_time_huawei_ifm__ifm_auto_recovery_times_auto_recovery_time(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/auto-recovery-times/auto-recovery-time. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure automatic recovery time.
  """
  __slots__ = ('_path_helper', '_extmethods', '__error_down_type','__time_value',)

  _yang_name = 'auto-recovery-time'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__error_down_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="error-down-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=True)
    self.__time_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['30..86400']}), is_leaf=True, yang_name="time-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'auto-recovery-times', 'auto-recovery-time']

  def _get_error_down_type(self):
    """
    Getter method for error_down_type, mapped from YANG variable /ifm/auto_recovery_times/auto_recovery_time/error_down_type (error-down-type)

    YANG Description: Cause of the error-down event.
    """
    return self.__error_down_type
      
  def _set_error_down_type(self, v, load=False):
    """
    Setter method for error_down_type, mapped from YANG variable /ifm/auto_recovery_times/auto_recovery_time/error_down_type (error-down-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_down_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_down_type() directly.

    YANG Description: Cause of the error-down event.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="error-down-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_down_type must be of a type compatible with error-down-type""",
          'defined-type': "huawei-ifm:error-down-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="error-down-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=True)""",
        })

    self.__error_down_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_down_type(self):
    self.__error_down_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="error-down-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=True)


  def _get_time_value(self):
    """
    Getter method for time_value, mapped from YANG variable /ifm/auto_recovery_times/auto_recovery_time/time_value (uint32)

    YANG Description: Delay for the status transition from down to up.
    """
    return self.__time_value
      
  def _set_time_value(self, v, load=False):
    """
    Setter method for time_value, mapped from YANG variable /ifm/auto_recovery_times/auto_recovery_time/time_value (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_value() directly.

    YANG Description: Delay for the status transition from down to up.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['30..86400']}), is_leaf=True, yang_name="time-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_value must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['30..86400']}), is_leaf=True, yang_name="time-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__time_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_value(self):
    self.__time_value = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['30..86400']}), is_leaf=True, yang_name="time-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)

  error_down_type = __builtin__.property(_get_error_down_type, _set_error_down_type)
  time_value = __builtin__.property(_get_time_value, _set_time_value)


  _pyangbind_elements = OrderedDict([('error_down_type', error_down_type), ('time_value', time_value), ])


class yc_auto_recovery_times_huawei_ifm__ifm_auto_recovery_times(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/auto-recovery-times. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of automatic recovery time configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__auto_recovery_time',)

  _yang_name = 'auto-recovery-times'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__auto_recovery_time = YANGDynClass(base=YANGListType("error_down_type",yc_auto_recovery_time_huawei_ifm__ifm_auto_recovery_times_auto_recovery_time, yang_name="auto-recovery-time", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='error-down-type', extensions=None), is_container='list', yang_name="auto-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'auto-recovery-times']

  def _get_auto_recovery_time(self):
    """
    Getter method for auto_recovery_time, mapped from YANG variable /ifm/auto_recovery_times/auto_recovery_time (list)

    YANG Description: Configure automatic recovery time.
    """
    return self.__auto_recovery_time
      
  def _set_auto_recovery_time(self, v, load=False):
    """
    Setter method for auto_recovery_time, mapped from YANG variable /ifm/auto_recovery_times/auto_recovery_time (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_recovery_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_recovery_time() directly.

    YANG Description: Configure automatic recovery time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("error_down_type",yc_auto_recovery_time_huawei_ifm__ifm_auto_recovery_times_auto_recovery_time, yang_name="auto-recovery-time", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='error-down-type', extensions=None), is_container='list', yang_name="auto-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_recovery_time must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("error_down_type",yc_auto_recovery_time_huawei_ifm__ifm_auto_recovery_times_auto_recovery_time, yang_name="auto-recovery-time", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='error-down-type', extensions=None), is_container='list', yang_name="auto-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)""",
        })

    self.__auto_recovery_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_recovery_time(self):
    self.__auto_recovery_time = YANGDynClass(base=YANGListType("error_down_type",yc_auto_recovery_time_huawei_ifm__ifm_auto_recovery_times_auto_recovery_time, yang_name="auto-recovery-time", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='error-down-type', extensions=None), is_container='list', yang_name="auto-recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)

  auto_recovery_time = __builtin__.property(_get_auto_recovery_time, _set_auto_recovery_time) # type: yc_auto_recovery_time_huawei_ifm__ifm_auto_recovery_times_auto_recovery_time


  _pyangbind_elements = OrderedDict([('auto_recovery_time', auto_recovery_time), ])


class yc_control_flap_huawei_ifm__ifm_interfaces_interface_control_flap(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/control-flap. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable/disable flapping control on an interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__suppress','__reuse','__ceiling','__decay_ok','__decay_ng','__control_flap_count',)

  _yang_name = 'control-flap'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2000), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(750), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__ceiling = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1001..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(6000), is_leaf=True, yang_name="ceiling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__decay_ok = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ok", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__decay_ng = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ng", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__control_flap_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="control-flap-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'control-flap']

  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /ifm/interfaces/interface/control_flap/suppress (uint32)

    YANG Description: Suppression threshold on an interface. The value must be greater than the reusing threshold and smaller than the suppression upper limit.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /ifm/interfaces/interface/control_flap/suppress (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: Suppression threshold on an interface. The value must be greater than the reusing threshold and smaller than the suppression upper limit.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2000), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2000), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(2000), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_reuse(self):
    """
    Getter method for reuse, mapped from YANG variable /ifm/interfaces/interface/control_flap/reuse (uint32)

    YANG Description: Reusing threshold of an interface. The value must be smaller than the suppression threshold.
    """
    return self.__reuse
      
  def _set_reuse(self, v, load=False):
    """
    Setter method for reuse, mapped from YANG variable /ifm/interfaces/interface/control_flap/reuse (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse() directly.

    YANG Description: Reusing threshold of an interface. The value must be smaller than the suppression threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(750), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(750), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__reuse = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse(self):
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(750), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_ceiling(self):
    """
    Getter method for ceiling, mapped from YANG variable /ifm/interfaces/interface/control_flap/ceiling (uint32)

    YANG Description: Maximum suppression value on an interface. The value should be greater than the damping suppression threshold.
    """
    return self.__ceiling
      
  def _set_ceiling(self, v, load=False):
    """
    Setter method for ceiling, mapped from YANG variable /ifm/interfaces/interface/control_flap/ceiling (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ceiling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ceiling() directly.

    YANG Description: Maximum suppression value on an interface. The value should be greater than the damping suppression threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1001..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(6000), is_leaf=True, yang_name="ceiling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ceiling must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1001..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(6000), is_leaf=True, yang_name="ceiling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__ceiling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ceiling(self):
    self.__ceiling = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1001..20000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(6000), is_leaf=True, yang_name="ceiling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_decay_ok(self):
    """
    Getter method for decay_ok, mapped from YANG variable /ifm/interfaces/interface/control_flap/decay_ok (uint32)

    YANG Description: The penalty value of an Up interface attenuates to 1/2.
    """
    return self.__decay_ok
      
  def _set_decay_ok(self, v, load=False):
    """
    Setter method for decay_ok, mapped from YANG variable /ifm/interfaces/interface/control_flap/decay_ok (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decay_ok is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decay_ok() directly.

    YANG Description: The penalty value of an Up interface attenuates to 1/2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ok", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decay_ok must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ok", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__decay_ok = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decay_ok(self):
    self.__decay_ok = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ok", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_decay_ng(self):
    """
    Getter method for decay_ng, mapped from YANG variable /ifm/interfaces/interface/control_flap/decay_ng (uint32)

    YANG Description: The penalty value of a Down interface attenuates to 1/2.
    """
    return self.__decay_ng
      
  def _set_decay_ng(self, v, load=False):
    """
    Setter method for decay_ng, mapped from YANG variable /ifm/interfaces/interface/control_flap/decay_ng (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decay_ng is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decay_ng() directly.

    YANG Description: The penalty value of a Down interface attenuates to 1/2.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ng", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decay_ng must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ng", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__decay_ng = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decay_ng(self):
    self.__decay_ng = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..900']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(54), is_leaf=True, yang_name="decay-ng", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_control_flap_count(self):
    """
    Getter method for control_flap_count, mapped from YANG variable /ifm/interfaces/interface/control_flap/control_flap_count (uint32)

    YANG Description: Status suppression count of an interface.
    """
    return self.__control_flap_count
      
  def _set_control_flap_count(self, v, load=False):
    """
    Setter method for control_flap_count, mapped from YANG variable /ifm/interfaces/interface/control_flap/control_flap_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_flap_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_flap_count() directly.

    YANG Description: Status suppression count of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="control-flap-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_flap_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="control-flap-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__control_flap_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_flap_count(self):
    self.__control_flap_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="control-flap-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

  suppress = __builtin__.property(_get_suppress, _set_suppress)
  reuse = __builtin__.property(_get_reuse, _set_reuse)
  ceiling = __builtin__.property(_get_ceiling, _set_ceiling)
  decay_ok = __builtin__.property(_get_decay_ok, _set_decay_ok)
  decay_ng = __builtin__.property(_get_decay_ng, _set_decay_ng)
  control_flap_count = __builtin__.property(_get_control_flap_count)


  _pyangbind_elements = OrderedDict([('suppress', suppress), ('reuse', reuse), ('ceiling', ceiling), ('decay_ok', decay_ok), ('decay_ng', decay_ng), ('control_flap_count', control_flap_count), ])


class yc_trap_threshold_huawei_ifm__ifm_interfaces_interface_trap_threshold(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/trap-threshold. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the trap threshold.
  """
  __slots__ = ('_path_helper', '_extmethods', '__input_rising_rate','__input_resume_rate','__output_rising_rate','__output_resume_rate',)

  _yang_name = 'trap-threshold'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__input_rising_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__input_resume_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__output_rising_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__output_resume_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'trap-threshold']

  def _get_input_rising_rate(self):
    """
    Getter method for input_rising_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/input_rising_rate (uint32)

    YANG Description: Input bandwidth usage trap threshold.
    """
    return self.__input_rising_rate
      
  def _set_input_rising_rate(self, v, load=False):
    """
    Setter method for input_rising_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/input_rising_rate (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_rising_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_rising_rate() directly.

    YANG Description: Input bandwidth usage trap threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_rising_rate must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__input_rising_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_rising_rate(self):
    self.__input_rising_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_input_resume_rate(self):
    """
    Getter method for input_resume_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/input_resume_rate (uint32)

    YANG Description: Input bandwidth usage resume threshold.
    """
    return self.__input_resume_rate
      
  def _set_input_resume_rate(self, v, load=False):
    """
    Setter method for input_resume_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/input_resume_rate (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_resume_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_resume_rate() directly.

    YANG Description: Input bandwidth usage resume threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_resume_rate must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__input_resume_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_resume_rate(self):
    self.__input_resume_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="input-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_output_rising_rate(self):
    """
    Getter method for output_rising_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/output_rising_rate (uint32)

    YANG Description: Output bandwidth usage trap threshold.
    """
    return self.__output_rising_rate
      
  def _set_output_rising_rate(self, v, load=False):
    """
    Setter method for output_rising_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/output_rising_rate (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_rising_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_rising_rate() directly.

    YANG Description: Output bandwidth usage trap threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_rising_rate must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__output_rising_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_rising_rate(self):
    self.__output_rising_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-rising-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_output_resume_rate(self):
    """
    Getter method for output_resume_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/output_resume_rate (uint32)

    YANG Description: Output bandwidth usage resume threshold.
    """
    return self.__output_resume_rate
      
  def _set_output_resume_rate(self, v, load=False):
    """
    Setter method for output_resume_rate, mapped from YANG variable /ifm/interfaces/interface/trap_threshold/output_resume_rate (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_resume_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_resume_rate() directly.

    YANG Description: Output bandwidth usage resume threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_resume_rate must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__output_resume_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_resume_rate(self):
    self.__output_resume_rate = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..100']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(100), is_leaf=True, yang_name="output-resume-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)

  input_rising_rate = __builtin__.property(_get_input_rising_rate, _set_input_rising_rate)
  input_resume_rate = __builtin__.property(_get_input_resume_rate, _set_input_resume_rate)
  output_rising_rate = __builtin__.property(_get_output_rising_rate, _set_output_rising_rate)
  output_resume_rate = __builtin__.property(_get_output_resume_rate, _set_output_resume_rate)


  _pyangbind_elements = OrderedDict([('input_rising_rate', input_rising_rate), ('input_resume_rate', input_resume_rate), ('output_rising_rate', output_rising_rate), ('output_resume_rate', output_resume_rate), ])


class yc_ignore_damp_huawei_ifm__ifm_interfaces_interface_ignore_damp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ignore-damp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure an interface to ignore the global damp-interface function.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ignore_global_damp',)

  _yang_name = 'ignore-damp'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ignore_global_damp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-global-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ignore-damp']

  def _get_ignore_global_damp(self):
    """
    Getter method for ignore_global_damp, mapped from YANG variable /ifm/interfaces/interface/ignore_damp/ignore_global_damp (boolean)

    YANG Description: Enable/disable an interface to ignore the global damp-interface function.
    """
    return self.__ignore_global_damp
      
  def _set_ignore_global_damp(self, v, load=False):
    """
    Setter method for ignore_global_damp, mapped from YANG variable /ifm/interfaces/interface/ignore_damp/ignore_global_damp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_global_damp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_global_damp() directly.

    YANG Description: Enable/disable an interface to ignore the global damp-interface function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-global-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_global_damp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-global-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__ignore_global_damp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_global_damp(self):
    self.__ignore_global_damp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ignore-global-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)

  ignore_global_damp = __builtin__.property(_get_ignore_global_damp, _set_ignore_global_damp)

  __choices__ = {'damping': {'ignore-damp': ['ignore_global_damp']}}
  _pyangbind_elements = OrderedDict([('ignore_global_damp', ignore_global_damp), ])


class yc_auto_huawei_ifm__ifm_interfaces_interface_damp_auto(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/damp/auto. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure an auto suppression level.
  """
  __slots__ = ('_path_helper', '_extmethods', '__level',)

  _yang_name = 'auto'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'damp', 'auto']

  def _get_level(self):
    """
    Getter method for level, mapped from YANG variable /ifm/interfaces/interface/damp/auto/level (damp-level-type)

    YANG Description: Auto damping level.
    """
    return self.__level
      
  def _set_level(self, v, load=False):
    """
    Setter method for level, mapped from YANG variable /ifm/interfaces/interface/damp/auto/level (damp-level-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level() directly.

    YANG Description: Auto damping level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level must be of a type compatible with damp-level-type""",
          'defined-type': "huawei-ifm:damp-level-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)""",
        })

    self.__level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level(self):
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'light': {'value': 0}, 'middle': {'value': 1}, 'heavy': {'value': 2}},), default=six.text_type("light"), is_leaf=True, yang_name="level", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-level-type', is_config=True)

  level = __builtin__.property(_get_level, _set_level)

  __choices__ = {'level': {'auto': ['level']}}
  _pyangbind_elements = OrderedDict([('level', level), ])


class yc_manual_huawei_ifm__ifm_interfaces_interface_damp_manual(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/damp/manual. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure a manual suppression level.
  """
  __slots__ = ('_path_helper', '_extmethods', '__suppress','__reuse','__max_suppress_time','__half_life_period',)

  _yang_name = 'manual'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__max_suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)
    self.__half_life_period = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'damp', 'manual']

  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /ifm/interfaces/interface/damp/manual/suppress (uint32)

    YANG Description: 1000 times of suppress threshold.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /ifm/interfaces/interface/damp/manual/suppress (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: 1000 times of suppress threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_reuse(self):
    """
    Getter method for reuse, mapped from YANG variable /ifm/interfaces/interface/damp/manual/reuse (uint32)

    YANG Description: 1000 times of reuse threshold.
    """
    return self.__reuse
      
  def _set_reuse(self, v, load=False):
    """
    Setter method for reuse, mapped from YANG variable /ifm/interfaces/interface/damp/manual/reuse (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse() directly.

    YANG Description: 1000 times of reuse threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__reuse = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse(self):
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_max_suppress_time(self):
    """
    Getter method for max_suppress_time, mapped from YANG variable /ifm/interfaces/interface/damp/manual/max_suppress_time (uint16)

    YANG Description: Max suppress time.
    """
    return self.__max_suppress_time
      
  def _set_max_suppress_time(self, v, load=False):
    """
    Setter method for max_suppress_time, mapped from YANG variable /ifm/interfaces/interface/damp/manual/max_suppress_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_suppress_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_suppress_time() directly.

    YANG Description: Max suppress time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_suppress_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)""",
        })

    self.__max_suppress_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_suppress_time(self):
    self.__max_suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)


  def _get_half_life_period(self):
    """
    Getter method for half_life_period, mapped from YANG variable /ifm/interfaces/interface/damp/manual/half_life_period (uint16)

    YANG Description: Half life time.
    """
    return self.__half_life_period
      
  def _set_half_life_period(self, v, load=False):
    """
    Setter method for half_life_period, mapped from YANG variable /ifm/interfaces/interface/damp/manual/half_life_period (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_half_life_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_half_life_period() directly.

    YANG Description: Half life time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """half_life_period must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)""",
        })

    self.__half_life_period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_half_life_period(self):
    self.__half_life_period = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=True)

  suppress = __builtin__.property(_get_suppress, _set_suppress)
  reuse = __builtin__.property(_get_reuse, _set_reuse)
  max_suppress_time = __builtin__.property(_get_max_suppress_time, _set_max_suppress_time)
  half_life_period = __builtin__.property(_get_half_life_period, _set_half_life_period)

  __choices__ = {'level': {'manual': ['suppress', 'reuse', 'max_suppress_time', 'half_life_period']}}
  _pyangbind_elements = OrderedDict([('suppress', suppress), ('reuse', reuse), ('max_suppress_time', max_suppress_time), ('half_life_period', half_life_period), ])


class yc_damp_huawei_ifm__ifm_interfaces_interface_damp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/damp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable/disable suppression on an interface's physical status flappings.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tx_off','__auto','__manual',)

  _yang_name = 'damp'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tx_off = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__auto = YANGDynClass(base=yc_auto_huawei_ifm__ifm_interfaces_interface_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__manual = YANGDynClass(base=yc_manual_huawei_ifm__ifm_interfaces_interface_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'damp']

  def _get_tx_off(self):
    """
    Getter method for tx_off, mapped from YANG variable /ifm/interfaces/interface/damp/tx_off (boolean)

    YANG Description: Enable/disable an interface suppressed due to status flapping from sending signals.
    """
    return self.__tx_off
      
  def _set_tx_off(self, v, load=False):
    """
    Setter method for tx_off, mapped from YANG variable /ifm/interfaces/interface/damp/tx_off (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tx_off is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tx_off() directly.

    YANG Description: Enable/disable an interface suppressed due to status flapping from sending signals.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tx_off must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__tx_off = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tx_off(self):
    self.__tx_off = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tx-off", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_auto(self):
    """
    Getter method for auto, mapped from YANG variable /ifm/interfaces/interface/damp/auto (container)

    YANG Description: Configure an auto suppression level.
    """
    return self.__auto
      
  def _set_auto(self, v, load=False):
    """
    Setter method for auto, mapped from YANG variable /ifm/interfaces/interface/damp/auto (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto() directly.

    YANG Description: Configure an auto suppression level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_auto_huawei_ifm__ifm_interfaces_interface_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_auto_huawei_ifm__ifm_interfaces_interface_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__auto = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto(self):
    self.__auto = YANGDynClass(base=yc_auto_huawei_ifm__ifm_interfaces_interface_damp_auto, is_container='container', yang_name="auto", parent=self, choice=('level', 'auto'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_manual(self):
    """
    Getter method for manual, mapped from YANG variable /ifm/interfaces/interface/damp/manual (container)

    YANG Description: Configure a manual suppression level.
    """
    return self.__manual
      
  def _set_manual(self, v, load=False):
    """
    Setter method for manual, mapped from YANG variable /ifm/interfaces/interface/damp/manual (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_manual is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_manual() directly.

    YANG Description: Configure a manual suppression level.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_manual_huawei_ifm__ifm_interfaces_interface_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """manual must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_manual_huawei_ifm__ifm_interfaces_interface_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__manual = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_manual(self):
    self.__manual = YANGDynClass(base=yc_manual_huawei_ifm__ifm_interfaces_interface_damp_manual, is_container='container', yang_name="manual", parent=self, choice=('level', 'manual'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

  tx_off = __builtin__.property(_get_tx_off, _set_tx_off)
  auto = __builtin__.property(_get_auto, _set_auto) # type: yc_auto_huawei_ifm__ifm_interfaces_interface_damp_auto
  manual = __builtin__.property(_get_manual, _set_manual) # type: yc_manual_huawei_ifm__ifm_interfaces_interface_damp_manual

  __choices__ = {'damping': {'damp': ['tx_off']}, 'level': {'auto': ['auto'], 'manual': ['manual']}}
  _pyangbind_elements = OrderedDict([('tx_off', tx_off), ('auto', auto), ('manual', manual), ])


class yc_damp_state_huawei_ifm__ifm_interfaces_interface_damp_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/damp-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state of interface suppression information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__suppress_status','__suppress','__reuse','__max_suppress_time','__half_life_period','__damp_reuse_time','__current_penalty','__max_penalty',)

  _yang_name = 'damp-state'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__suppress_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'suppressed': {'value': 0}, 'unsuppressed': {'value': 1}},), is_leaf=True, yang_name="suppress-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-status-type', is_config=False)
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__max_suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)
    self.__half_life_period = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)
    self.__damp_reuse_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="damp-reuse-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)
    self.__current_penalty = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="current-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__max_penalty = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'damp-state']

  def _get_suppress_status(self):
    """
    Getter method for suppress_status, mapped from YANG variable /ifm/interfaces/interface/damp_state/suppress_status (damp-status-type)

    YANG Description: Interface status suppression state.
    """
    return self.__suppress_status
      
  def _set_suppress_status(self, v, load=False):
    """
    Setter method for suppress_status, mapped from YANG variable /ifm/interfaces/interface/damp_state/suppress_status (damp-status-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress_status() directly.

    YANG Description: Interface status suppression state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'suppressed': {'value': 0}, 'unsuppressed': {'value': 1}},), is_leaf=True, yang_name="suppress-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-status-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress_status must be of a type compatible with damp-status-type""",
          'defined-type': "huawei-ifm:damp-status-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'suppressed': {'value': 0}, 'unsuppressed': {'value': 1}},), is_leaf=True, yang_name="suppress-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-status-type', is_config=False)""",
        })

    self.__suppress_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress_status(self):
    self.__suppress_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'suppressed': {'value': 0}, 'unsuppressed': {'value': 1}},), is_leaf=True, yang_name="suppress-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='damp-status-type', is_config=False)


  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /ifm/interfaces/interface/damp_state/suppress (uint32)

    YANG Description: 1000 times of suppress threshold.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /ifm/interfaces/interface/damp_state/suppress (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: 1000 times of suppress threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_reuse(self):
    """
    Getter method for reuse, mapped from YANG variable /ifm/interfaces/interface/damp_state/reuse (uint32)

    YANG Description: 1000 times of reuse threshold.
    """
    return self.__reuse
      
  def _set_reuse(self, v, load=False):
    """
    Setter method for reuse, mapped from YANG variable /ifm/interfaces/interface/damp_state/reuse (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reuse is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reuse() directly.

    YANG Description: 1000 times of reuse threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reuse must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__reuse = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reuse(self):
    self.__reuse = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..20000']}), is_leaf=True, yang_name="reuse", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_max_suppress_time(self):
    """
    Getter method for max_suppress_time, mapped from YANG variable /ifm/interfaces/interface/damp_state/max_suppress_time (uint16)

    YANG Description: Max suppress time.
    """
    return self.__max_suppress_time
      
  def _set_max_suppress_time(self, v, load=False):
    """
    Setter method for max_suppress_time, mapped from YANG variable /ifm/interfaces/interface/damp_state/max_suppress_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_suppress_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_suppress_time() directly.

    YANG Description: Max suppress time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_suppress_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)""",
        })

    self.__max_suppress_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_suppress_time(self):
    self.__max_suppress_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..255']}), is_leaf=True, yang_name="max-suppress-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)


  def _get_half_life_period(self):
    """
    Getter method for half_life_period, mapped from YANG variable /ifm/interfaces/interface/damp_state/half_life_period (uint16)

    YANG Description: Half life time.
    """
    return self.__half_life_period
      
  def _set_half_life_period(self, v, load=False):
    """
    Setter method for half_life_period, mapped from YANG variable /ifm/interfaces/interface/damp_state/half_life_period (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_half_life_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_half_life_period() directly.

    YANG Description: Half life time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """half_life_period must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)""",
        })

    self.__half_life_period = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_half_life_period(self):
    self.__half_life_period = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..60']}), is_leaf=True, yang_name="half-life-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)


  def _get_damp_reuse_time(self):
    """
    Getter method for damp_reuse_time, mapped from YANG variable /ifm/interfaces/interface/damp_state/damp_reuse_time (uint16)

    YANG Description: Damping reuse time.
    """
    return self.__damp_reuse_time
      
  def _set_damp_reuse_time(self, v, load=False):
    """
    Setter method for damp_reuse_time, mapped from YANG variable /ifm/interfaces/interface/damp_state/damp_reuse_time (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_damp_reuse_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_damp_reuse_time() directly.

    YANG Description: Damping reuse time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="damp-reuse-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """damp_reuse_time must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="damp-reuse-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)""",
        })

    self.__damp_reuse_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_damp_reuse_time(self):
    self.__damp_reuse_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..255']}), is_leaf=True, yang_name="damp-reuse-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint16', is_config=False)


  def _get_current_penalty(self):
    """
    Getter method for current_penalty, mapped from YANG variable /ifm/interfaces/interface/damp_state/current_penalty (uint32)

    YANG Description: 1000 times of current penalty.
    """
    return self.__current_penalty
      
  def _set_current_penalty(self, v, load=False):
    """
    Setter method for current_penalty, mapped from YANG variable /ifm/interfaces/interface/damp_state/current_penalty (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_penalty is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_penalty() directly.

    YANG Description: 1000 times of current penalty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="current-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_penalty must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="current-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__current_penalty = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_penalty(self):
    self.__current_penalty = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="current-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_max_penalty(self):
    """
    Getter method for max_penalty, mapped from YANG variable /ifm/interfaces/interface/damp_state/max_penalty (uint32)

    YANG Description: 1000 times of max penalty.
    """
    return self.__max_penalty
      
  def _set_max_penalty(self, v, load=False):
    """
    Setter method for max_penalty, mapped from YANG variable /ifm/interfaces/interface/damp_state/max_penalty (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_penalty is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_penalty() directly.

    YANG Description: 1000 times of max penalty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_penalty must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__max_penalty = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_penalty(self):
    self.__max_penalty = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-penalty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

  suppress_status = __builtin__.property(_get_suppress_status)
  suppress = __builtin__.property(_get_suppress)
  reuse = __builtin__.property(_get_reuse)
  max_suppress_time = __builtin__.property(_get_max_suppress_time)
  half_life_period = __builtin__.property(_get_half_life_period)
  damp_reuse_time = __builtin__.property(_get_damp_reuse_time)
  current_penalty = __builtin__.property(_get_current_penalty)
  max_penalty = __builtin__.property(_get_max_penalty)


  _pyangbind_elements = OrderedDict([('suppress_status', suppress_status), ('suppress', suppress), ('reuse', reuse), ('max_suppress_time', max_suppress_time), ('half_life_period', half_life_period), ('damp_reuse_time', damp_reuse_time), ('current_penalty', current_penalty), ('max_penalty', max_penalty), ])


class yc_dynamic_huawei_ifm__ifm_interfaces_interface_dynamic(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/dynamic. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state of interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__oper_status','__physical_status','__link_status','__mtu','__bandwidth','__ipv4_status','__ipv6_status','__is_control_flap_damp','__mac_address','__line_protocol_up_time','__is_offline','__link_quality_grade','__sub_if_counts',)

  _yang_name = 'dynamic'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    self.__physical_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="physical-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    self.__link_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:band-width', is_config=False)
    self.__ipv4_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv4-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    self.__ipv6_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv6-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    self.__is_control_flap_damp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-control-flap-damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['1..14']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=False)
    self.__line_protocol_up_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="line-protocol-up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='yang:date-and-time', is_config=False)
    self.__is_offline = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-offline", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)
    self.__link_quality_grade = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'good': {'value': 0}, 'high': {'value': 1}, 'middle': {'value': 2}, 'low': {'value': 4}},), is_leaf=True, yang_name="link-quality-grade", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-quality-grade-type', is_config=False)
    self.__sub_if_counts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-if-counts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'dynamic']

  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/oper_status (port-status)

    YANG Description: Running status of an interface.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/oper_status (port-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: Running status of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with port-status""",
          'defined-type': "huawei-ifm:port-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)


  def _get_physical_status(self):
    """
    Getter method for physical_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/physical_status (port-status)

    YANG Description: Physical status of an interface.
    """
    return self.__physical_status
      
  def _set_physical_status(self, v, load=False):
    """
    Setter method for physical_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/physical_status (port-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_status() directly.

    YANG Description: Physical status of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="physical-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_status must be of a type compatible with port-status""",
          'defined-type': "huawei-ifm:port-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="physical-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)""",
        })

    self.__physical_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_status(self):
    self.__physical_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="physical-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)


  def _get_link_status(self):
    """
    Getter method for link_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/link_status (port-status)

    YANG Description: Link status of an interface.
    """
    return self.__link_status
      
  def _set_link_status(self, v, load=False):
    """
    Setter method for link_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/link_status (port-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_status() directly.

    YANG Description: Link status of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_status must be of a type compatible with port-status""",
          'defined-type': "huawei-ifm:port-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)""",
        })

    self.__link_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_status(self):
    self.__link_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="link-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /ifm/interfaces/interface/dynamic/mtu (uint32)

    YANG Description: Dynamic MTU of an interface.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /ifm/interfaces/interface/dynamic/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: Dynamic MTU of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /ifm/interfaces/interface/dynamic/bandwidth (pub-type:band-width)

    YANG Description: Bandwidth of an interface.
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /ifm/interfaces/interface/dynamic/bandwidth (pub-type:band-width)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: Bandwidth of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:band-width', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with pub-type:band-width""",
          'defined-type': "pub-type:band-width",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:band-width', is_config=False)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:band-width', is_config=False)


  def _get_ipv4_status(self):
    """
    Getter method for ipv4_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/ipv4_status (port-status)

    YANG Description: IPv4 Protocol status of an interface.
    """
    return self.__ipv4_status
      
  def _set_ipv4_status(self, v, load=False):
    """
    Setter method for ipv4_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/ipv4_status (port-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_status() directly.

    YANG Description: IPv4 Protocol status of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv4-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_status must be of a type compatible with port-status""",
          'defined-type': "huawei-ifm:port-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv4-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)""",
        })

    self.__ipv4_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_status(self):
    self.__ipv4_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv4-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)


  def _get_ipv6_status(self):
    """
    Getter method for ipv6_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/ipv6_status (port-status)

    YANG Description: IPv6 protocol status of an interface.
    """
    return self.__ipv6_status
      
  def _set_ipv6_status(self, v, load=False):
    """
    Setter method for ipv6_status, mapped from YANG variable /ifm/interfaces/interface/dynamic/ipv6_status (port-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_status() directly.

    YANG Description: IPv6 protocol status of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv6-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6_status must be of a type compatible with port-status""",
          'defined-type': "huawei-ifm:port-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv6-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)""",
        })

    self.__ipv6_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6_status(self):
    self.__ipv6_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="ipv6-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=False)


  def _get_is_control_flap_damp(self):
    """
    Getter method for is_control_flap_damp, mapped from YANG variable /ifm/interfaces/interface/dynamic/is_control_flap_damp (boolean)

    YANG Description: Status suppression of an interface.
    """
    return self.__is_control_flap_damp
      
  def _set_is_control_flap_damp(self, v, load=False):
    """
    Setter method for is_control_flap_damp, mapped from YANG variable /ifm/interfaces/interface/dynamic/is_control_flap_damp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_control_flap_damp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_control_flap_damp() directly.

    YANG Description: Status suppression of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-control-flap-damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_control_flap_damp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-control-flap-damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)""",
        })

    self.__is_control_flap_damp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_control_flap_damp(self):
    self.__is_control_flap_damp = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-control-flap-damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /ifm/interfaces/interface/dynamic/mac_address (pub-type:mac-address)

    YANG Description: MAC address of an interface.
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /ifm/interfaces/interface/dynamic/mac_address (pub-type:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: MAC address of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['1..14']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with pub-type:mac-address""",
          'defined-type': "pub-type:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['1..14']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=False)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['1..14']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=False)


  def _get_line_protocol_up_time(self):
    """
    Getter method for line_protocol_up_time, mapped from YANG variable /ifm/interfaces/interface/dynamic/line_protocol_up_time (yang:date-and-time)

    YANG Description: Last line protocol up time.
    """
    return self.__line_protocol_up_time
      
  def _set_line_protocol_up_time(self, v, load=False):
    """
    Setter method for line_protocol_up_time, mapped from YANG variable /ifm/interfaces/interface/dynamic/line_protocol_up_time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_protocol_up_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_protocol_up_time() directly.

    YANG Description: Last line protocol up time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="line-protocol-up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_protocol_up_time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="line-protocol-up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__line_protocol_up_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_protocol_up_time(self):
    self.__line_protocol_up_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="line-protocol-up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='yang:date-and-time', is_config=False)


  def _get_is_offline(self):
    """
    Getter method for is_offline, mapped from YANG variable /ifm/interfaces/interface/dynamic/is_offline (boolean)

    YANG Description: Whether an interface is offline.
    """
    return self.__is_offline
      
  def _set_is_offline(self, v, load=False):
    """
    Setter method for is_offline, mapped from YANG variable /ifm/interfaces/interface/dynamic/is_offline (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_offline is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_offline() directly.

    YANG Description: Whether an interface is offline.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-offline", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_offline must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-offline", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)""",
        })

    self.__is_offline = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_offline(self):
    self.__is_offline = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-offline", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)


  def _get_link_quality_grade(self):
    """
    Getter method for link_quality_grade, mapped from YANG variable /ifm/interfaces/interface/dynamic/link_quality_grade (link-quality-grade-type)

    YANG Description: Interface link quality grade.
    """
    return self.__link_quality_grade
      
  def _set_link_quality_grade(self, v, load=False):
    """
    Setter method for link_quality_grade, mapped from YANG variable /ifm/interfaces/interface/dynamic/link_quality_grade (link-quality-grade-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_quality_grade is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_quality_grade() directly.

    YANG Description: Interface link quality grade.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'good': {'value': 0}, 'high': {'value': 1}, 'middle': {'value': 2}, 'low': {'value': 4}},), is_leaf=True, yang_name="link-quality-grade", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-quality-grade-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_quality_grade must be of a type compatible with link-quality-grade-type""",
          'defined-type': "huawei-ifm:link-quality-grade-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'good': {'value': 0}, 'high': {'value': 1}, 'middle': {'value': 2}, 'low': {'value': 4}},), is_leaf=True, yang_name="link-quality-grade", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-quality-grade-type', is_config=False)""",
        })

    self.__link_quality_grade = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_quality_grade(self):
    self.__link_quality_grade = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'good': {'value': 0}, 'high': {'value': 1}, 'middle': {'value': 2}, 'low': {'value': 4}},), is_leaf=True, yang_name="link-quality-grade", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-quality-grade-type', is_config=False)


  def _get_sub_if_counts(self):
    """
    Getter method for sub_if_counts, mapped from YANG variable /ifm/interfaces/interface/dynamic/sub_if_counts (uint32)

    YANG Description: Number of sub-interfaces on this interface.
    """
    return self.__sub_if_counts
      
  def _set_sub_if_counts(self, v, load=False):
    """
    Setter method for sub_if_counts, mapped from YANG variable /ifm/interfaces/interface/dynamic/sub_if_counts (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sub_if_counts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sub_if_counts() directly.

    YANG Description: Number of sub-interfaces on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-if-counts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sub_if_counts must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-if-counts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__sub_if_counts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sub_if_counts(self):
    self.__sub_if_counts = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="sub-if-counts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

  oper_status = __builtin__.property(_get_oper_status)
  physical_status = __builtin__.property(_get_physical_status)
  link_status = __builtin__.property(_get_link_status)
  mtu = __builtin__.property(_get_mtu)
  bandwidth = __builtin__.property(_get_bandwidth)
  ipv4_status = __builtin__.property(_get_ipv4_status)
  ipv6_status = __builtin__.property(_get_ipv6_status)
  is_control_flap_damp = __builtin__.property(_get_is_control_flap_damp)
  mac_address = __builtin__.property(_get_mac_address)
  line_protocol_up_time = __builtin__.property(_get_line_protocol_up_time)
  is_offline = __builtin__.property(_get_is_offline)
  link_quality_grade = __builtin__.property(_get_link_quality_grade)
  sub_if_counts = __builtin__.property(_get_sub_if_counts)


  _pyangbind_elements = OrderedDict([('oper_status', oper_status), ('physical_status', physical_status), ('link_status', link_status), ('mtu', mtu), ('bandwidth', bandwidth), ('ipv4_status', ipv4_status), ('ipv6_status', ipv6_status), ('is_control_flap_damp', is_control_flap_damp), ('mac_address', mac_address), ('line_protocol_up_time', line_protocol_up_time), ('is_offline', is_offline), ('link_quality_grade', link_quality_grade), ('sub_if_counts', sub_if_counts), ])


class yc_mib_statistics_huawei_ifm__ifm_interfaces_interface_mib_statistics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/mib-statistics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface statistics.
  """
  __slots__ = ('_path_helper', '_extmethods', '__receive_byte','__send_byte','__receive_packet','__send_packet','__receive_unicast_packet','__receive_multicast_packet','__receive_broad_packet','__send_unicast_packet','__send_multicast_packet','__send_broad_packet','__receive_error_packet','__receive_drop_packet','__send_error_packet','__send_drop_packet',)

  _yang_name = 'mib-statistics'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__receive_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'mib-statistics']

  def _get_receive_byte(self):
    """
    Getter method for receive_byte, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_byte (uint64)

    YANG Description: Number of bytes received on an interface.
    """
    return self.__receive_byte
      
  def _set_receive_byte(self, v, load=False):
    """
    Setter method for receive_byte, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_byte (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_byte is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_byte() directly.

    YANG Description: Number of bytes received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_byte must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_byte = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_byte(self):
    self.__receive_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_byte(self):
    """
    Getter method for send_byte, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_byte (uint64)

    YANG Description: Number of bytes sent on an interface.
    """
    return self.__send_byte
      
  def _set_send_byte(self, v, load=False):
    """
    Setter method for send_byte, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_byte (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_byte is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_byte() directly.

    YANG Description: Number of bytes sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_byte must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_byte = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_byte(self):
    self.__send_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_packet(self):
    """
    Getter method for receive_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_packet (uint64)

    YANG Description: Number of packets received on an interface.
    """
    return self.__receive_packet
      
  def _set_receive_packet(self, v, load=False):
    """
    Setter method for receive_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_packet() directly.

    YANG Description: Number of packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_packet(self):
    self.__receive_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_packet(self):
    """
    Getter method for send_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_packet (uint64)

    YANG Description: Number of packets sent on an interface.
    """
    return self.__send_packet
      
  def _set_send_packet(self, v, load=False):
    """
    Setter method for send_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_packet() directly.

    YANG Description: Number of packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_packet(self):
    self.__send_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_unicast_packet(self):
    """
    Getter method for receive_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_unicast_packet (uint64)

    YANG Description: Number of unicast packets received on an interface.
    """
    return self.__receive_unicast_packet
      
  def _set_receive_unicast_packet(self, v, load=False):
    """
    Setter method for receive_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_unicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_unicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_unicast_packet() directly.

    YANG Description: Number of unicast packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_unicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_unicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_unicast_packet(self):
    self.__receive_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_multicast_packet(self):
    """
    Getter method for receive_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_multicast_packet (uint64)

    YANG Description: Number of multicast packets received on an interface.
    """
    return self.__receive_multicast_packet
      
  def _set_receive_multicast_packet(self, v, load=False):
    """
    Setter method for receive_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_multicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_multicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_multicast_packet() directly.

    YANG Description: Number of multicast packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_multicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_multicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_multicast_packet(self):
    self.__receive_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_broad_packet(self):
    """
    Getter method for receive_broad_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_broad_packet (uint64)

    YANG Description: Number of broadcast packets received on an interface.
    """
    return self.__receive_broad_packet
      
  def _set_receive_broad_packet(self, v, load=False):
    """
    Setter method for receive_broad_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_broad_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_broad_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_broad_packet() directly.

    YANG Description: Number of broadcast packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_broad_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_broad_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_broad_packet(self):
    self.__receive_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_unicast_packet(self):
    """
    Getter method for send_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_unicast_packet (uint64)

    YANG Description: Number of unicast packets sent on an interface.
    """
    return self.__send_unicast_packet
      
  def _set_send_unicast_packet(self, v, load=False):
    """
    Setter method for send_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_unicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_unicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_unicast_packet() directly.

    YANG Description: Number of unicast packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_unicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_unicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_unicast_packet(self):
    self.__send_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_multicast_packet(self):
    """
    Getter method for send_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_multicast_packet (uint64)

    YANG Description: Number of multicast packets sent on an interface.
    """
    return self.__send_multicast_packet
      
  def _set_send_multicast_packet(self, v, load=False):
    """
    Setter method for send_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_multicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_multicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_multicast_packet() directly.

    YANG Description: Number of multicast packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_multicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_multicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_multicast_packet(self):
    self.__send_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_broad_packet(self):
    """
    Getter method for send_broad_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_broad_packet (uint64)

    YANG Description: Number of broadcast packets sent on an interface.
    """
    return self.__send_broad_packet
      
  def _set_send_broad_packet(self, v, load=False):
    """
    Setter method for send_broad_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_broad_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_broad_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_broad_packet() directly.

    YANG Description: Number of broadcast packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_broad_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_broad_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_broad_packet(self):
    self.__send_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_error_packet(self):
    """
    Getter method for receive_error_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_error_packet (uint64)

    YANG Description: Number of error packets received on an interface.
    """
    return self.__receive_error_packet
      
  def _set_receive_error_packet(self, v, load=False):
    """
    Setter method for receive_error_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_error_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_error_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_error_packet() directly.

    YANG Description: Number of error packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_error_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_error_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_error_packet(self):
    self.__receive_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_drop_packet(self):
    """
    Getter method for receive_drop_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_drop_packet (uint64)

    YANG Description: Number of received packets discarded on an interface.
    """
    return self.__receive_drop_packet
      
  def _set_receive_drop_packet(self, v, load=False):
    """
    Setter method for receive_drop_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/receive_drop_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_drop_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_drop_packet() directly.

    YANG Description: Number of received packets discarded on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_drop_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_drop_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_drop_packet(self):
    self.__receive_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_error_packet(self):
    """
    Getter method for send_error_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_error_packet (uint64)

    YANG Description: Number of error packets sent on an interface.
    """
    return self.__send_error_packet
      
  def _set_send_error_packet(self, v, load=False):
    """
    Setter method for send_error_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_error_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_error_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_error_packet() directly.

    YANG Description: Number of error packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_error_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_error_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_error_packet(self):
    self.__send_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_drop_packet(self):
    """
    Getter method for send_drop_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_drop_packet (uint64)

    YANG Description: Number of sent packets discarded on an interface.
    """
    return self.__send_drop_packet
      
  def _set_send_drop_packet(self, v, load=False):
    """
    Setter method for send_drop_packet, mapped from YANG variable /ifm/interfaces/interface/mib_statistics/send_drop_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_drop_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_drop_packet() directly.

    YANG Description: Number of sent packets discarded on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_drop_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_drop_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_drop_packet(self):
    self.__send_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)

  receive_byte = __builtin__.property(_get_receive_byte)
  send_byte = __builtin__.property(_get_send_byte)
  receive_packet = __builtin__.property(_get_receive_packet)
  send_packet = __builtin__.property(_get_send_packet)
  receive_unicast_packet = __builtin__.property(_get_receive_unicast_packet)
  receive_multicast_packet = __builtin__.property(_get_receive_multicast_packet)
  receive_broad_packet = __builtin__.property(_get_receive_broad_packet)
  send_unicast_packet = __builtin__.property(_get_send_unicast_packet)
  send_multicast_packet = __builtin__.property(_get_send_multicast_packet)
  send_broad_packet = __builtin__.property(_get_send_broad_packet)
  receive_error_packet = __builtin__.property(_get_receive_error_packet)
  receive_drop_packet = __builtin__.property(_get_receive_drop_packet)
  send_error_packet = __builtin__.property(_get_send_error_packet)
  send_drop_packet = __builtin__.property(_get_send_drop_packet)


  _pyangbind_elements = OrderedDict([('receive_byte', receive_byte), ('send_byte', send_byte), ('receive_packet', receive_packet), ('send_packet', send_packet), ('receive_unicast_packet', receive_unicast_packet), ('receive_multicast_packet', receive_multicast_packet), ('receive_broad_packet', receive_broad_packet), ('send_unicast_packet', send_unicast_packet), ('send_multicast_packet', send_multicast_packet), ('send_broad_packet', send_broad_packet), ('receive_error_packet', receive_error_packet), ('receive_drop_packet', receive_drop_packet), ('send_error_packet', send_error_packet), ('send_drop_packet', send_drop_packet), ])


class yc_common_statistics_huawei_ifm__ifm_interfaces_interface_common_statistics(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/common-statistics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Interface statistics.
  """
  __slots__ = ('_path_helper', '_extmethods', '__stati_interval','__in_byte_rate','__in_bit_rate','__in_packet_rate','__in_use_rate','__out_byte_rate','__out_bit_rate','__out_packet_rate','__out_use_rate','__receive_byte','__send_byte','__receive_packet','__send_packet','__receive_unicast_packet','__receive_multicast_packet','__receive_broad_packet','__send_unicast_packet','__send_multicast_packet','__send_broad_packet','__receive_error_packet','__receive_drop_packet','__send_error_packet','__send_drop_packet','__send_unicast_bit','__receive_unicast_bit','__send_multicast_bit','__receive_multicast_bit','__send_broad_bit','__receive_broad_bit','__send_unicast_bit_rate','__receive_unicast_bit_rate','__send_multicast_bit_rate','__receive_multicast_bit_rate','__send_broad_bit_rate','__receive_broad_bit_rate','__send_unicast_packet_rate','__receive_unicast_packet_rate','__send_multicast_packet_rate','__receive_multicast_packet_rate','__send_broadcast_packet_rate','__receive_broadcast_packet_rate',)

  _yang_name = 'common-statistics'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__stati_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="stati-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__in_byte_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__in_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__in_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__in_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__out_byte_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__out_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__out_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__out_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__receive_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_unicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_unicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_multicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_multicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_broad_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_broad_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_unicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_unicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_multicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_multicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_broad_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_broad_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_unicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_unicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_multicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_multicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__send_broadcast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__receive_broadcast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'common-statistics']

  def _get_stati_interval(self):
    """
    Getter method for stati_interval, mapped from YANG variable /ifm/interfaces/interface/common_statistics/stati_interval (uint32)

    YANG Description: Current interval at which interface flow statistics are collected.
    """
    return self.__stati_interval
      
  def _set_stati_interval(self, v, load=False):
    """
    Setter method for stati_interval, mapped from YANG variable /ifm/interfaces/interface/common_statistics/stati_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stati_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stati_interval() directly.

    YANG Description: Current interval at which interface flow statistics are collected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="stati-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stati_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="stati-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__stati_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stati_interval(self):
    self.__stati_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(300), is_leaf=True, yang_name="stati-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_in_byte_rate(self):
    """
    Getter method for in_byte_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_byte_rate (uint64)

    YANG Description: Rate at which bytes are received within the interval.
    """
    return self.__in_byte_rate
      
  def _set_in_byte_rate(self, v, load=False):
    """
    Setter method for in_byte_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_byte_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_byte_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_byte_rate() directly.

    YANG Description: Rate at which bytes are received within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_byte_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__in_byte_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_byte_rate(self):
    self.__in_byte_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_in_bit_rate(self):
    """
    Getter method for in_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_bit_rate (uint64)

    YANG Description: Rate at which bits are received within the interval.
    """
    return self.__in_bit_rate
      
  def _set_in_bit_rate(self, v, load=False):
    """
    Setter method for in_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_bit_rate() directly.

    YANG Description: Rate at which bits are received within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__in_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_bit_rate(self):
    self.__in_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_in_packet_rate(self):
    """
    Getter method for in_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_packet_rate (uint64)

    YANG Description: Rate at which packets are received within the interval.
    """
    return self.__in_packet_rate
      
  def _set_in_packet_rate(self, v, load=False):
    """
    Setter method for in_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_packet_rate() directly.

    YANG Description: Rate at which packets are received within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__in_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_packet_rate(self):
    self.__in_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_in_use_rate(self):
    """
    Getter method for in_use_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_use_rate (string)

    YANG Description: Input bandwidth usage within the interval.
    """
    return self.__in_use_rate
      
  def _set_in_use_rate(self, v, load=False):
    """
    Setter method for in_use_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/in_use_rate (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_use_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_use_rate() directly.

    YANG Description: Input bandwidth usage within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_use_rate must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__in_use_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_use_rate(self):
    self.__in_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_out_byte_rate(self):
    """
    Getter method for out_byte_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_byte_rate (uint64)

    YANG Description: Rate at which bytes are sent within the interval.
    """
    return self.__out_byte_rate
      
  def _set_out_byte_rate(self, v, load=False):
    """
    Setter method for out_byte_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_byte_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_byte_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_byte_rate() directly.

    YANG Description: Rate at which bytes are sent within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_byte_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__out_byte_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_byte_rate(self):
    self.__out_byte_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-byte-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_out_bit_rate(self):
    """
    Getter method for out_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_bit_rate (uint64)

    YANG Description: Rate at which bits are sent within the interval.
    """
    return self.__out_bit_rate
      
  def _set_out_bit_rate(self, v, load=False):
    """
    Setter method for out_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_bit_rate() directly.

    YANG Description: Rate at which bits are sent within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__out_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_bit_rate(self):
    self.__out_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_out_packet_rate(self):
    """
    Getter method for out_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_packet_rate (uint64)

    YANG Description: Rate at which packets are sent within the interval.
    """
    return self.__out_packet_rate
      
  def _set_out_packet_rate(self, v, load=False):
    """
    Setter method for out_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_packet_rate() directly.

    YANG Description: Rate at which packets are sent within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__out_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_packet_rate(self):
    self.__out_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_out_use_rate(self):
    """
    Getter method for out_use_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_use_rate (string)

    YANG Description: Output bandwidth usage within the interval.
    """
    return self.__out_use_rate
      
  def _set_out_use_rate(self, v, load=False):
    """
    Setter method for out_use_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/out_use_rate (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_use_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_use_rate() directly.

    YANG Description: Output bandwidth usage within the interval.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_use_rate must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__out_use_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_use_rate(self):
    self.__out_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_receive_byte(self):
    """
    Getter method for receive_byte, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_byte (uint64)

    YANG Description: Number of received bytes, which can be cleared.
    """
    return self.__receive_byte
      
  def _set_receive_byte(self, v, load=False):
    """
    Setter method for receive_byte, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_byte (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_byte is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_byte() directly.

    YANG Description: Number of received bytes, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_byte must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_byte = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_byte(self):
    self.__receive_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_byte(self):
    """
    Getter method for send_byte, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_byte (uint64)

    YANG Description: Number of sent bytes, which can be cleared.
    """
    return self.__send_byte
      
  def _set_send_byte(self, v, load=False):
    """
    Setter method for send_byte, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_byte (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_byte is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_byte() directly.

    YANG Description: Number of sent bytes, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_byte must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_byte = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_byte(self):
    self.__send_byte = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-byte", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_packet(self):
    """
    Getter method for receive_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_packet (uint64)

    YANG Description: Number of received packets, which can be cleared.
    """
    return self.__receive_packet
      
  def _set_receive_packet(self, v, load=False):
    """
    Setter method for receive_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_packet() directly.

    YANG Description: Number of received packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_packet(self):
    self.__receive_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_packet(self):
    """
    Getter method for send_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_packet (uint64)

    YANG Description: Number of sent packets, which can be cleared.
    """
    return self.__send_packet
      
  def _set_send_packet(self, v, load=False):
    """
    Setter method for send_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_packet() directly.

    YANG Description: Number of sent packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_packet(self):
    self.__send_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_unicast_packet(self):
    """
    Getter method for receive_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_packet (uint64)

    YANG Description: Number of received unicast packets, which can be cleared.
    """
    return self.__receive_unicast_packet
      
  def _set_receive_unicast_packet(self, v, load=False):
    """
    Setter method for receive_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_unicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_unicast_packet() directly.

    YANG Description: Number of received unicast packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_unicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_unicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_unicast_packet(self):
    self.__receive_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_multicast_packet(self):
    """
    Getter method for receive_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_packet (uint64)

    YANG Description: Number of received multicast packets, which can be cleared.
    """
    return self.__receive_multicast_packet
      
  def _set_receive_multicast_packet(self, v, load=False):
    """
    Setter method for receive_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_multicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_multicast_packet() directly.

    YANG Description: Number of received multicast packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_multicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_multicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_multicast_packet(self):
    self.__receive_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_broad_packet(self):
    """
    Getter method for receive_broad_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broad_packet (uint64)

    YANG Description: Number of received broadcast packets, which can be cleared.
    """
    return self.__receive_broad_packet
      
  def _set_receive_broad_packet(self, v, load=False):
    """
    Setter method for receive_broad_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broad_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_broad_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_broad_packet() directly.

    YANG Description: Number of received broadcast packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_broad_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_broad_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_broad_packet(self):
    self.__receive_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_unicast_packet(self):
    """
    Getter method for send_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_packet (uint64)

    YANG Description: Number of sent unicast packets, which can be cleared.
    """
    return self.__send_unicast_packet
      
  def _set_send_unicast_packet(self, v, load=False):
    """
    Setter method for send_unicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_unicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_unicast_packet() directly.

    YANG Description: Number of sent unicast packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_unicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_unicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_unicast_packet(self):
    self.__send_unicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_multicast_packet(self):
    """
    Getter method for send_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_packet (uint64)

    YANG Description: Number of sent multicast packets, which can be cleared.
    """
    return self.__send_multicast_packet
      
  def _set_send_multicast_packet(self, v, load=False):
    """
    Setter method for send_multicast_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_multicast_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_multicast_packet() directly.

    YANG Description: Number of sent multicast packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_multicast_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_multicast_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_multicast_packet(self):
    self.__send_multicast_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_broad_packet(self):
    """
    Getter method for send_broad_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broad_packet (uint64)

    YANG Description: Number of sent broadcast packets, which can be cleared.
    """
    return self.__send_broad_packet
      
  def _set_send_broad_packet(self, v, load=False):
    """
    Setter method for send_broad_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broad_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_broad_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_broad_packet() directly.

    YANG Description: Number of sent broadcast packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_broad_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_broad_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_broad_packet(self):
    self.__send_broad_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_error_packet(self):
    """
    Getter method for receive_error_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_error_packet (uint64)

    YANG Description: Number of received error packets, which can be cleared.
    """
    return self.__receive_error_packet
      
  def _set_receive_error_packet(self, v, load=False):
    """
    Setter method for receive_error_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_error_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_error_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_error_packet() directly.

    YANG Description: Number of received error packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_error_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_error_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_error_packet(self):
    self.__receive_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_drop_packet(self):
    """
    Getter method for receive_drop_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_drop_packet (uint64)

    YANG Description: Number of received discarded packets, which can be cleared.
    """
    return self.__receive_drop_packet
      
  def _set_receive_drop_packet(self, v, load=False):
    """
    Setter method for receive_drop_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_drop_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_drop_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_drop_packet() directly.

    YANG Description: Number of received discarded packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_drop_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_drop_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_drop_packet(self):
    self.__receive_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_error_packet(self):
    """
    Getter method for send_error_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_error_packet (uint64)

    YANG Description: Number of sent error packets, which can be cleared.
    """
    return self.__send_error_packet
      
  def _set_send_error_packet(self, v, load=False):
    """
    Setter method for send_error_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_error_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_error_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_error_packet() directly.

    YANG Description: Number of sent error packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_error_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_error_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_error_packet(self):
    self.__send_error_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-error-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_drop_packet(self):
    """
    Getter method for send_drop_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_drop_packet (uint64)

    YANG Description: Number of sent discarded packets, which can be cleared.
    """
    return self.__send_drop_packet
      
  def _set_send_drop_packet(self, v, load=False):
    """
    Setter method for send_drop_packet, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_drop_packet (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_drop_packet is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_drop_packet() directly.

    YANG Description: Number of sent discarded packets, which can be cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_drop_packet must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_drop_packet = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_drop_packet(self):
    self.__send_drop_packet = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-drop-packet", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_unicast_bit(self):
    """
    Getter method for send_unicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_bit (uint64)

    YANG Description: Number of unicast bits sent on an interface.
    """
    return self.__send_unicast_bit
      
  def _set_send_unicast_bit(self, v, load=False):
    """
    Setter method for send_unicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_bit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_unicast_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_unicast_bit() directly.

    YANG Description: Number of unicast bits sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_unicast_bit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_unicast_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_unicast_bit(self):
    self.__send_unicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_unicast_bit(self):
    """
    Getter method for receive_unicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_bit (uint64)

    YANG Description: Number of unicast bits received on an interface.
    """
    return self.__receive_unicast_bit
      
  def _set_receive_unicast_bit(self, v, load=False):
    """
    Setter method for receive_unicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_bit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_unicast_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_unicast_bit() directly.

    YANG Description: Number of unicast bits received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_unicast_bit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_unicast_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_unicast_bit(self):
    self.__receive_unicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_multicast_bit(self):
    """
    Getter method for send_multicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_bit (uint64)

    YANG Description: Number of multicast bits sent on an interface.
    """
    return self.__send_multicast_bit
      
  def _set_send_multicast_bit(self, v, load=False):
    """
    Setter method for send_multicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_bit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_multicast_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_multicast_bit() directly.

    YANG Description: Number of multicast bits sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_multicast_bit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_multicast_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_multicast_bit(self):
    self.__send_multicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_multicast_bit(self):
    """
    Getter method for receive_multicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_bit (uint64)

    YANG Description: Number of multicast bits received on an interface.
    """
    return self.__receive_multicast_bit
      
  def _set_receive_multicast_bit(self, v, load=False):
    """
    Setter method for receive_multicast_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_bit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_multicast_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_multicast_bit() directly.

    YANG Description: Number of multicast bits received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_multicast_bit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_multicast_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_multicast_bit(self):
    self.__receive_multicast_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_broad_bit(self):
    """
    Getter method for send_broad_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broad_bit (uint64)

    YANG Description: Number of broadcast bits sent on an interface.
    """
    return self.__send_broad_bit
      
  def _set_send_broad_bit(self, v, load=False):
    """
    Setter method for send_broad_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broad_bit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_broad_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_broad_bit() directly.

    YANG Description: Number of broadcast bits sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_broad_bit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_broad_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_broad_bit(self):
    self.__send_broad_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_broad_bit(self):
    """
    Getter method for receive_broad_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broad_bit (uint64)

    YANG Description: Number of broadcast bits received on an interface.
    """
    return self.__receive_broad_bit
      
  def _set_receive_broad_bit(self, v, load=False):
    """
    Setter method for receive_broad_bit, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broad_bit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_broad_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_broad_bit() directly.

    YANG Description: Number of broadcast bits received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_broad_bit must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_broad_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_broad_bit(self):
    self.__receive_broad_bit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_unicast_bit_rate(self):
    """
    Getter method for send_unicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_bit_rate (uint64)

    YANG Description: Rate of unicast bits sent on an interface.
    """
    return self.__send_unicast_bit_rate
      
  def _set_send_unicast_bit_rate(self, v, load=False):
    """
    Setter method for send_unicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_unicast_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_unicast_bit_rate() directly.

    YANG Description: Rate of unicast bits sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_unicast_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_unicast_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_unicast_bit_rate(self):
    self.__send_unicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_unicast_bit_rate(self):
    """
    Getter method for receive_unicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_bit_rate (uint64)

    YANG Description: Rate of unicast bits received on an interface.
    """
    return self.__receive_unicast_bit_rate
      
  def _set_receive_unicast_bit_rate(self, v, load=False):
    """
    Setter method for receive_unicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_unicast_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_unicast_bit_rate() directly.

    YANG Description: Rate of unicast bits received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_unicast_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_unicast_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_unicast_bit_rate(self):
    self.__receive_unicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_multicast_bit_rate(self):
    """
    Getter method for send_multicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_bit_rate (uint64)

    YANG Description: Rate of multicast bits sent on an interface.
    """
    return self.__send_multicast_bit_rate
      
  def _set_send_multicast_bit_rate(self, v, load=False):
    """
    Setter method for send_multicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_multicast_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_multicast_bit_rate() directly.

    YANG Description: Rate of multicast bits sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_multicast_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_multicast_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_multicast_bit_rate(self):
    self.__send_multicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_multicast_bit_rate(self):
    """
    Getter method for receive_multicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_bit_rate (uint64)

    YANG Description: Rate of multicast bits received on an interface.
    """
    return self.__receive_multicast_bit_rate
      
  def _set_receive_multicast_bit_rate(self, v, load=False):
    """
    Setter method for receive_multicast_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_multicast_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_multicast_bit_rate() directly.

    YANG Description: Rate of multicast bits received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_multicast_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_multicast_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_multicast_bit_rate(self):
    self.__receive_multicast_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_broad_bit_rate(self):
    """
    Getter method for send_broad_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broad_bit_rate (uint64)

    YANG Description: Rate of broadcast bits sent on an interface.
    """
    return self.__send_broad_bit_rate
      
  def _set_send_broad_bit_rate(self, v, load=False):
    """
    Setter method for send_broad_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broad_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_broad_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_broad_bit_rate() directly.

    YANG Description: Rate of broadcast bits sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_broad_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_broad_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_broad_bit_rate(self):
    self.__send_broad_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_broad_bit_rate(self):
    """
    Getter method for receive_broad_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broad_bit_rate (uint64)

    YANG Description: Rate of broadcast bits received on an interface.
    """
    return self.__receive_broad_bit_rate
      
  def _set_receive_broad_bit_rate(self, v, load=False):
    """
    Setter method for receive_broad_bit_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broad_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_broad_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_broad_bit_rate() directly.

    YANG Description: Rate of broadcast bits received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_broad_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_broad_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_broad_bit_rate(self):
    self.__receive_broad_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broad-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_unicast_packet_rate(self):
    """
    Getter method for send_unicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_packet_rate (uint64)

    YANG Description: Rate of unicast packets sent on an interface.
    """
    return self.__send_unicast_packet_rate
      
  def _set_send_unicast_packet_rate(self, v, load=False):
    """
    Setter method for send_unicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_unicast_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_unicast_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_unicast_packet_rate() directly.

    YANG Description: Rate of unicast packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_unicast_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_unicast_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_unicast_packet_rate(self):
    self.__send_unicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_unicast_packet_rate(self):
    """
    Getter method for receive_unicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_packet_rate (uint64)

    YANG Description: Rate of unicast packets received on an interface.
    """
    return self.__receive_unicast_packet_rate
      
  def _set_receive_unicast_packet_rate(self, v, load=False):
    """
    Setter method for receive_unicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_unicast_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_unicast_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_unicast_packet_rate() directly.

    YANG Description: Rate of unicast packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_unicast_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_unicast_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_unicast_packet_rate(self):
    self.__receive_unicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-unicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_multicast_packet_rate(self):
    """
    Getter method for send_multicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_packet_rate (uint64)

    YANG Description: Rate of multicast packets sent on an interface.
    """
    return self.__send_multicast_packet_rate
      
  def _set_send_multicast_packet_rate(self, v, load=False):
    """
    Setter method for send_multicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_multicast_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_multicast_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_multicast_packet_rate() directly.

    YANG Description: Rate of multicast packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_multicast_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_multicast_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_multicast_packet_rate(self):
    self.__send_multicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_multicast_packet_rate(self):
    """
    Getter method for receive_multicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_packet_rate (uint64)

    YANG Description: Rate of multicast packets received on an interface.
    """
    return self.__receive_multicast_packet_rate
      
  def _set_receive_multicast_packet_rate(self, v, load=False):
    """
    Setter method for receive_multicast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_multicast_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_multicast_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_multicast_packet_rate() directly.

    YANG Description: Rate of multicast packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_multicast_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_multicast_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_multicast_packet_rate(self):
    self.__receive_multicast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-multicast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_send_broadcast_packet_rate(self):
    """
    Getter method for send_broadcast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broadcast_packet_rate (uint64)

    YANG Description: Rate of broadcast packets sent on an interface.
    """
    return self.__send_broadcast_packet_rate
      
  def _set_send_broadcast_packet_rate(self, v, load=False):
    """
    Setter method for send_broadcast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/send_broadcast_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_send_broadcast_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_send_broadcast_packet_rate() directly.

    YANG Description: Rate of broadcast packets sent on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """send_broadcast_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__send_broadcast_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_send_broadcast_packet_rate(self):
    self.__send_broadcast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="send-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_receive_broadcast_packet_rate(self):
    """
    Getter method for receive_broadcast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broadcast_packet_rate (uint64)

    YANG Description: Rate of broadcast packets received on an interface.
    """
    return self.__receive_broadcast_packet_rate
      
  def _set_receive_broadcast_packet_rate(self, v, load=False):
    """
    Setter method for receive_broadcast_packet_rate, mapped from YANG variable /ifm/interfaces/interface/common_statistics/receive_broadcast_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_receive_broadcast_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_receive_broadcast_packet_rate() directly.

    YANG Description: Rate of broadcast packets received on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """receive_broadcast_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__receive_broadcast_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_receive_broadcast_packet_rate(self):
    self.__receive_broadcast_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="receive-broadcast-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)

  stati_interval = __builtin__.property(_get_stati_interval)
  in_byte_rate = __builtin__.property(_get_in_byte_rate)
  in_bit_rate = __builtin__.property(_get_in_bit_rate)
  in_packet_rate = __builtin__.property(_get_in_packet_rate)
  in_use_rate = __builtin__.property(_get_in_use_rate)
  out_byte_rate = __builtin__.property(_get_out_byte_rate)
  out_bit_rate = __builtin__.property(_get_out_bit_rate)
  out_packet_rate = __builtin__.property(_get_out_packet_rate)
  out_use_rate = __builtin__.property(_get_out_use_rate)
  receive_byte = __builtin__.property(_get_receive_byte)
  send_byte = __builtin__.property(_get_send_byte)
  receive_packet = __builtin__.property(_get_receive_packet)
  send_packet = __builtin__.property(_get_send_packet)
  receive_unicast_packet = __builtin__.property(_get_receive_unicast_packet)
  receive_multicast_packet = __builtin__.property(_get_receive_multicast_packet)
  receive_broad_packet = __builtin__.property(_get_receive_broad_packet)
  send_unicast_packet = __builtin__.property(_get_send_unicast_packet)
  send_multicast_packet = __builtin__.property(_get_send_multicast_packet)
  send_broad_packet = __builtin__.property(_get_send_broad_packet)
  receive_error_packet = __builtin__.property(_get_receive_error_packet)
  receive_drop_packet = __builtin__.property(_get_receive_drop_packet)
  send_error_packet = __builtin__.property(_get_send_error_packet)
  send_drop_packet = __builtin__.property(_get_send_drop_packet)
  send_unicast_bit = __builtin__.property(_get_send_unicast_bit)
  receive_unicast_bit = __builtin__.property(_get_receive_unicast_bit)
  send_multicast_bit = __builtin__.property(_get_send_multicast_bit)
  receive_multicast_bit = __builtin__.property(_get_receive_multicast_bit)
  send_broad_bit = __builtin__.property(_get_send_broad_bit)
  receive_broad_bit = __builtin__.property(_get_receive_broad_bit)
  send_unicast_bit_rate = __builtin__.property(_get_send_unicast_bit_rate)
  receive_unicast_bit_rate = __builtin__.property(_get_receive_unicast_bit_rate)
  send_multicast_bit_rate = __builtin__.property(_get_send_multicast_bit_rate)
  receive_multicast_bit_rate = __builtin__.property(_get_receive_multicast_bit_rate)
  send_broad_bit_rate = __builtin__.property(_get_send_broad_bit_rate)
  receive_broad_bit_rate = __builtin__.property(_get_receive_broad_bit_rate)
  send_unicast_packet_rate = __builtin__.property(_get_send_unicast_packet_rate)
  receive_unicast_packet_rate = __builtin__.property(_get_receive_unicast_packet_rate)
  send_multicast_packet_rate = __builtin__.property(_get_send_multicast_packet_rate)
  receive_multicast_packet_rate = __builtin__.property(_get_receive_multicast_packet_rate)
  send_broadcast_packet_rate = __builtin__.property(_get_send_broadcast_packet_rate)
  receive_broadcast_packet_rate = __builtin__.property(_get_receive_broadcast_packet_rate)


  _pyangbind_elements = OrderedDict([('stati_interval', stati_interval), ('in_byte_rate', in_byte_rate), ('in_bit_rate', in_bit_rate), ('in_packet_rate', in_packet_rate), ('in_use_rate', in_use_rate), ('out_byte_rate', out_byte_rate), ('out_bit_rate', out_bit_rate), ('out_packet_rate', out_packet_rate), ('out_use_rate', out_use_rate), ('receive_byte', receive_byte), ('send_byte', send_byte), ('receive_packet', receive_packet), ('send_packet', send_packet), ('receive_unicast_packet', receive_unicast_packet), ('receive_multicast_packet', receive_multicast_packet), ('receive_broad_packet', receive_broad_packet), ('send_unicast_packet', send_unicast_packet), ('send_multicast_packet', send_multicast_packet), ('send_broad_packet', send_broad_packet), ('receive_error_packet', receive_error_packet), ('receive_drop_packet', receive_drop_packet), ('send_error_packet', send_error_packet), ('send_drop_packet', send_drop_packet), ('send_unicast_bit', send_unicast_bit), ('receive_unicast_bit', receive_unicast_bit), ('send_multicast_bit', send_multicast_bit), ('receive_multicast_bit', receive_multicast_bit), ('send_broad_bit', send_broad_bit), ('receive_broad_bit', receive_broad_bit), ('send_unicast_bit_rate', send_unicast_bit_rate), ('receive_unicast_bit_rate', receive_unicast_bit_rate), ('send_multicast_bit_rate', send_multicast_bit_rate), ('receive_multicast_bit_rate', receive_multicast_bit_rate), ('send_broad_bit_rate', send_broad_bit_rate), ('receive_broad_bit_rate', receive_broad_bit_rate), ('send_unicast_packet_rate', send_unicast_packet_rate), ('receive_unicast_packet_rate', receive_unicast_packet_rate), ('send_multicast_packet_rate', send_multicast_packet_rate), ('receive_multicast_packet_rate', receive_multicast_packet_rate), ('send_broadcast_packet_rate', send_broadcast_packet_rate), ('receive_broadcast_packet_rate', receive_broadcast_packet_rate), ])


class yc_error_down_huawei_ifm__ifm_interfaces_interface_error_down(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/error-down. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about the interface in the error-down state, including the interface name, cause of the error-down event, delay for the transition from down to up, and remaining time for the up state.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cause','__recovery_time','__remainder_time',)

  _yang_name = 'error-down'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cause = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="cause", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=False)
    self.__recovery_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__remainder_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="remainder-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'error-down']

  def _get_cause(self):
    """
    Getter method for cause, mapped from YANG variable /ifm/interfaces/interface/error_down/cause (error-down-type)

    YANG Description: Cause of the error-down event.
    """
    return self.__cause
      
  def _set_cause(self, v, load=False):
    """
    Setter method for cause, mapped from YANG variable /ifm/interfaces/interface/error_down/cause (error-down-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cause is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cause() directly.

    YANG Description: Cause of the error-down event.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="cause", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cause must be of a type compatible with error-down-type""",
          'defined-type': "huawei-ifm:error-down-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="cause", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=False)""",
        })

    self.__cause = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cause(self):
    self.__cause = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'bpdu-protection': {'value': 0}, 'auto-defend': {'value': 1}, 'monitor-link': {'value': 2}, 'portsec-reached-limit': {'value': 65}, 'storm-control': {'value': 66}, 'loopback-detect': {'value': 67}, 'dual-active': {'value': 68}, 'mac-address-flapping': {'value': 69}, 'no-stack-link': {'value': 70}, 'crc-statistics': {'value': 71}, 'transceiver-power-low': {'value': 72}, 'link-flap': {'value': 73}, 'l2-loop-occured': {'value': 74}, 'stack-member-exceed-limit': {'value': 75}, 'spine-member-exceed-limit': {'value': 76}, 'resource-mismatch': {'value': 77}, 'leaf-mstp': {'value': 78}, 'm-lag': {'value': 79}, 'fabric-uplink-threshold': {'value': 80}, 'stack-config-conflict': {'value': 81}, 'spine-type-unsupported': {'value': 82}, 'stack-packet-defensive': {'value': 83}, 'forward-engine-buffer-failed': {'value': 85}, 'forward-engine-interface-failed': {'value': 86}, 'fabric-link-failure': {'value': 87}, 'm-lag-consistency-check': {'value': 88}},), is_leaf=True, yang_name="cause", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='error-down-type', is_config=False)


  def _get_recovery_time(self):
    """
    Getter method for recovery_time, mapped from YANG variable /ifm/interfaces/interface/error_down/recovery_time (uint32)

    YANG Description: Delay for the transition from down to up.
    """
    return self.__recovery_time
      
  def _set_recovery_time(self, v, load=False):
    """
    Setter method for recovery_time, mapped from YANG variable /ifm/interfaces/interface/error_down/recovery_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_recovery_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_recovery_time() directly.

    YANG Description: Delay for the transition from down to up.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """recovery_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__recovery_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_recovery_time(self):
    self.__recovery_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="recovery-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_remainder_time(self):
    """
    Getter method for remainder_time, mapped from YANG variable /ifm/interfaces/interface/error_down/remainder_time (uint32)

    YANG Description: The remaining time for the up event.
    """
    return self.__remainder_time
      
  def _set_remainder_time(self, v, load=False):
    """
    Setter method for remainder_time, mapped from YANG variable /ifm/interfaces/interface/error_down/remainder_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remainder_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remainder_time() directly.

    YANG Description: The remaining time for the up event.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="remainder-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remainder_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="remainder-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__remainder_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remainder_time(self):
    self.__remainder_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..86400']}), is_leaf=True, yang_name="remainder-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

  cause = __builtin__.property(_get_cause)
  recovery_time = __builtin__.property(_get_recovery_time)
  remainder_time = __builtin__.property(_get_remainder_time)


  _pyangbind_elements = OrderedDict([('cause', cause), ('recovery_time', recovery_time), ('remainder_time', remainder_time), ])


class yc_tunnel_protocol_huawei_ifm__ifm_interfaces_interface_tunnel_protocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/tunnel-protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure tunnel protocol.
Special explanation:
Constraint: If a tunnel is locked, all configurations of the tunnel cannot be deleted or modified.
  """
  _pyangbind_elements = {}

  

class yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_addresses_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/addresses/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure IPv4 address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__mask','__type',)

  _yang_name = 'address'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__mask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-config-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'addresses', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address/ip (inet:ipv4-address-no-zone)

    YANG Description: IPv4 address.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address/ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: IPv4 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_mask(self):
    """
    Getter method for mask, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address/mask (ipv4-netmask)

    YANG Description: IPv4 address mask.
    """
    return self.__mask
      
  def _set_mask(self, v, load=False):
    """
    Setter method for mask, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address/mask (ipv4-netmask)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mask() directly.

    YANG Description: IPv4 address mask.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mask must be of a type compatible with ipv4-netmask""",
          'defined-type': "huawei-ip:ipv4-netmask",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=True)""",
        })

    self.__mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mask(self):
    self.__mask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address/type (ipv4-address-config-type)

    YANG Description: IPv4 address type.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address/type (ipv4-address-config-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: IPv4 address type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-config-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with ipv4-address-config-type""",
          'defined-type': "huawei-ip:ipv4-address-config-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-config-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-config-type', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  mask = __builtin__.property(_get_mask, _set_mask)
  type = __builtin__.property(_get_type, _set_type)

  __choices__ = {'address': {'common-address': ['ip', 'mask', 'type']}}
  _pyangbind_elements = OrderedDict([('ip', ip), ('mask', mask), ('type', type), ])


class yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of common addresses. The IPv4 address of the DCN interface cannot be created, modified, or deleted.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'addresses'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'addresses']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address (list)

    YANG Description: Configure IPv4 address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Configure IPv4 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)

  address = __builtin__.property(_get_address, _set_address) # type: yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_addresses_address

  __choices__ = {'address': {'common-address': ['address']}}
  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_unnumbered_address_huawei_ifm__ifm_interfaces_interface_ipv4_unnumbered_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/unnumbered-address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure unnumbered interface. The address borrowing relationship of the DCN interface cannot be created, modified, or deleted.
  """
  __slots__ = ('_path_helper', '_extmethods', '__unnumbered_if_name',)

  _yang_name = 'unnumbered-address'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__unnumbered_if_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unnumbered-if-name", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'unnumbered-address']

  def _get_unnumbered_if_name(self):
    """
    Getter method for unnumbered_if_name, mapped from YANG variable /ifm/interfaces/interface/ipv4/unnumbered_address/unnumbered_if_name (leafref)

    YANG Description: Name of an unnumbered interface.
    """
    return self.__unnumbered_if_name
      
  def _set_unnumbered_if_name(self, v, load=False):
    """
    Setter method for unnumbered_if_name, mapped from YANG variable /ifm/interfaces/interface/ipv4/unnumbered_address/unnumbered_if_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unnumbered_if_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unnumbered_if_name() directly.

    YANG Description: Name of an unnumbered interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="unnumbered-if-name", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unnumbered_if_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unnumbered-if-name", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='leafref', is_config=True)""",
        })

    self.__unnumbered_if_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unnumbered_if_name(self):
    self.__unnumbered_if_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="unnumbered-if-name", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='leafref', is_config=True)

  unnumbered_if_name = __builtin__.property(_get_unnumbered_if_name, _set_unnumbered_if_name)

  __choices__ = {'address': {'unnumbered-address': ['unnumbered_if_name']}}
  _pyangbind_elements = OrderedDict([('unnumbered_if_name', unnumbered_if_name), ])


class yc_negotiation_address_huawei_ifm__ifm_interfaces_interface_ipv4_negotiation_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/negotiation-address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure negotiate address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__negotiation_type',)

  _yang_name = 'negotiation-address'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__negotiation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ppp-negotiate': {'value': 0}},), is_leaf=True, yang_name="negotiation-type", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='negotiation-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'negotiation-address']

  def _get_negotiation_type(self):
    """
    Getter method for negotiation_type, mapped from YANG variable /ifm/interfaces/interface/ipv4/negotiation_address/negotiation_type (negotiation-type)

    YANG Description: Enable negotiation address on interface.
    """
    return self.__negotiation_type
      
  def _set_negotiation_type(self, v, load=False):
    """
    Setter method for negotiation_type, mapped from YANG variable /ifm/interfaces/interface/ipv4/negotiation_address/negotiation_type (negotiation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_negotiation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_negotiation_type() directly.

    YANG Description: Enable negotiation address on interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ppp-negotiate': {'value': 0}},), is_leaf=True, yang_name="negotiation-type", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='negotiation-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """negotiation_type must be of a type compatible with negotiation-type""",
          'defined-type': "huawei-ip:negotiation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ppp-negotiate': {'value': 0}},), is_leaf=True, yang_name="negotiation-type", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='negotiation-type', is_config=True)""",
        })

    self.__negotiation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_negotiation_type(self):
    self.__negotiation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ppp-negotiate': {'value': 0}},), is_leaf=True, yang_name="negotiation-type", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='negotiation-type', is_config=True)

  negotiation_type = __builtin__.property(_get_negotiation_type, _set_negotiation_type)

  __choices__ = {'address': {'negotiate-address': ['negotiation_type']}}
  _pyangbind_elements = OrderedDict([('negotiation_type', negotiation_type), ])


class yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/state/addresses/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state of IPv4 address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__mask','__type','__is_block',)

  _yang_name = 'address'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__mask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}, 'neg': {'value': 4}, 'unnumber': {'value': 2}, 'dhcp': {'value': 256}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-state-type', is_config=False)
    self.__is_block = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'state', 'addresses', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/ip (inet:ipv4-address-no-zone)

    YANG Description: IPv4 address.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: IPv4 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_mask(self):
    """
    Getter method for mask, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/mask (ipv4-netmask)

    YANG Description: IPv4 address mask.
    """
    return self.__mask
      
  def _set_mask(self, v, load=False):
    """
    Setter method for mask, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/mask (ipv4-netmask)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mask is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mask() directly.

    YANG Description: IPv4 address mask.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mask must be of a type compatible with ipv4-netmask""",
          'defined-type': "huawei-ip:ipv4-netmask",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=False)""",
        })

    self.__mask = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mask(self):
    self.__mask = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([1-9]?[0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))', 'length': ['9..15']}), is_leaf=True, yang_name="mask", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-netmask', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/type (ipv4-address-state-type)

    YANG Description: IPv4 address type.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/type (ipv4-address-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: IPv4 address type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}, 'neg': {'value': 4}, 'unnumber': {'value': 2}, 'dhcp': {'value': 256}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-state-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with ipv4-address-state-type""",
          'defined-type': "huawei-ip:ipv4-address-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}, 'neg': {'value': 4}, 'unnumber': {'value': 2}, 'dhcp': {'value': 256}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-state-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main': {'value': 1}, 'sub': {'value': 32}, 'neg': {'value': 4}, 'unnumber': {'value': 2}, 'dhcp': {'value': 256}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv4-address-state-type', is_config=False)


  def _get_is_block(self):
    """
    Getter method for is_block, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/is_block (boolean)

    YANG Description: IPv4 address is blocked or not.
    """
    return self.__is_block
      
  def _set_is_block(self, v, load=False):
    """
    Setter method for is_block, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address/is_block (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_block is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_block() directly.

    YANG Description: IPv4 address is blocked or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_block must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)""",
        })

    self.__is_block = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_block(self):
    self.__is_block = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)

  ip = __builtin__.property(_get_ip)
  mask = __builtin__.property(_get_mask)
  type = __builtin__.property(_get_type)
  is_block = __builtin__.property(_get_is_block)


  _pyangbind_elements = OrderedDict([('ip', ip), ('mask', mask), ('type', type), ('is_block', is_block), ])


class yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/state/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'addresses'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'state', 'addresses']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address (list)

    YANG Description: Operational state of IPv4 address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Operational state of IPv4 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)

  address = __builtin__.property(_get_address) # type: yc_address_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses_address


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_gateway_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways_gateway(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/state/gateways/gateway. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state of gateway addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__gateway',)

  _yang_name = 'gateway'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__gateway = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'state', 'gateways', 'gateway']

  def _get_gateway(self):
    """
    Getter method for gateway, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/gateways/gateway/gateway (inet:ipv4-address)

    YANG Description: Gateway of interface.
    """
    return self.__gateway
      
  def _set_gateway(self, v, load=False):
    """
    Setter method for gateway, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/gateways/gateway/gateway (inet:ipv4-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway() directly.

    YANG Description: Gateway of interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateway must be of a type compatible with inet:ipv4-address""",
          'defined-type': "inet:ipv4-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address', is_config=False)""",
        })

    self.__gateway = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateway(self):
    self.__gateway = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), is_leaf=True, yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv4-address', is_config=False)

  gateway = __builtin__.property(_get_gateway)


  _pyangbind_elements = OrderedDict([('gateway', gateway), ])


class yc_gateways_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/state/gateways. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of gateway addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__gateway',)

  _yang_name = 'gateways'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__gateway = YANGDynClass(base=YANGListType("gateway",yc_gateway_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways_gateway, yang_name="gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='gateway', extensions=None), is_container='list', yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'state', 'gateways']

  def _get_gateway(self):
    """
    Getter method for gateway, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/gateways/gateway (list)

    YANG Description: Operational state of gateway addresses.
    """
    return self.__gateway
      
  def _set_gateway(self, v, load=False):
    """
    Setter method for gateway, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/gateways/gateway (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway() directly.

    YANG Description: Operational state of gateway addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("gateway",yc_gateway_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways_gateway, yang_name="gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='gateway', extensions=None), is_container='list', yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateway must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("gateway",yc_gateway_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways_gateway, yang_name="gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='gateway', extensions=None), is_container='list', yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)""",
        })

    self.__gateway = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateway(self):
    self.__gateway = YANGDynClass(base=YANGListType("gateway",yc_gateway_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways_gateway, yang_name="gateway", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='gateway', extensions=None), is_container='list', yang_name="gateway", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)

  gateway = __builtin__.property(_get_gateway) # type: yc_gateway_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways_gateway


  _pyangbind_elements = OrderedDict([('gateway', gateway), ])


class yc_state_huawei_ifm__ifm_interfaces_interface_ipv4_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state of IPv4 addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__addresses','__gateways',)

  _yang_name = 'state'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)
    self.__gateways = YANGDynClass(base=yc_gateways_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways, is_container='container', yang_name="gateways", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4', 'state']

  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses (container)

    YANG Description: List of addresses.
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: List of addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)


  def _get_gateways(self):
    """
    Getter method for gateways, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/gateways (container)

    YANG Description: List of gateway addresses.
    """
    return self.__gateways
      
  def _set_gateways(self, v, load=False):
    """
    Setter method for gateways, mapped from YANG variable /ifm/interfaces/interface/ipv4/state/gateways (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateways is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateways() directly.

    YANG Description: List of gateway addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_gateways_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways, is_container='container', yang_name="gateways", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gateways must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_gateways_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways, is_container='container', yang_name="gateways", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)""",
        })

    self.__gateways = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gateways(self):
    self.__gateways = YANGDynClass(base=yc_gateways_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways, is_container='container', yang_name="gateways", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)

  addresses = __builtin__.property(_get_addresses) # type: yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_state_addresses
  gateways = __builtin__.property(_get_gateways) # type: yc_gateways_huawei_ifm__ifm_interfaces_interface_ipv4_state_gateways


  _pyangbind_elements = OrderedDict([('addresses', addresses), ('gateways', gateways), ])


class yc_ipv4_huawei_ifm__ifm_interfaces_interface_ipv4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure IPv4 addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__addresses','__unnumbered_address','__negotiation_address','__state',)

  _yang_name = 'ipv4'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    self.__unnumbered_address = YANGDynClass(base=yc_unnumbered_address_huawei_ifm__ifm_interfaces_interface_ipv4_unnumbered_address, is_container='container', yang_name="unnumbered-address", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    self.__negotiation_address = YANGDynClass(base=yc_negotiation_address_huawei_ifm__ifm_interfaces_interface_ipv4_negotiation_address, is_container='container', yang_name="negotiation-address", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv4']

  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses (container)

    YANG Description: List of common addresses. The IPv4 address of the DCN interface cannot be created, modified, or deleted.
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv4/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: List of common addresses. The IPv4 address of the DCN interface cannot be created, modified, or deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)


  def _get_unnumbered_address(self):
    """
    Getter method for unnumbered_address, mapped from YANG variable /ifm/interfaces/interface/ipv4/unnumbered_address (container)

    YANG Description: Configure unnumbered interface. The address borrowing relationship of the DCN interface cannot be created, modified, or deleted.
    """
    return self.__unnumbered_address
      
  def _set_unnumbered_address(self, v, load=False):
    """
    Setter method for unnumbered_address, mapped from YANG variable /ifm/interfaces/interface/ipv4/unnumbered_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_unnumbered_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_unnumbered_address() directly.

    YANG Description: Configure unnumbered interface. The address borrowing relationship of the DCN interface cannot be created, modified, or deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_unnumbered_address_huawei_ifm__ifm_interfaces_interface_ipv4_unnumbered_address, is_container='container', yang_name="unnumbered-address", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """unnumbered_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_unnumbered_address_huawei_ifm__ifm_interfaces_interface_ipv4_unnumbered_address, is_container='container', yang_name="unnumbered-address", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__unnumbered_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_unnumbered_address(self):
    self.__unnumbered_address = YANGDynClass(base=yc_unnumbered_address_huawei_ifm__ifm_interfaces_interface_ipv4_unnumbered_address, is_container='container', yang_name="unnumbered-address", parent=self, choice=('address', 'unnumbered-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)


  def _get_negotiation_address(self):
    """
    Getter method for negotiation_address, mapped from YANG variable /ifm/interfaces/interface/ipv4/negotiation_address (container)

    YANG Description: Configure negotiate address.
    """
    return self.__negotiation_address
      
  def _set_negotiation_address(self, v, load=False):
    """
    Setter method for negotiation_address, mapped from YANG variable /ifm/interfaces/interface/ipv4/negotiation_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_negotiation_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_negotiation_address() directly.

    YANG Description: Configure negotiate address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_negotiation_address_huawei_ifm__ifm_interfaces_interface_ipv4_negotiation_address, is_container='container', yang_name="negotiation-address", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """negotiation_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_negotiation_address_huawei_ifm__ifm_interfaces_interface_ipv4_negotiation_address, is_container='container', yang_name="negotiation-address", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__negotiation_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_negotiation_address(self):
    self.__negotiation_address = YANGDynClass(base=yc_negotiation_address_huawei_ifm__ifm_interfaces_interface_ipv4_negotiation_address, is_container='container', yang_name="negotiation-address", parent=self, choice=('address', 'negotiate-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ifm/interfaces/interface/ipv4/state (container)

    YANG Description: Operational state of IPv4 addresses.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ifm/interfaces/interface/ipv4/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state of IPv4 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv4_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)

  addresses = __builtin__.property(_get_addresses, _set_addresses) # type: yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv4_addresses
  unnumbered_address = __builtin__.property(_get_unnumbered_address, _set_unnumbered_address) # type: yc_unnumbered_address_huawei_ifm__ifm_interfaces_interface_ipv4_unnumbered_address
  negotiation_address = __builtin__.property(_get_negotiation_address, _set_negotiation_address) # type: yc_negotiation_address_huawei_ifm__ifm_interfaces_interface_ipv4_negotiation_address
  state = __builtin__.property(_get_state, _set_state) # type: yc_state_huawei_ifm__ifm_interfaces_interface_ipv4_state

  __choices__ = {'address': {'common-address': ['addresses'], 'unnumbered-address': ['unnumbered_address'], 'negotiate-address': ['negotiation_address']}}
  _pyangbind_elements = OrderedDict([('addresses', addresses), ('unnumbered_address', unnumbered_address), ('negotiation_address', negotiation_address), ('state', state), ])


class yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_addresses_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6/addresses/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure IPv6 address.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type','__algorithm_type',)

  _yang_name = 'address'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-config-type', is_config=True)
    self.__algorithm_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), default=six.text_type("none"), is_leaf=True, yang_name="algorithm-type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6', 'addresses', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/ip (inet:ipv6-address-no-zone)

    YANG Description: IPv6 address.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/ip (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: IPv6 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/prefix_length (uint32)

    YANG Description: Length of the IPv6 address prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/prefix_length (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: Length of the IPv6 address prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/type (ipv6-address-config-type)

    YANG Description: IPv6 address type.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/type (ipv6-address-config-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: IPv6 address type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-config-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with ipv6-address-config-type""",
          'defined-type': "huawei-ip:ipv6-address-config-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-config-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-config-type', is_config=True)


  def _get_algorithm_type(self):
    """
    Getter method for algorithm_type, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/algorithm_type (ipv6-address-algorithm-type)

    YANG Description: Address algorithm type.
    """
    return self.__algorithm_type
      
  def _set_algorithm_type(self, v, load=False):
    """
    Setter method for algorithm_type, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address/algorithm_type (ipv6-address-algorithm-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algorithm_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algorithm_type() directly.

    YANG Description: Address algorithm type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), default=six.text_type("none"), is_leaf=True, yang_name="algorithm-type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """algorithm_type must be of a type compatible with ipv6-address-algorithm-type""",
          'defined-type': "huawei-ip:ipv6-address-algorithm-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), default=six.text_type("none"), is_leaf=True, yang_name="algorithm-type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=True)""",
        })

    self.__algorithm_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_algorithm_type(self):
    self.__algorithm_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), default=six.text_type("none"), is_leaf=True, yang_name="algorithm-type", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=True)

  ip = __builtin__.property(_get_ip, _set_ip)
  prefix_length = __builtin__.property(_get_prefix_length, _set_prefix_length)
  type = __builtin__.property(_get_type, _set_type)
  algorithm_type = __builtin__.property(_get_algorithm_type, _set_algorithm_type)

  __choices__ = {'address': {'common-address': ['ip', 'prefix_length', 'type', 'algorithm_type']}}
  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ('algorithm_type', algorithm_type), ])


class yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of IPv6 addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'addresses'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6', 'addresses']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address (list)

    YANG Description: Configure IPv6 address.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Configure IPv6 address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None, choice=('address', 'common-address')), is_container='list', yang_name="address", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)

  address = __builtin__.property(_get_address, _set_address) # type: yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_addresses_address

  __choices__ = {'address': {'common-address': ['address']}}
  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_nd_prefix_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs_nd_prefix(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6/nd-prefixs/nd-prefix. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure nd prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__prefix_len','__valid_lifetime','__preferred_lifetime','__auto_flag','__on_link_flag',)

  _yang_name = 'nd-prefix'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)
    self.__prefix_len = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='int32', is_config=True)
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    self.__auto_flag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)
    self.__on_link_flag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="on-link-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6', 'nd-prefixs', 'nd-prefix']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/prefix (inet:ipv6-address-no-zone)

    YANG Description: IPv6 address of the prefix.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/prefix (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: IPv6 address of the prefix.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=True)


  def _get_prefix_len(self):
    """
    Getter method for prefix_len, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/prefix_len (int32)

    YANG Description: Length of the prefix address.
    """
    return self.__prefix_len
      
  def _set_prefix_len(self, v, load=False):
    """
    Setter method for prefix_len, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/prefix_len (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_len is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_len() directly.

    YANG Description: Length of the prefix address.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='int32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_len must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='int32', is_config=True)""",
        })

    self.__prefix_len = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_len(self):
    self.__prefix_len = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), restriction_dict={'range': ['0..128']}), is_leaf=True, yang_name="prefix-len", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='int32', is_config=True)


  def _get_valid_lifetime(self):
    """
    Getter method for valid_lifetime, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/valid_lifetime (uint32)

    YANG Description: Valid life time.
    """
    return self.__valid_lifetime
      
  def _set_valid_lifetime(self, v, load=False):
    """
    Setter method for valid_lifetime, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/valid_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valid_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valid_lifetime() directly.

    YANG Description: Valid life time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valid_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)""",
        })

    self.__valid_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valid_lifetime(self):
    self.__valid_lifetime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="valid-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)


  def _get_preferred_lifetime(self):
    """
    Getter method for preferred_lifetime, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/preferred_lifetime (uint32)

    YANG Description: Preferred life time.
    """
    return self.__preferred_lifetime
      
  def _set_preferred_lifetime(self, v, load=False):
    """
    Setter method for preferred_lifetime, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/preferred_lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferred_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferred_lifetime() directly.

    YANG Description: Preferred life time.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preferred_lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)""",
        })

    self.__preferred_lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preferred_lifetime(self):
    self.__preferred_lifetime = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="preferred-lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)


  def _get_auto_flag(self):
    """
    Getter method for auto_flag, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/auto_flag (boolean)

    YANG Description: Enable/disable the autonomous address-configuration.
    """
    return self.__auto_flag
      
  def _set_auto_flag(self, v, load=False):
    """
    Setter method for auto_flag, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/auto_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_flag() directly.

    YANG Description: Enable/disable the autonomous address-configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)""",
        })

    self.__auto_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_flag(self):
    self.__auto_flag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="auto-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)


  def _get_on_link_flag(self):
    """
    Getter method for on_link_flag, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/on_link_flag (boolean)

    YANG Description: Enable/disable the on-link flag.
    """
    return self.__on_link_flag
      
  def _set_on_link_flag(self, v, load=False):
    """
    Setter method for on_link_flag, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix/on_link_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_on_link_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_on_link_flag() directly.

    YANG Description: Enable/disable the on-link flag.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="on-link-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """on_link_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="on-link-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)""",
        })

    self.__on_link_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_on_link_flag(self):
    self.__on_link_flag = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="on-link-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)

  prefix = __builtin__.property(_get_prefix, _set_prefix)
  prefix_len = __builtin__.property(_get_prefix_len, _set_prefix_len)
  valid_lifetime = __builtin__.property(_get_valid_lifetime, _set_valid_lifetime)
  preferred_lifetime = __builtin__.property(_get_preferred_lifetime, _set_preferred_lifetime)
  auto_flag = __builtin__.property(_get_auto_flag, _set_auto_flag)
  on_link_flag = __builtin__.property(_get_on_link_flag, _set_on_link_flag)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('prefix_len', prefix_len), ('valid_lifetime', valid_lifetime), ('preferred_lifetime', preferred_lifetime), ('auto_flag', auto_flag), ('on_link_flag', on_link_flag), ])


class yc_nd_prefixs_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6/nd-prefixs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of nd prefix.
  """
  __slots__ = ('_path_helper', '_extmethods', '__nd_prefix',)

  _yang_name = 'nd-prefixs'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__nd_prefix = YANGDynClass(base=YANGListType("prefix",yc_nd_prefix_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs_nd_prefix, yang_name="nd-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="nd-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6', 'nd-prefixs']

  def _get_nd_prefix(self):
    """
    Getter method for nd_prefix, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix (list)

    YANG Description: Configure nd prefix.
    """
    return self.__nd_prefix
      
  def _set_nd_prefix(self, v, load=False):
    """
    Setter method for nd_prefix, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs/nd_prefix (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nd_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nd_prefix() directly.

    YANG Description: Configure nd prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix",yc_nd_prefix_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs_nd_prefix, yang_name="nd-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="nd-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nd_prefix must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix",yc_nd_prefix_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs_nd_prefix, yang_name="nd-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="nd-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)""",
        })

    self.__nd_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nd_prefix(self):
    self.__nd_prefix = YANGDynClass(base=YANGListType("prefix",yc_nd_prefix_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs_nd_prefix, yang_name="nd-prefix", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="nd-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=True)

  nd_prefix = __builtin__.property(_get_nd_prefix, _set_nd_prefix) # type: yc_nd_prefix_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs_nd_prefix


  _pyangbind_elements = OrderedDict([('nd_prefix', nd_prefix), ])


class yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses_address(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6/state/addresses/address. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state of IPv6 addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ip','__prefix_length','__type','__algorithm_type','__collision_count','__is_block','__status',)

  _yang_name = 'address'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'auto-link-local': {'value': 3}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-state-type', is_config=False)
    self.__algorithm_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), is_leaf=True, yang_name="algorithm-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=False)
    self.__collision_count = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="collision-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint8', is_config=False)
    self.__is_block = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {'value': 1}, 'inaccessible': {'value': 4}, 'unknown': {'value': 5}, 'tentative': {'value': 6}, 'duplicate': {'value': 7}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-status-type', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6', 'state', 'addresses', 'address']

  def _get_ip(self):
    """
    Getter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/ip (inet:ipv6-address-no-zone)

    YANG Description: IPv6 address.
    """
    return self.__ip
      
  def _set_ip(self, v, load=False):
    """
    Setter method for ip, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/ip (inet:ipv6-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip() directly.

    YANG Description: IPv6 address.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ip must be of a type compatible with inet:ipv6-address-no-zone""",
          'defined-type': "inet:ipv6-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)""",
        })

    self.__ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ip(self):
    self.__ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}), is_leaf=True, yang_name="ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='inet:ipv6-address-no-zone', is_config=False)


  def _get_prefix_length(self):
    """
    Getter method for prefix_length, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/prefix_length (uint32)

    YANG Description: Length of the IPv6 address prefix.
    """
    return self.__prefix_length
      
  def _set_prefix_length(self, v, load=False):
    """
    Setter method for prefix_length, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/prefix_length (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix_length() directly.

    YANG Description: Length of the IPv6 address prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix_length must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)""",
        })

    self.__prefix_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix_length(self):
    self.__prefix_length = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..128']}), is_leaf=True, yang_name="prefix-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/type (ipv6-address-state-type)

    YANG Description: IPv6 address type.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/type (ipv6-address-state-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: IPv6 address type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'auto-link-local': {'value': 3}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-state-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with ipv6-address-state-type""",
          'defined-type': "huawei-ip:ipv6-address-state-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'auto-link-local': {'value': 3}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-state-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'global': {'value': 1}, 'link-local': {'value': 2}, 'auto-link-local': {'value': 3}, 'anycast': {'value': 6}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-state-type', is_config=False)


  def _get_algorithm_type(self):
    """
    Getter method for algorithm_type, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/algorithm_type (ipv6-address-algorithm-type)

    YANG Description: Address algorithm type.
    """
    return self.__algorithm_type
      
  def _set_algorithm_type(self, v, load=False):
    """
    Setter method for algorithm_type, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/algorithm_type (ipv6-address-algorithm-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algorithm_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algorithm_type() directly.

    YANG Description: Address algorithm type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), is_leaf=True, yang_name="algorithm-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """algorithm_type must be of a type compatible with ipv6-address-algorithm-type""",
          'defined-type': "huawei-ip:ipv6-address-algorithm-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), is_leaf=True, yang_name="algorithm-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=False)""",
        })

    self.__algorithm_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_algorithm_type(self):
    self.__algorithm_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'cga': {'value': 1}, 'eui64': {'value': 2}},), is_leaf=True, yang_name="algorithm-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-address-algorithm-type', is_config=False)


  def _get_collision_count(self):
    """
    Getter method for collision_count, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/collision_count (uint8)

    YANG Description: Number of IPv6 address collisions.
    """
    return self.__collision_count
      
  def _set_collision_count(self, v, load=False):
    """
    Setter method for collision_count, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/collision_count (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_collision_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_collision_count() directly.

    YANG Description: Number of IPv6 address collisions.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="collision-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """collision_count must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="collision-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint8', is_config=False)""",
        })

    self.__collision_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_collision_count(self):
    self.__collision_count = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..3']}), is_leaf=True, yang_name="collision-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint8', is_config=False)


  def _get_is_block(self):
    """
    Getter method for is_block, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/is_block (boolean)

    YANG Description: IPv6 address is blocked or not.
    """
    return self.__is_block
      
  def _set_is_block(self, v, load=False):
    """
    Setter method for is_block, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/is_block (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_block is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_block() directly.

    YANG Description: IPv6 address is blocked or not.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_block must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)""",
        })

    self.__is_block = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_block(self):
    self.__is_block = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-block", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=False)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/status (ipv6-status-type)

    YANG Description: IPv6 address status.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address/status (ipv6-status-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: IPv6 address status.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {'value': 1}, 'inaccessible': {'value': 4}, 'unknown': {'value': 5}, 'tentative': {'value': 6}, 'duplicate': {'value': 7}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-status-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with ipv6-status-type""",
          'defined-type': "huawei-ip:ipv6-status-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {'value': 1}, 'inaccessible': {'value': 4}, 'unknown': {'value': 5}, 'tentative': {'value': 6}, 'duplicate': {'value': 7}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-status-type', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'preferred': {'value': 1}, 'inaccessible': {'value': 4}, 'unknown': {'value': 5}, 'tentative': {'value': 6}, 'duplicate': {'value': 7}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='ipv6-status-type', is_config=False)

  ip = __builtin__.property(_get_ip)
  prefix_length = __builtin__.property(_get_prefix_length)
  type = __builtin__.property(_get_type)
  algorithm_type = __builtin__.property(_get_algorithm_type)
  collision_count = __builtin__.property(_get_collision_count)
  is_block = __builtin__.property(_get_is_block)
  status = __builtin__.property(_get_status)


  _pyangbind_elements = OrderedDict([('ip', ip), ('prefix_length', prefix_length), ('type', type), ('algorithm_type', algorithm_type), ('collision_count', collision_count), ('is_block', is_block), ('status', status), ])


class yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6/state/addresses. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of IPv6 addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__address',)

  _yang_name = 'addresses'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6', 'state', 'addresses']

  def _get_address(self):
    """
    Getter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address (list)

    YANG Description: Operational state of IPv6 addresses.
    """
    return self.__address
      
  def _set_address(self, v, load=False):
    """
    Setter method for address, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses/address (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address() directly.

    YANG Description: Operational state of IPv6 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """address must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)""",
        })

    self.__address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_address(self):
    self.__address = YANGDynClass(base=YANGListType("ip",yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses_address, yang_name="address", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ip', extensions=None), is_container='list', yang_name="address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='list', is_config=False)

  address = __builtin__.property(_get_address) # type: yc_address_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses_address


  _pyangbind_elements = OrderedDict([('address', address), ])


class yc_state_huawei_ifm__ifm_interfaces_interface_ipv6_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state of IPv6 addresses.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mtu6','__addresses',)

  _yang_name = 'state'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mtu6 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6', 'state']

  def _get_mtu6(self):
    """
    Getter method for mtu6, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/mtu6 (uint32)

    YANG Description: IPv6 maximum transmission unit of an interface.
Special explanation:
Range: The server may restrict the allowed values for this leaf, depending on the interface's type.
    """
    return self.__mtu6
      
  def _set_mtu6(self, v, load=False):
    """
    Setter method for mtu6, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/mtu6 (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu6() directly.

    YANG Description: IPv6 maximum transmission unit of an interface.
Special explanation:
Range: The server may restrict the allowed values for this leaf, depending on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu6 must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)""",
        })

    self.__mtu6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu6(self):
    self.__mtu6 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=False)


  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses (container)

    YANG Description: List of IPv6 addresses.
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv6/state/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: List of IPv6 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses, is_container='container', yang_name="addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=False)

  mtu6 = __builtin__.property(_get_mtu6)
  addresses = __builtin__.property(_get_addresses) # type: yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_state_addresses


  _pyangbind_elements = OrderedDict([('mtu6', mtu6), ('addresses', addresses), ])


class yc_ipv6_huawei_ifm__ifm_interfaces_interface_ipv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface/ipv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enable/disable the IPv6 capability on an interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mtu6','__spread_mtu_flag','__auto_link_local','__addresses','__nd_prefixs','__state',)

  _yang_name = 'ipv6'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mtu6 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    self.__spread_mtu_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)
    self.__auto_link_local = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="auto-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    self.__nd_prefixs = YANGDynClass(base=yc_nd_prefixs_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs, is_container='container', yang_name="nd-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface', 'ipv6']

  def _get_mtu6(self):
    """
    Getter method for mtu6, mapped from YANG variable /ifm/interfaces/interface/ipv6/mtu6 (uint32)

    YANG Description: IPv6 maximum transmission unit of an interface.
Special explanation:
Range: The server may restrict the allowed values for this leaf, depending on the interface's type.
    """
    return self.__mtu6
      
  def _set_mtu6(self, v, load=False):
    """
    Setter method for mtu6, mapped from YANG variable /ifm/interfaces/interface/ipv6/mtu6 (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu6() directly.

    YANG Description: IPv6 maximum transmission unit of an interface.
Special explanation:
Range: The server may restrict the allowed values for this leaf, depending on the interface's type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu6 must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)""",
        })

    self.__mtu6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu6(self):
    self.__mtu6 = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..50000']}), is_leaf=True, yang_name="mtu6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='uint32', is_config=True)


  def _get_spread_mtu_flag(self):
    """
    Getter method for spread_mtu_flag, mapped from YANG variable /ifm/interfaces/interface/ipv6/spread_mtu_flag (boolean)

    YANG Description: Enable/disable the function of spreading the IPv6 MTU of main interface to subinterface.
    """
    return self.__spread_mtu_flag
      
  def _set_spread_mtu_flag(self, v, load=False):
    """
    Setter method for spread_mtu_flag, mapped from YANG variable /ifm/interfaces/interface/ipv6/spread_mtu_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spread_mtu_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spread_mtu_flag() directly.

    YANG Description: Enable/disable the function of spreading the IPv6 MTU of main interface to subinterface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spread_mtu_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)""",
        })

    self.__spread_mtu_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spread_mtu_flag(self):
    self.__spread_mtu_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)


  def _get_auto_link_local(self):
    """
    Getter method for auto_link_local, mapped from YANG variable /ifm/interfaces/interface/ipv6/auto_link_local (boolean)

    YANG Description: Enable/disable an interface with the auto linklocal address function.
    """
    return self.__auto_link_local
      
  def _set_auto_link_local(self, v, load=False):
    """
    Setter method for auto_link_local, mapped from YANG variable /ifm/interfaces/interface/ipv6/auto_link_local (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_link_local is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_link_local() directly.

    YANG Description: Enable/disable an interface with the auto linklocal address function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="auto-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_link_local must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="auto-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)""",
        })

    self.__auto_link_local = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_link_local(self):
    self.__auto_link_local = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="auto-link-local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='boolean', is_config=True)


  def _get_addresses(self):
    """
    Getter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses (container)

    YANG Description: List of IPv6 addresses.
    """
    return self.__addresses
      
  def _set_addresses(self, v, load=False):
    """
    Setter method for addresses, mapped from YANG variable /ifm/interfaces/interface/ipv6/addresses (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_addresses() directly.

    YANG Description: List of IPv6 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """addresses must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__addresses = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_addresses(self):
    self.__addresses = YANGDynClass(base=yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_addresses, is_container='container', yang_name="addresses", parent=self, choice=('address', 'common-address'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)


  def _get_nd_prefixs(self):
    """
    Getter method for nd_prefixs, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs (container)

    YANG Description: List of nd prefix.
    """
    return self.__nd_prefixs
      
  def _set_nd_prefixs(self, v, load=False):
    """
    Setter method for nd_prefixs, mapped from YANG variable /ifm/interfaces/interface/ipv6/nd_prefixs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nd_prefixs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nd_prefixs() directly.

    YANG Description: List of nd prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_nd_prefixs_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs, is_container='container', yang_name="nd-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nd_prefixs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_nd_prefixs_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs, is_container='container', yang_name="nd-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__nd_prefixs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nd_prefixs(self):
    self.__nd_prefixs = YANGDynClass(base=yc_nd_prefixs_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs, is_container='container', yang_name="nd-prefixs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /ifm/interfaces/interface/ipv6/state (container)

    YANG Description: Operational state of IPv6 addresses.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /ifm/interfaces/interface/ipv6/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state of IPv6 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_huawei_ifm__ifm_interfaces_interface_ipv6_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)

  mtu6 = __builtin__.property(_get_mtu6, _set_mtu6)
  spread_mtu_flag = __builtin__.property(_get_spread_mtu_flag, _set_spread_mtu_flag)
  auto_link_local = __builtin__.property(_get_auto_link_local, _set_auto_link_local)
  addresses = __builtin__.property(_get_addresses, _set_addresses) # type: yc_addresses_huawei_ifm__ifm_interfaces_interface_ipv6_addresses
  nd_prefixs = __builtin__.property(_get_nd_prefixs, _set_nd_prefixs) # type: yc_nd_prefixs_huawei_ifm__ifm_interfaces_interface_ipv6_nd_prefixs
  state = __builtin__.property(_get_state, _set_state) # type: yc_state_huawei_ifm__ifm_interfaces_interface_ipv6_state

  __choices__ = {'address': {'common-address': ['addresses']}}
  _pyangbind_elements = OrderedDict([('mtu6', mtu6), ('spread_mtu_flag', spread_mtu_flag), ('auto_link_local', auto_link_local), ('addresses', addresses), ('nd_prefixs', nd_prefixs), ('state', state), ])


class yc_interface_huawei_ifm__ifm_interfaces_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces/interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure information on an interface. Physical, NULL, Virtual-if, and Virtual-Template0 interfaces cannot be created or deleted.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__class_','__type','__parent_name','__number','__description','__admin_status','__link_protocol','__router_type','__clear_ip_df','__link_up_down_trap_enable','__statistic_enable','__statistic_mode','__bandwidth','__bandwidth_kbps','__mtu','__spread_mtu_flag','__statistic_interval','__vrf_name','__l2_mode_enable','__down_delay_time','__mac_address','__index','__position','__aggregation_name','__is_l2_switch','__vs_name','__l2_switch_port_index','__service_type','__encapsulation_type','__network_layer_status','__protocol_up_delay_time','__control_flap','__trap_threshold','__ignore_damp','__damp','__damp_state','__dynamic','__mib_statistics','__common_statistics','__error_down','__tunnel_protocol','__ipv4','__ipv6',)

  _yang_name = 'interface'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=True)
    self.__class_ = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main-interface': {'value': 0}, 'sub-interface': {'value': 1}},), is_leaf=True, yang_name="class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='class-type', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=True)
    self.__parent_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parent-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)
    self.__number = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(\\d+/\\d+/\\d+/\\d+)|(\\d+/\\d+/\\d+)|(\\d+/\\d+)|(\\d+)|(\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+[:]\\d+)', 'length': ['1..63']}), is_leaf=True, yang_name="number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=True)
    self.__link_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ethernet': {'value': 0}, 'ppp': {'value': 1}, 'hdlc': {'value': 2}, 'fr': {'value': 3}, 'atm': {'value': 6}, 'tdm': {'value': 7}},), is_leaf=True, yang_name="link-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-protocol', is_config=True)
    self.__router_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PtoP': {'value': 0}, 'PtoMP': {'value': 1}, 'broadcast': {'value': 2}, 'NBMA': {'value': 3}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="router-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='router-type', is_config=True)
    self.__clear_ip_df = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="clear-ip-df", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__link_up_down_trap_enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__statistic_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__statistic_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'interface-based': {'value': 1}, 'vlan-group-based': {'value': 2}},), default=six.text_type("interface-based"), is_leaf=True, yang_name="statistic-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='statistic-mode', is_config=True)
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth", parent=self, choice=('bandwidth-type', 'bandwidth-mbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__bandwidth_kbps = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth-kbps", parent=self, choice=('bandwidth-type', 'bandwidth-kbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..64000']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__spread_mtu_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__statistic_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__vrf_name = YANGDynClass(base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)
    self.__l2_mode_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2-mode-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    self.__down_delay_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=True)
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__position = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__aggregation_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="aggregation-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)
    self.__is_l2_switch = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="is-l2-switch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)
    self.__vs_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="vs-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__l2_switch_port_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="l2-switch-port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__service_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'trunk-member': {'value': 2}, 'stack-member': {'value': 6}, 'mp-member': {'value': 7}, 'vbridge-member': {'value': 8}, 'ima-member': {'value': 9}, 'bundle-member': {'value': 10}, 'fabric-member': {'value': 11}, 'lag-master-member': {'value': 12}, 'lag-slave-member': {'value': 13}, 'cpos-trunk-member': {'value': 15}, 'pos-trunk-member': {'value': 16}, 'global-mp-member': {'value': 17}, 'global-ima-member': {'value': 18}},), is_leaf=True, yang_name="service-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='service-type', is_config=False)
    self.__encapsulation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'vlan-type': {'value': 0}, 'dot1q': {'value': 1}, 'qinq': {'value': 2}, 'p2p': {'value': 3}, 'p2mp': {'value': 4}, 'l2ve': {'value': 5}, 'l3ve': {'value': 6}, 'vlan-type-policy': {'value': 7}, 'dot1q-policy': {'value': 8}, 'stacking-policy': {'value': 9}, 'untag-policy': {'value': 10}, 'qinq-mapping': {'value': 11}, 'l2vc': {'value': 12}, 'l3vc': {'value': 13}, 'evc-untag': {'value': 14}, 'evc-dot1q': {'value': 15}, 'evc-qinq': {'value': 16}, 'evc-default': {'value': 17}, 'evc-dot1q-policy': {'value': 18}, 'ietf': {'value': 19}, 'nonstandard': {'value': 20}, 'user-vlan': {'value': 21}, 'user-vlan-anyother': {'value': 22}, 'qin-link': {'value': 23}, 'soft-gre-ve': {'value': 24}, 'l3ve-ter': {'value': 25}, 'l3ve-acc': {'value': 26}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='encapsulation-type', is_config=False)
    self.__network_layer_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-ipv6-up': {'value': 0}, 'ipv4-ipv6-down': {'value': 196608}},), default=six.text_type("ipv4-ipv6-up"), is_leaf=True, yang_name="network-layer-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='network-layer-state', is_config=True)
    self.__protocol_up_delay_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..7200']}), is_leaf=True, yang_name="protocol-up-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    self.__control_flap = YANGDynClass(base=yc_control_flap_huawei_ifm__ifm_interfaces_interface_control_flap, is_container='container', yang_name="control-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__trap_threshold = YANGDynClass(base=yc_trap_threshold_huawei_ifm__ifm_interfaces_interface_trap_threshold, is_container='container', yang_name="trap-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__ignore_damp = YANGDynClass(base=yc_ignore_damp_huawei_ifm__ifm_interfaces_interface_ignore_damp, is_container='container', yang_name="ignore-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__damp = YANGDynClass(base=yc_damp_huawei_ifm__ifm_interfaces_interface_damp, is_container='container', yang_name="damp", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__damp_state = YANGDynClass(base=yc_damp_state_huawei_ifm__ifm_interfaces_interface_damp_state, is_container='container', yang_name="damp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__dynamic = YANGDynClass(base=yc_dynamic_huawei_ifm__ifm_interfaces_interface_dynamic, is_container='container', yang_name="dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__mib_statistics = YANGDynClass(base=yc_mib_statistics_huawei_ifm__ifm_interfaces_interface_mib_statistics, is_container='container', yang_name="mib-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__common_statistics = YANGDynClass(base=yc_common_statistics_huawei_ifm__ifm_interfaces_interface_common_statistics, is_container='container', yang_name="common-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__error_down = YANGDynClass(base=yc_error_down_huawei_ifm__ifm_interfaces_interface_error_down, is_container='container', yang_name="error-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__tunnel_protocol = YANGDynClass(base=yc_tunnel_protocol_huawei_ifm__ifm_interfaces_interface_tunnel_protocol, is_container='container', yang_name="tunnel-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-tunnel-management', defining_module='huawei-tunnel-management', yang_type='container', is_config=True)
    self.__ipv4 = YANGDynClass(base=yc_ipv4_huawei_ifm__ifm_interfaces_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    self.__ipv6 = YANGDynClass(base=yc_ipv6_huawei_ifm__ifm_interfaces_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces', 'interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ifm/interfaces/interface/name (pub-type:if-name)

    YANG Description: The textual name of the interface. It should be the name of the interface as assigned by the local device. It should be suitable for use in commands which entered at the device's 'console'. This might be a text name, such as 'NULL0', depending on the interface naming syntax of the device.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ifm/interfaces/interface/name (pub-type:if-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The textual name of the interface. It should be the name of the interface as assigned by the local device. It should be suitable for use in commands which entered at the device's 'console'. This might be a text name, such as 'NULL0', depending on the interface naming syntax of the device.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with pub-type:if-name""",
          'defined-type': "pub-type:if-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=True)


  def _get_class_(self):
    """
    Getter method for class_, mapped from YANG variable /ifm/interfaces/interface/class (class-type)

    YANG Description: Identify a main interface or a sub-interface.
    """
    return self.__class_
      
  def _set_class_(self, v, load=False):
    """
    Setter method for class_, mapped from YANG variable /ifm/interfaces/interface/class (class-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_class_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_class_() directly.

    YANG Description: Identify a main interface or a sub-interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main-interface': {'value': 0}, 'sub-interface': {'value': 1}},), is_leaf=True, yang_name="class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='class-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """class_ must be of a type compatible with class-type""",
          'defined-type': "huawei-ifm:class-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main-interface': {'value': 0}, 'sub-interface': {'value': 1}},), is_leaf=True, yang_name="class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='class-type', is_config=True)""",
        })

    self.__class_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_class_(self):
    self.__class_ = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'main-interface': {'value': 0}, 'sub-interface': {'value': 1}},), is_leaf=True, yang_name="class", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='class-type', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /ifm/interfaces/interface/type (port-type)

    YANG Description: Type of an interface. Interfaces include physical and logical interfaces.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /ifm/interfaces/interface/type (port-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of an interface. Interfaces include physical and logical interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with port-type""",
          'defined-type': "huawei-ifm:port-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=True)


  def _get_parent_name(self):
    """
    Getter method for parent_name, mapped from YANG variable /ifm/interfaces/interface/parent_name (leafref)

    YANG Description: Name of the main interface. For example, Ethernet0/1/0.
    """
    return self.__parent_name
      
  def _set_parent_name(self, v, load=False):
    """
    Setter method for parent_name, mapped from YANG variable /ifm/interfaces/interface/parent_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parent_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parent_name() directly.

    YANG Description: Name of the main interface. For example, Ethernet0/1/0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="parent-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parent_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parent-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)""",
        })

    self.__parent_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parent_name(self):
    self.__parent_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parent-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)


  def _get_number(self):
    """
    Getter method for number, mapped from YANG variable /ifm/interfaces/interface/number (string)

    YANG Description: Number of an interface. For example,1, 0/1/0, or 2:1.
    """
    return self.__number
      
  def _set_number(self, v, load=False):
    """
    Setter method for number, mapped from YANG variable /ifm/interfaces/interface/number (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number() directly.

    YANG Description: Number of an interface. For example,1, 0/1/0, or 2:1.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(\\d+/\\d+/\\d+/\\d+)|(\\d+/\\d+/\\d+)|(\\d+/\\d+)|(\\d+)|(\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+[:]\\d+)', 'length': ['1..63']}), is_leaf=True, yang_name="number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """number must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(\\d+/\\d+/\\d+/\\d+)|(\\d+/\\d+/\\d+)|(\\d+/\\d+)|(\\d+)|(\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+[:]\\d+)', 'length': ['1..63']}), is_leaf=True, yang_name="number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)""",
        })

    self.__number = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_number(self):
    self.__number = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(\\d+/\\d+/\\d+/\\d+)|(\\d+/\\d+/\\d+)|(\\d+/\\d+)|(\\d+)|(\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+[:]\\d+[:]\\d+[:]\\d+)|(\\d+/\\d+/\\d+/\\d+/\\d+[:]\\d+)|(\\d+/\\d+[:]\\d+)', 'length': ['1..63']}), is_leaf=True, yang_name="number", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /ifm/interfaces/interface/description (string)

    YANG Description: Description of an interface.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /ifm/interfaces/interface/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=True)


  def _get_admin_status(self):
    """
    Getter method for admin_status, mapped from YANG variable /ifm/interfaces/interface/admin_status (port-status)

    YANG Description: Administrative status of an interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__admin_status
      
  def _set_admin_status(self, v, load=False):
    """
    Setter method for admin_status, mapped from YANG variable /ifm/interfaces/interface/admin_status (port-status)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_admin_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_admin_status() directly.

    YANG Description: Administrative status of an interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """admin_status must be of a type compatible with port-status""",
          'defined-type': "huawei-ifm:port-status",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=True)""",
        })

    self.__admin_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_admin_status(self):
    self.__admin_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'down': {'value': 0}, 'up': {'value': 1}},), is_leaf=True, yang_name="admin-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-status', is_config=True)


  def _get_link_protocol(self):
    """
    Getter method for link_protocol, mapped from YANG variable /ifm/interfaces/interface/link_protocol (link-protocol)

    YANG Description: Link protocol. Capabilities supported by this node vary according to interface types.
    """
    return self.__link_protocol
      
  def _set_link_protocol(self, v, load=False):
    """
    Setter method for link_protocol, mapped from YANG variable /ifm/interfaces/interface/link_protocol (link-protocol)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_protocol() directly.

    YANG Description: Link protocol. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ethernet': {'value': 0}, 'ppp': {'value': 1}, 'hdlc': {'value': 2}, 'fr': {'value': 3}, 'atm': {'value': 6}, 'tdm': {'value': 7}},), is_leaf=True, yang_name="link-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-protocol', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_protocol must be of a type compatible with link-protocol""",
          'defined-type': "huawei-ifm:link-protocol",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ethernet': {'value': 0}, 'ppp': {'value': 1}, 'hdlc': {'value': 2}, 'fr': {'value': 3}, 'atm': {'value': 6}, 'tdm': {'value': 7}},), is_leaf=True, yang_name="link-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-protocol', is_config=True)""",
        })

    self.__link_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_protocol(self):
    self.__link_protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ethernet': {'value': 0}, 'ppp': {'value': 1}, 'hdlc': {'value': 2}, 'fr': {'value': 3}, 'atm': {'value': 6}, 'tdm': {'value': 7}},), is_leaf=True, yang_name="link-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='link-protocol', is_config=True)


  def _get_router_type(self):
    """
    Getter method for router_type, mapped from YANG variable /ifm/interfaces/interface/router_type (router-type)

    YANG Description: Route attribute of an interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__router_type
      
  def _set_router_type(self, v, load=False):
    """
    Setter method for router_type, mapped from YANG variable /ifm/interfaces/interface/router_type (router-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_type() directly.

    YANG Description: Route attribute of an interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PtoP': {'value': 0}, 'PtoMP': {'value': 1}, 'broadcast': {'value': 2}, 'NBMA': {'value': 3}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="router-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='router-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_type must be of a type compatible with router-type""",
          'defined-type': "huawei-ifm:router-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PtoP': {'value': 0}, 'PtoMP': {'value': 1}, 'broadcast': {'value': 2}, 'NBMA': {'value': 3}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="router-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='router-type', is_config=True)""",
        })

    self.__router_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_type(self):
    self.__router_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PtoP': {'value': 0}, 'PtoMP': {'value': 1}, 'broadcast': {'value': 2}, 'NBMA': {'value': 3}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="router-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='router-type', is_config=True)


  def _get_clear_ip_df(self):
    """
    Getter method for clear_ip_df, mapped from YANG variable /ifm/interfaces/interface/clear_ip_df (boolean)

    YANG Description: Enable/disable a device to forcibly fragment IP packets on an outbound interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__clear_ip_df
      
  def _set_clear_ip_df(self, v, load=False):
    """
    Setter method for clear_ip_df, mapped from YANG variable /ifm/interfaces/interface/clear_ip_df (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clear_ip_df is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clear_ip_df() directly.

    YANG Description: Enable/disable a device to forcibly fragment IP packets on an outbound interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="clear-ip-df", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clear_ip_df must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="clear-ip-df", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__clear_ip_df = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clear_ip_df(self):
    self.__clear_ip_df = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="clear-ip-df", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_link_up_down_trap_enable(self):
    """
    Getter method for link_up_down_trap_enable, mapped from YANG variable /ifm/interfaces/interface/link_up_down_trap_enable (boolean)

    YANG Description: Enable/disable the trap function on an interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__link_up_down_trap_enable
      
  def _set_link_up_down_trap_enable(self, v, load=False):
    """
    Setter method for link_up_down_trap_enable, mapped from YANG variable /ifm/interfaces/interface/link_up_down_trap_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_up_down_trap_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_up_down_trap_enable() directly.

    YANG Description: Enable/disable the trap function on an interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_up_down_trap_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__link_up_down_trap_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_up_down_trap_enable(self):
    self.__link_up_down_trap_enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="link-up-down-trap-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_statistic_enable(self):
    """
    Getter method for statistic_enable, mapped from YANG variable /ifm/interfaces/interface/statistic_enable (boolean)

    YANG Description: Enable/disable the statistics function on an interface. The default value of this node varies according to different interface types. Capabilities supported by this node vary according to interface types.
    """
    return self.__statistic_enable
      
  def _set_statistic_enable(self, v, load=False):
    """
    Setter method for statistic_enable, mapped from YANG variable /ifm/interfaces/interface/statistic_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistic_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistic_enable() directly.

    YANG Description: Enable/disable the statistics function on an interface. The default value of this node varies according to different interface types. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistic_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__statistic_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistic_enable(self):
    self.__statistic_enable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_statistic_mode(self):
    """
    Getter method for statistic_mode, mapped from YANG variable /ifm/interfaces/interface/statistic_mode (statistic-mode)

    YANG Description: Mode of statistics collection. Capabilities supported by this node vary according to interface types.
    """
    return self.__statistic_mode
      
  def _set_statistic_mode(self, v, load=False):
    """
    Setter method for statistic_mode, mapped from YANG variable /ifm/interfaces/interface/statistic_mode (statistic-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistic_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistic_mode() directly.

    YANG Description: Mode of statistics collection. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'interface-based': {'value': 1}, 'vlan-group-based': {'value': 2}},), default=six.text_type("interface-based"), is_leaf=True, yang_name="statistic-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='statistic-mode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistic_mode must be of a type compatible with statistic-mode""",
          'defined-type': "huawei-ifm:statistic-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'interface-based': {'value': 1}, 'vlan-group-based': {'value': 2}},), default=six.text_type("interface-based"), is_leaf=True, yang_name="statistic-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='statistic-mode', is_config=True)""",
        })

    self.__statistic_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistic_mode(self):
    self.__statistic_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'interface-based': {'value': 1}, 'vlan-group-based': {'value': 2}},), default=six.text_type("interface-based"), is_leaf=True, yang_name="statistic-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='statistic-mode', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /ifm/interfaces/interface/bandwidth (uint32)

    YANG Description: Configure the bandwidth of an interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /ifm/interfaces/interface/bandwidth (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: Configure the bandwidth of an interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth", parent=self, choice=('bandwidth-type', 'bandwidth-mbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth", parent=self, choice=('bandwidth-type', 'bandwidth-mbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth", parent=self, choice=('bandwidth-type', 'bandwidth-mbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_bandwidth_kbps(self):
    """
    Getter method for bandwidth_kbps, mapped from YANG variable /ifm/interfaces/interface/bandwidth_kbps (uint32)

    YANG Description: Configure the bandwidth of an interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__bandwidth_kbps
      
  def _set_bandwidth_kbps(self, v, load=False):
    """
    Setter method for bandwidth_kbps, mapped from YANG variable /ifm/interfaces/interface/bandwidth_kbps (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth_kbps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth_kbps() directly.

    YANG Description: Configure the bandwidth of an interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth-kbps", parent=self, choice=('bandwidth-type', 'bandwidth-kbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth_kbps must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth-kbps", parent=self, choice=('bandwidth-type', 'bandwidth-kbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__bandwidth_kbps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth_kbps(self):
    self.__bandwidth_kbps = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..1000000']}), is_leaf=True, yang_name="bandwidth-kbps", parent=self, choice=('bandwidth-type', 'bandwidth-kbps'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_mtu(self):
    """
    Getter method for mtu, mapped from YANG variable /ifm/interfaces/interface/mtu (uint32)

    YANG Description: Maximum transmission unit of an interface.
Special explanation:
Range: The server may restrict the allowed values for this leaf, depending on the interface types.
Capabilities supported by this node vary according to interface types.
    """
    return self.__mtu
      
  def _set_mtu(self, v, load=False):
    """
    Setter method for mtu, mapped from YANG variable /ifm/interfaces/interface/mtu (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: Maximum transmission unit of an interface.
Special explanation:
Range: The server may restrict the allowed values for this leaf, depending on the interface types.
Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..64000']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mtu must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..64000']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__mtu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mtu(self):
    self.__mtu = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..64000']}), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_spread_mtu_flag(self):
    """
    Getter method for spread_mtu_flag, mapped from YANG variable /ifm/interfaces/interface/spread_mtu_flag (boolean)

    YANG Description: Enable/disable the function of spreading the MTU value of main interface to subinterface. Capabilities supported by this node vary according to interface types.
    """
    return self.__spread_mtu_flag
      
  def _set_spread_mtu_flag(self, v, load=False):
    """
    Setter method for spread_mtu_flag, mapped from YANG variable /ifm/interfaces/interface/spread_mtu_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spread_mtu_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spread_mtu_flag() directly.

    YANG Description: Enable/disable the function of spreading the MTU value of main interface to subinterface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spread_mtu_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__spread_mtu_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spread_mtu_flag(self):
    self.__spread_mtu_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="spread-mtu-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_statistic_interval(self):
    """
    Getter method for statistic_interval, mapped from YANG variable /ifm/interfaces/interface/statistic_interval (uint32)

    YANG Description: Interval at which flow statistics are collected on an interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__statistic_interval
      
  def _set_statistic_interval(self, v, load=False):
    """
    Setter method for statistic_interval, mapped from YANG variable /ifm/interfaces/interface/statistic_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistic_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistic_interval() directly.

    YANG Description: Interval at which flow statistics are collected on an interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """statistic_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__statistic_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_statistic_interval(self):
    self.__statistic_interval = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['10..600']}), is_leaf=True, yang_name="statistic-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_vrf_name(self):
    """
    Getter method for vrf_name, mapped from YANG variable /ifm/interfaces/interface/vrf_name (leafref)

    YANG Description: Name of a VPN instance. It uniquely identifies a VPN instance. The VRF name of the DCN interface cannot be created, modified, or deleted.
    """
    return self.__vrf_name
      
  def _set_vrf_name(self, v, load=False):
    """
    Setter method for vrf_name, mapped from YANG variable /ifm/interfaces/interface/vrf_name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_name() directly.

    YANG Description: Name of a VPN instance. It uniquely identifies a VPN instance. The VRF name of the DCN interface cannot be created, modified, or deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)""",
        })

    self.__vrf_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_name(self):
    self.__vrf_name = YANGDynClass(base=six.text_type, default=six.text_type("_public_"), is_leaf=True, yang_name="vrf-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='leafref', is_config=True)


  def _get_l2_mode_enable(self):
    """
    Getter method for l2_mode_enable, mapped from YANG variable /ifm/interfaces/interface/l2_mode_enable (boolean)

    YANG Description: Enable/disable the function of creating an L2 Sub-interface. Capabilities supported by this node vary according to interface types.
    """
    return self.__l2_mode_enable
      
  def _set_l2_mode_enable(self, v, load=False):
    """
    Setter method for l2_mode_enable, mapped from YANG variable /ifm/interfaces/interface/l2_mode_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_mode_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_mode_enable() directly.

    YANG Description: Enable/disable the function of creating an L2 Sub-interface. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2-mode-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2_mode_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2-mode-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)""",
        })

    self.__l2_mode_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2_mode_enable(self):
    self.__l2_mode_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="l2-mode-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=True)


  def _get_down_delay_time(self):
    """
    Getter method for down_delay_time, mapped from YANG variable /ifm/interfaces/interface/down_delay_time (uint32)

    YANG Description: Specify down-delay-time value in milliseconds.
    """
    return self.__down_delay_time
      
  def _set_down_delay_time(self, v, load=False):
    """
    Setter method for down_delay_time, mapped from YANG variable /ifm/interfaces/interface/down_delay_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_down_delay_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_down_delay_time() directly.

    YANG Description: Specify down-delay-time value in milliseconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """down_delay_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__down_delay_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_down_delay_time(self):
    self.__down_delay_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..1000']}), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="down-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /ifm/interfaces/interface/mac_address (pub-type:mac-address)

    YANG Description: Config MAC Address. Constraints on MAC address configuration varies according to interfaces. Capabilities supported by this node vary according to interface types.
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /ifm/interfaces/interface/mac_address (pub-type:mac-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: Config MAC Address. Constraints on MAC address configuration varies according to interfaces. Capabilities supported by this node vary according to interface types.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with pub-type:mac-address""",
          'defined-type': "pub-type:mac-address",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=True)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[0-9a-f]{4}(-[0-9a-f]{4}){2}', 'length': ['0..255']}), restriction_dict={'length': ['0..255']}), is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:mac-address', is_config=True)


  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /ifm/interfaces/interface/index (uint32)

    YANG Description: Index of an interface.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /ifm/interfaces/interface/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_position(self):
    """
    Getter method for position, mapped from YANG variable /ifm/interfaces/interface/position (string)

    YANG Description: Position of an interface. For example, 0/1/0. Data can be queried only on physical interfaces.
    """
    return self.__position
      
  def _set_position(self, v, load=False):
    """
    Setter method for position, mapped from YANG variable /ifm/interfaces/interface/position (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_position is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_position() directly.

    YANG Description: Position of an interface. For example, 0/1/0. Data can be queried only on physical interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """position must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__position = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_position(self):
    self.__position = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..256']}), is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_aggregation_name(self):
    """
    Getter method for aggregation_name, mapped from YANG variable /ifm/interfaces/interface/aggregation_name (pub-type:if-name)

    YANG Description: Name of an aggregation interface.
    """
    return self.__aggregation_name
      
  def _set_aggregation_name(self, v, load=False):
    """
    Setter method for aggregation_name, mapped from YANG variable /ifm/interfaces/interface/aggregation_name (pub-type:if-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aggregation_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aggregation_name() directly.

    YANG Description: Name of an aggregation interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="aggregation-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aggregation_name must be of a type compatible with pub-type:if-name""",
          'defined-type': "pub-type:if-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="aggregation-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)""",
        })

    self.__aggregation_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aggregation_name(self):
    self.__aggregation_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="aggregation-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)


  def _get_is_l2_switch(self):
    """
    Getter method for is_l2_switch, mapped from YANG variable /ifm/interfaces/interface/is_l2_switch (boolean)

    YANG Description: To identify a layer2 switch port.
    """
    return self.__is_l2_switch
      
  def _set_is_l2_switch(self, v, load=False):
    """
    Setter method for is_l2_switch, mapped from YANG variable /ifm/interfaces/interface/is_l2_switch (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_l2_switch is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_l2_switch() directly.

    YANG Description: To identify a layer2 switch port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="is-l2-switch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """is_l2_switch must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="is-l2-switch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)""",
        })

    self.__is_l2_switch = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_is_l2_switch(self):
    self.__is_l2_switch = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="is-l2-switch", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='boolean', is_config=False)


  def _get_vs_name(self):
    """
    Getter method for vs_name, mapped from YANG variable /ifm/interfaces/interface/vs_name (string)

    YANG Description: Name of a VS to which an interface belongs.
    """
    return self.__vs_name
      
  def _set_vs_name(self, v, load=False):
    """
    Setter method for vs_name, mapped from YANG variable /ifm/interfaces/interface/vs_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vs_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vs_name() directly.

    YANG Description: Name of a VS to which an interface belongs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="vs-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vs_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="vs-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__vs_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vs_name(self):
    self.__vs_name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="vs-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_l2_switch_port_index(self):
    """
    Getter method for l2_switch_port_index, mapped from YANG variable /ifm/interfaces/interface/l2_switch_port_index (uint32)

    YANG Description: L2 switch port index of an interface.
    """
    return self.__l2_switch_port_index
      
  def _set_l2_switch_port_index(self, v, load=False):
    """
    Setter method for l2_switch_port_index, mapped from YANG variable /ifm/interfaces/interface/l2_switch_port_index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_switch_port_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_switch_port_index() directly.

    YANG Description: L2 switch port index of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="l2-switch-port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """l2_switch_port_index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="l2-switch-port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__l2_switch_port_index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_l2_switch_port_index(self):
    self.__l2_switch_port_index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="l2-switch-port-index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_service_type(self):
    """
    Getter method for service_type, mapped from YANG variable /ifm/interfaces/interface/service_type (service-type)

    YANG Description: Type of a member interface.
    """
    return self.__service_type
      
  def _set_service_type(self, v, load=False):
    """
    Setter method for service_type, mapped from YANG variable /ifm/interfaces/interface/service_type (service-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_type() directly.

    YANG Description: Type of a member interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'trunk-member': {'value': 2}, 'stack-member': {'value': 6}, 'mp-member': {'value': 7}, 'vbridge-member': {'value': 8}, 'ima-member': {'value': 9}, 'bundle-member': {'value': 10}, 'fabric-member': {'value': 11}, 'lag-master-member': {'value': 12}, 'lag-slave-member': {'value': 13}, 'cpos-trunk-member': {'value': 15}, 'pos-trunk-member': {'value': 16}, 'global-mp-member': {'value': 17}, 'global-ima-member': {'value': 18}},), is_leaf=True, yang_name="service-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='service-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """service_type must be of a type compatible with service-type""",
          'defined-type': "huawei-ifm:service-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'trunk-member': {'value': 2}, 'stack-member': {'value': 6}, 'mp-member': {'value': 7}, 'vbridge-member': {'value': 8}, 'ima-member': {'value': 9}, 'bundle-member': {'value': 10}, 'fabric-member': {'value': 11}, 'lag-master-member': {'value': 12}, 'lag-slave-member': {'value': 13}, 'cpos-trunk-member': {'value': 15}, 'pos-trunk-member': {'value': 16}, 'global-mp-member': {'value': 17}, 'global-ima-member': {'value': 18}},), is_leaf=True, yang_name="service-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='service-type', is_config=False)""",
        })

    self.__service_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_service_type(self):
    self.__service_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {'value': 0}, 'trunk-member': {'value': 2}, 'stack-member': {'value': 6}, 'mp-member': {'value': 7}, 'vbridge-member': {'value': 8}, 'ima-member': {'value': 9}, 'bundle-member': {'value': 10}, 'fabric-member': {'value': 11}, 'lag-master-member': {'value': 12}, 'lag-slave-member': {'value': 13}, 'cpos-trunk-member': {'value': 15}, 'pos-trunk-member': {'value': 16}, 'global-mp-member': {'value': 17}, 'global-ima-member': {'value': 18}},), is_leaf=True, yang_name="service-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='service-type', is_config=False)


  def _get_encapsulation_type(self):
    """
    Getter method for encapsulation_type, mapped from YANG variable /ifm/interfaces/interface/encapsulation_type (encapsulation-type)

    YANG Description: Effective encapsulation type.
    """
    return self.__encapsulation_type
      
  def _set_encapsulation_type(self, v, load=False):
    """
    Setter method for encapsulation_type, mapped from YANG variable /ifm/interfaces/interface/encapsulation_type (encapsulation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulation_type() directly.

    YANG Description: Effective encapsulation type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'vlan-type': {'value': 0}, 'dot1q': {'value': 1}, 'qinq': {'value': 2}, 'p2p': {'value': 3}, 'p2mp': {'value': 4}, 'l2ve': {'value': 5}, 'l3ve': {'value': 6}, 'vlan-type-policy': {'value': 7}, 'dot1q-policy': {'value': 8}, 'stacking-policy': {'value': 9}, 'untag-policy': {'value': 10}, 'qinq-mapping': {'value': 11}, 'l2vc': {'value': 12}, 'l3vc': {'value': 13}, 'evc-untag': {'value': 14}, 'evc-dot1q': {'value': 15}, 'evc-qinq': {'value': 16}, 'evc-default': {'value': 17}, 'evc-dot1q-policy': {'value': 18}, 'ietf': {'value': 19}, 'nonstandard': {'value': 20}, 'user-vlan': {'value': 21}, 'user-vlan-anyother': {'value': 22}, 'qin-link': {'value': 23}, 'soft-gre-ve': {'value': 24}, 'l3ve-ter': {'value': 25}, 'l3ve-acc': {'value': 26}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='encapsulation-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulation_type must be of a type compatible with encapsulation-type""",
          'defined-type': "huawei-ifm:encapsulation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'vlan-type': {'value': 0}, 'dot1q': {'value': 1}, 'qinq': {'value': 2}, 'p2p': {'value': 3}, 'p2mp': {'value': 4}, 'l2ve': {'value': 5}, 'l3ve': {'value': 6}, 'vlan-type-policy': {'value': 7}, 'dot1q-policy': {'value': 8}, 'stacking-policy': {'value': 9}, 'untag-policy': {'value': 10}, 'qinq-mapping': {'value': 11}, 'l2vc': {'value': 12}, 'l3vc': {'value': 13}, 'evc-untag': {'value': 14}, 'evc-dot1q': {'value': 15}, 'evc-qinq': {'value': 16}, 'evc-default': {'value': 17}, 'evc-dot1q-policy': {'value': 18}, 'ietf': {'value': 19}, 'nonstandard': {'value': 20}, 'user-vlan': {'value': 21}, 'user-vlan-anyother': {'value': 22}, 'qin-link': {'value': 23}, 'soft-gre-ve': {'value': 24}, 'l3ve-ter': {'value': 25}, 'l3ve-acc': {'value': 26}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='encapsulation-type', is_config=False)""",
        })

    self.__encapsulation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulation_type(self):
    self.__encapsulation_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'vlan-type': {'value': 0}, 'dot1q': {'value': 1}, 'qinq': {'value': 2}, 'p2p': {'value': 3}, 'p2mp': {'value': 4}, 'l2ve': {'value': 5}, 'l3ve': {'value': 6}, 'vlan-type-policy': {'value': 7}, 'dot1q-policy': {'value': 8}, 'stacking-policy': {'value': 9}, 'untag-policy': {'value': 10}, 'qinq-mapping': {'value': 11}, 'l2vc': {'value': 12}, 'l3vc': {'value': 13}, 'evc-untag': {'value': 14}, 'evc-dot1q': {'value': 15}, 'evc-qinq': {'value': 16}, 'evc-default': {'value': 17}, 'evc-dot1q-policy': {'value': 18}, 'ietf': {'value': 19}, 'nonstandard': {'value': 20}, 'user-vlan': {'value': 21}, 'user-vlan-anyother': {'value': 22}, 'qin-link': {'value': 23}, 'soft-gre-ve': {'value': 24}, 'l3ve-ter': {'value': 25}, 'l3ve-acc': {'value': 26}, 'invalid': {'value': 255}},), is_leaf=True, yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='encapsulation-type', is_config=False)


  def _get_network_layer_status(self):
    """
    Getter method for network_layer_status, mapped from YANG variable /ifm/interfaces/interface/network_layer_status (network-layer-state)

    YANG Description: Network-layer status of an interface.
    """
    return self.__network_layer_status
      
  def _set_network_layer_status(self, v, load=False):
    """
    Setter method for network_layer_status, mapped from YANG variable /ifm/interfaces/interface/network_layer_status (network-layer-state)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_layer_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_layer_status() directly.

    YANG Description: Network-layer status of an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-ipv6-up': {'value': 0}, 'ipv4-ipv6-down': {'value': 196608}},), default=six.text_type("ipv4-ipv6-up"), is_leaf=True, yang_name="network-layer-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='network-layer-state', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_layer_status must be of a type compatible with network-layer-state""",
          'defined-type': "huawei-ifm:network-layer-state",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-ipv6-up': {'value': 0}, 'ipv4-ipv6-down': {'value': 196608}},), default=six.text_type("ipv4-ipv6-up"), is_leaf=True, yang_name="network-layer-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='network-layer-state', is_config=True)""",
        })

    self.__network_layer_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_layer_status(self):
    self.__network_layer_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-ipv6-up': {'value': 0}, 'ipv4-ipv6-down': {'value': 196608}},), default=six.text_type("ipv4-ipv6-up"), is_leaf=True, yang_name="network-layer-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='network-layer-state', is_config=True)


  def _get_protocol_up_delay_time(self):
    """
    Getter method for protocol_up_delay_time, mapped from YANG variable /ifm/interfaces/interface/protocol_up_delay_time (uint32)

    YANG Description: Specify the protocol up-delay-time value in seconds.
    """
    return self.__protocol_up_delay_time
      
  def _set_protocol_up_delay_time(self, v, load=False):
    """
    Setter method for protocol_up_delay_time, mapped from YANG variable /ifm/interfaces/interface/protocol_up_delay_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_up_delay_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_up_delay_time() directly.

    YANG Description: Specify the protocol up-delay-time value in seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..7200']}), is_leaf=True, yang_name="protocol-up-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_up_delay_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..7200']}), is_leaf=True, yang_name="protocol-up-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)""",
        })

    self.__protocol_up_delay_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_up_delay_time(self):
    self.__protocol_up_delay_time = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..7200']}), is_leaf=True, yang_name="protocol-up-delay-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=True)


  def _get_control_flap(self):
    """
    Getter method for control_flap, mapped from YANG variable /ifm/interfaces/interface/control_flap (container)

    YANG Description: Enable/disable flapping control on an interface.
    """
    return self.__control_flap
      
  def _set_control_flap(self, v, load=False):
    """
    Setter method for control_flap, mapped from YANG variable /ifm/interfaces/interface/control_flap (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_flap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_flap() directly.

    YANG Description: Enable/disable flapping control on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_control_flap_huawei_ifm__ifm_interfaces_interface_control_flap, is_container='container', yang_name="control-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_flap must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_control_flap_huawei_ifm__ifm_interfaces_interface_control_flap, is_container='container', yang_name="control-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__control_flap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_flap(self):
    self.__control_flap = YANGDynClass(base=yc_control_flap_huawei_ifm__ifm_interfaces_interface_control_flap, is_container='container', yang_name="control-flap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_trap_threshold(self):
    """
    Getter method for trap_threshold, mapped from YANG variable /ifm/interfaces/interface/trap_threshold (container)

    YANG Description: Configure the trap threshold.
    """
    return self.__trap_threshold
      
  def _set_trap_threshold(self, v, load=False):
    """
    Setter method for trap_threshold, mapped from YANG variable /ifm/interfaces/interface/trap_threshold (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trap_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trap_threshold() directly.

    YANG Description: Configure the trap threshold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_trap_threshold_huawei_ifm__ifm_interfaces_interface_trap_threshold, is_container='container', yang_name="trap-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trap_threshold must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_trap_threshold_huawei_ifm__ifm_interfaces_interface_trap_threshold, is_container='container', yang_name="trap-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__trap_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trap_threshold(self):
    self.__trap_threshold = YANGDynClass(base=yc_trap_threshold_huawei_ifm__ifm_interfaces_interface_trap_threshold, is_container='container', yang_name="trap-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_ignore_damp(self):
    """
    Getter method for ignore_damp, mapped from YANG variable /ifm/interfaces/interface/ignore_damp (container)

    YANG Description: Configure an interface to ignore the global damp-interface function.
    """
    return self.__ignore_damp
      
  def _set_ignore_damp(self, v, load=False):
    """
    Setter method for ignore_damp, mapped from YANG variable /ifm/interfaces/interface/ignore_damp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ignore_damp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ignore_damp() directly.

    YANG Description: Configure an interface to ignore the global damp-interface function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ignore_damp_huawei_ifm__ifm_interfaces_interface_ignore_damp, is_container='container', yang_name="ignore-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ignore_damp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ignore_damp_huawei_ifm__ifm_interfaces_interface_ignore_damp, is_container='container', yang_name="ignore-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__ignore_damp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ignore_damp(self):
    self.__ignore_damp = YANGDynClass(base=yc_ignore_damp_huawei_ifm__ifm_interfaces_interface_ignore_damp, is_container='container', yang_name="ignore-damp", parent=self, choice=('damping', 'ignore-damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_damp(self):
    """
    Getter method for damp, mapped from YANG variable /ifm/interfaces/interface/damp (container)

    YANG Description: Enable/disable suppression on an interface's physical status flappings.
    """
    return self.__damp
      
  def _set_damp(self, v, load=False):
    """
    Setter method for damp, mapped from YANG variable /ifm/interfaces/interface/damp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_damp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_damp() directly.

    YANG Description: Enable/disable suppression on an interface's physical status flappings.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_damp_huawei_ifm__ifm_interfaces_interface_damp, is_container='container', yang_name="damp", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """damp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_damp_huawei_ifm__ifm_interfaces_interface_damp, is_container='container', yang_name="damp", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__damp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_damp(self):
    self.__damp = YANGDynClass(base=yc_damp_huawei_ifm__ifm_interfaces_interface_damp, is_container='container', yang_name="damp", parent=self, choice=('damping', 'damp'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_damp_state(self):
    """
    Getter method for damp_state, mapped from YANG variable /ifm/interfaces/interface/damp_state (container)

    YANG Description: Operational state of interface suppression information.
    """
    return self.__damp_state
      
  def _set_damp_state(self, v, load=False):
    """
    Setter method for damp_state, mapped from YANG variable /ifm/interfaces/interface/damp_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_damp_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_damp_state() directly.

    YANG Description: Operational state of interface suppression information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_damp_state_huawei_ifm__ifm_interfaces_interface_damp_state, is_container='container', yang_name="damp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """damp_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_damp_state_huawei_ifm__ifm_interfaces_interface_damp_state, is_container='container', yang_name="damp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__damp_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_damp_state(self):
    self.__damp_state = YANGDynClass(base=yc_damp_state_huawei_ifm__ifm_interfaces_interface_damp_state, is_container='container', yang_name="damp-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_dynamic(self):
    """
    Getter method for dynamic, mapped from YANG variable /ifm/interfaces/interface/dynamic (container)

    YANG Description: Operational state of interfaces.
    """
    return self.__dynamic
      
  def _set_dynamic(self, v, load=False):
    """
    Setter method for dynamic, mapped from YANG variable /ifm/interfaces/interface/dynamic (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dynamic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dynamic() directly.

    YANG Description: Operational state of interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_dynamic_huawei_ifm__ifm_interfaces_interface_dynamic, is_container='container', yang_name="dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dynamic must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_dynamic_huawei_ifm__ifm_interfaces_interface_dynamic, is_container='container', yang_name="dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__dynamic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dynamic(self):
    self.__dynamic = YANGDynClass(base=yc_dynamic_huawei_ifm__ifm_interfaces_interface_dynamic, is_container='container', yang_name="dynamic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_mib_statistics(self):
    """
    Getter method for mib_statistics, mapped from YANG variable /ifm/interfaces/interface/mib_statistics (container)

    YANG Description: Interface statistics.
    """
    return self.__mib_statistics
      
  def _set_mib_statistics(self, v, load=False):
    """
    Setter method for mib_statistics, mapped from YANG variable /ifm/interfaces/interface/mib_statistics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mib_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mib_statistics() directly.

    YANG Description: Interface statistics.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_mib_statistics_huawei_ifm__ifm_interfaces_interface_mib_statistics, is_container='container', yang_name="mib-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mib_statistics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_mib_statistics_huawei_ifm__ifm_interfaces_interface_mib_statistics, is_container='container', yang_name="mib-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__mib_statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mib_statistics(self):
    self.__mib_statistics = YANGDynClass(base=yc_mib_statistics_huawei_ifm__ifm_interfaces_interface_mib_statistics, is_container='container', yang_name="mib-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_common_statistics(self):
    """
    Getter method for common_statistics, mapped from YANG variable /ifm/interfaces/interface/common_statistics (container)

    YANG Description: Interface statistics.
    """
    return self.__common_statistics
      
  def _set_common_statistics(self, v, load=False):
    """
    Setter method for common_statistics, mapped from YANG variable /ifm/interfaces/interface/common_statistics (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_common_statistics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_common_statistics() directly.

    YANG Description: Interface statistics.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_common_statistics_huawei_ifm__ifm_interfaces_interface_common_statistics, is_container='container', yang_name="common-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """common_statistics must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_common_statistics_huawei_ifm__ifm_interfaces_interface_common_statistics, is_container='container', yang_name="common-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__common_statistics = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_common_statistics(self):
    self.__common_statistics = YANGDynClass(base=yc_common_statistics_huawei_ifm__ifm_interfaces_interface_common_statistics, is_container='container', yang_name="common-statistics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_error_down(self):
    """
    Getter method for error_down, mapped from YANG variable /ifm/interfaces/interface/error_down (container)

    YANG Description: Information about the interface in the error-down state, including the interface name, cause of the error-down event, delay for the transition from down to up, and remaining time for the up state.
    """
    return self.__error_down
      
  def _set_error_down(self, v, load=False):
    """
    Setter method for error_down, mapped from YANG variable /ifm/interfaces/interface/error_down (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_error_down is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_error_down() directly.

    YANG Description: Information about the interface in the error-down state, including the interface name, cause of the error-down event, delay for the transition from down to up, and remaining time for the up state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_error_down_huawei_ifm__ifm_interfaces_interface_error_down, is_container='container', yang_name="error-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """error_down must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_error_down_huawei_ifm__ifm_interfaces_interface_error_down, is_container='container', yang_name="error-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__error_down = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_error_down(self):
    self.__error_down = YANGDynClass(base=yc_error_down_huawei_ifm__ifm_interfaces_interface_error_down, is_container='container', yang_name="error-down", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_tunnel_protocol(self):
    """
    Getter method for tunnel_protocol, mapped from YANG variable /ifm/interfaces/interface/tunnel_protocol (container)

    YANG Description: Configure tunnel protocol.
Special explanation:
Constraint: If a tunnel is locked, all configurations of the tunnel cannot be deleted or modified.
    """
    return self.__tunnel_protocol
      
  def _set_tunnel_protocol(self, v, load=False):
    """
    Setter method for tunnel_protocol, mapped from YANG variable /ifm/interfaces/interface/tunnel_protocol (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_protocol() directly.

    YANG Description: Configure tunnel protocol.
Special explanation:
Constraint: If a tunnel is locked, all configurations of the tunnel cannot be deleted or modified.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tunnel_protocol_huawei_ifm__ifm_interfaces_interface_tunnel_protocol, is_container='container', yang_name="tunnel-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-tunnel-management', defining_module='huawei-tunnel-management', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_protocol must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tunnel_protocol_huawei_ifm__ifm_interfaces_interface_tunnel_protocol, is_container='container', yang_name="tunnel-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-tunnel-management', defining_module='huawei-tunnel-management', yang_type='container', is_config=True)""",
        })

    self.__tunnel_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_protocol(self):
    self.__tunnel_protocol = YANGDynClass(base=yc_tunnel_protocol_huawei_ifm__ifm_interfaces_interface_tunnel_protocol, is_container='container', yang_name="tunnel-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-tunnel-management', defining_module='huawei-tunnel-management', yang_type='container', is_config=True)


  def _get_ipv4(self):
    """
    Getter method for ipv4, mapped from YANG variable /ifm/interfaces/interface/ipv4 (container)

    YANG Description: Configure IPv4 addresses.
    """
    return self.__ipv4
      
  def _set_ipv4(self, v, load=False):
    """
    Setter method for ipv4, mapped from YANG variable /ifm/interfaces/interface/ipv4 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4() directly.

    YANG Description: Configure IPv4 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_huawei_ifm__ifm_interfaces_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_huawei_ifm__ifm_interfaces_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__ipv4 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4(self):
    self.__ipv4 = YANGDynClass(base=yc_ipv4_huawei_ifm__ifm_interfaces_interface_ipv4, is_container='container', yang_name="ipv4", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)


  def _get_ipv6(self):
    """
    Getter method for ipv6, mapped from YANG variable /ifm/interfaces/interface/ipv6 (container)

    YANG Description: Enable/disable the IPv6 capability on an interface.
    """
    return self.__ipv6
      
  def _set_ipv6(self, v, load=False):
    """
    Setter method for ipv6, mapped from YANG variable /ifm/interfaces/interface/ipv6 (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6() directly.

    YANG Description: Enable/disable the IPv6 capability on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv6_huawei_ifm__ifm_interfaces_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv6 must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv6_huawei_ifm__ifm_interfaces_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)""",
        })

    self.__ipv6 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv6(self):
    self.__ipv6 = YANGDynClass(base=yc_ipv6_huawei_ifm__ifm_interfaces_interface_ipv6, is_container='container', yang_name="ipv6", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ip', defining_module='huawei-ip', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  class_ = __builtin__.property(_get_class_, _set_class_)
  type = __builtin__.property(_get_type, _set_type)
  parent_name = __builtin__.property(_get_parent_name, _set_parent_name)
  number = __builtin__.property(_get_number, _set_number)
  description = __builtin__.property(_get_description, _set_description)
  admin_status = __builtin__.property(_get_admin_status, _set_admin_status)
  link_protocol = __builtin__.property(_get_link_protocol, _set_link_protocol)
  router_type = __builtin__.property(_get_router_type, _set_router_type)
  clear_ip_df = __builtin__.property(_get_clear_ip_df, _set_clear_ip_df)
  link_up_down_trap_enable = __builtin__.property(_get_link_up_down_trap_enable, _set_link_up_down_trap_enable)
  statistic_enable = __builtin__.property(_get_statistic_enable, _set_statistic_enable)
  statistic_mode = __builtin__.property(_get_statistic_mode, _set_statistic_mode)
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)
  bandwidth_kbps = __builtin__.property(_get_bandwidth_kbps, _set_bandwidth_kbps)
  mtu = __builtin__.property(_get_mtu, _set_mtu)
  spread_mtu_flag = __builtin__.property(_get_spread_mtu_flag, _set_spread_mtu_flag)
  statistic_interval = __builtin__.property(_get_statistic_interval, _set_statistic_interval)
  vrf_name = __builtin__.property(_get_vrf_name, _set_vrf_name)
  l2_mode_enable = __builtin__.property(_get_l2_mode_enable, _set_l2_mode_enable)
  down_delay_time = __builtin__.property(_get_down_delay_time, _set_down_delay_time)
  mac_address = __builtin__.property(_get_mac_address, _set_mac_address)
  index = __builtin__.property(_get_index)
  position = __builtin__.property(_get_position)
  aggregation_name = __builtin__.property(_get_aggregation_name)
  is_l2_switch = __builtin__.property(_get_is_l2_switch)
  vs_name = __builtin__.property(_get_vs_name)
  l2_switch_port_index = __builtin__.property(_get_l2_switch_port_index)
  service_type = __builtin__.property(_get_service_type)
  encapsulation_type = __builtin__.property(_get_encapsulation_type)
  network_layer_status = __builtin__.property(_get_network_layer_status, _set_network_layer_status)
  protocol_up_delay_time = __builtin__.property(_get_protocol_up_delay_time, _set_protocol_up_delay_time)
  control_flap = __builtin__.property(_get_control_flap, _set_control_flap) # type: yc_control_flap_huawei_ifm__ifm_interfaces_interface_control_flap
  trap_threshold = __builtin__.property(_get_trap_threshold, _set_trap_threshold) # type: yc_trap_threshold_huawei_ifm__ifm_interfaces_interface_trap_threshold
  ignore_damp = __builtin__.property(_get_ignore_damp, _set_ignore_damp) # type: yc_ignore_damp_huawei_ifm__ifm_interfaces_interface_ignore_damp
  damp = __builtin__.property(_get_damp, _set_damp) # type: yc_damp_huawei_ifm__ifm_interfaces_interface_damp
  damp_state = __builtin__.property(_get_damp_state, _set_damp_state) # type: yc_damp_state_huawei_ifm__ifm_interfaces_interface_damp_state
  dynamic = __builtin__.property(_get_dynamic, _set_dynamic) # type: yc_dynamic_huawei_ifm__ifm_interfaces_interface_dynamic
  mib_statistics = __builtin__.property(_get_mib_statistics, _set_mib_statistics) # type: yc_mib_statistics_huawei_ifm__ifm_interfaces_interface_mib_statistics
  common_statistics = __builtin__.property(_get_common_statistics, _set_common_statistics) # type: yc_common_statistics_huawei_ifm__ifm_interfaces_interface_common_statistics
  error_down = __builtin__.property(_get_error_down, _set_error_down) # type: yc_error_down_huawei_ifm__ifm_interfaces_interface_error_down
  tunnel_protocol = __builtin__.property(_get_tunnel_protocol, _set_tunnel_protocol) # type: yc_tunnel_protocol_huawei_ifm__ifm_interfaces_interface_tunnel_protocol
  ipv4 = __builtin__.property(_get_ipv4, _set_ipv4) # type: yc_ipv4_huawei_ifm__ifm_interfaces_interface_ipv4
  ipv6 = __builtin__.property(_get_ipv6, _set_ipv6) # type: yc_ipv6_huawei_ifm__ifm_interfaces_interface_ipv6

  __choices__ = {'bandwidth-type': {'bandwidth-mbps': ['bandwidth'], 'bandwidth-kbps': ['bandwidth_kbps']}, 'damping': {'ignore-damp': ['ignore_damp'], 'damp': ['damp']}}
  _pyangbind_elements = OrderedDict([('name', name), ('class_', class_), ('type', type), ('parent_name', parent_name), ('number', number), ('description', description), ('admin_status', admin_status), ('link_protocol', link_protocol), ('router_type', router_type), ('clear_ip_df', clear_ip_df), ('link_up_down_trap_enable', link_up_down_trap_enable), ('statistic_enable', statistic_enable), ('statistic_mode', statistic_mode), ('bandwidth', bandwidth), ('bandwidth_kbps', bandwidth_kbps), ('mtu', mtu), ('spread_mtu_flag', spread_mtu_flag), ('statistic_interval', statistic_interval), ('vrf_name', vrf_name), ('l2_mode_enable', l2_mode_enable), ('down_delay_time', down_delay_time), ('mac_address', mac_address), ('index', index), ('position', position), ('aggregation_name', aggregation_name), ('is_l2_switch', is_l2_switch), ('vs_name', vs_name), ('l2_switch_port_index', l2_switch_port_index), ('service_type', service_type), ('encapsulation_type', encapsulation_type), ('network_layer_status', network_layer_status), ('protocol_up_delay_time', protocol_up_delay_time), ('control_flap', control_flap), ('trap_threshold', trap_threshold), ('ignore_damp', ignore_damp), ('damp', damp), ('damp_state', damp_state), ('dynamic', dynamic), ('mib_statistics', mib_statistics), ('common_statistics', common_statistics), ('error_down', error_down), ('tunnel_protocol', tunnel_protocol), ('ipv4', ipv4), ('ipv6', ipv6), ])


class yc_interfaces_huawei_ifm__ifm_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of configuring information on an interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__interface',)

  _yang_name = 'interfaces'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_huawei_ifm__ifm_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'interfaces']

  def _get_interface(self):
    """
    Getter method for interface, mapped from YANG variable /ifm/interfaces/interface (list)

    YANG Description: Configure information on an interface. Physical, NULL, Virtual-if, and Virtual-Template0 interfaces cannot be created or deleted.
    """
    return self.__interface
      
  def _set_interface(self, v, load=False):
    """
    Setter method for interface, mapped from YANG variable /ifm/interfaces/interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface() directly.

    YANG Description: Configure information on an interface. Physical, NULL, Virtual-if, and Virtual-Template0 interfaces cannot be created or deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_interface_huawei_ifm__ifm_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_interface_huawei_ifm__ifm_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)""",
        })

    self.__interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interface(self):
    self.__interface = YANGDynClass(base=YANGListType("name",yc_interface_huawei_ifm__ifm_interfaces_interface, yang_name="interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=True)

  interface = __builtin__.property(_get_interface, _set_interface) # type: yc_interface_huawei_ifm__ifm_interfaces_interface


  _pyangbind_elements = OrderedDict([('interface', interface), ])


class yc_static_dimension_range_huawei_ifm__ifm_static_dimension_ranges_static_dimension_range(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/static-dimension-ranges/static-dimension-range. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of Interface dimensionality.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__chassis_range','__slot_range','__card_range','__port_range',)

  _yang_name = 'static-dimension-range'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=False)
    self.__chassis_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="chassis-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__slot_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="slot-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__card_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="card-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__port_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="port-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'static-dimension-ranges', 'static-dimension-range']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/type (port-type)

    YANG Description: Interface type.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/type (port-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Interface type.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with port-type""",
          'defined-type': "huawei-ifm:port-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'Ethernet': {'value': 0}, 'GigabitEthernet': {'value': 2}, 'Eth-Trunk': {'value': 4}, 'Ip-Trunk': {'value': 5}, 'Pos': {'value': 9}, 'Tunnel': {'value': 14}, 'NULL': {'value': 18}, 'LoopBack': {'value': 19}, 'Vlanif': {'value': 15}, '100GE': {'value': 20}, '200GE': {'value': 92}, '40GE': {'value': 23}, 'MTunnel': {'value': 22}, '10GE': {'value': 24}, 'GEBrief': {'value': 25}, 'MEth': {'value': 26}, 'IMEth': {'value': 79}, 'Stack-Port': {'value': 27}, 'Sip': {'value': 28}, 'Cpos': {'value': 10}, 'E1': {'value': 30}, 'Serial': {'value': 8}, 'Mp-group': {'value': 31}, 'Virtual-Ethernet': {'value': 6}, 'VMEth': {'value': 33}, 'Ima-group': {'value': 32}, 'Remote-Ap': {'value': 35}, 'VBridge': {'value': 36}, 'Atm-Bundle': {'value': 37}, 'Fiber-Channel': {'value': 38}, 'Infiniband': {'value': 39}, 'Lmpif': {'value': 21}, 'T1': {'value': 41}, 'T3': {'value': 42}, 'Global-VE': {'value': 45}, 'VC4': {'value': 43}, 'VC12': {'value': 44}, 'Vbdif': {'value': 40}, 'Fabric-Port': {'value': 46}, 'E3': {'value': 48}, 'Otn': {'value': 55}, 'Vp': {'value': 49}, 'DcnInterface': {'value': 50}, 'Cpos-Trunk': {'value': 51}, 'Pos-Trunk': {'value': 59}, 'Trunk-Serial': {'value': 52}, 'Global-Ima-Group': {'value': 57}, 'Global-Mp-Group': {'value': 53}, 'Gmpls-Uni': {'value': 63}, 'Wdm': {'value': 64}, 'Nve': {'value': 65}, 'FCoE-Port': {'value': 67}, 'Virtual-Template': {'value': 68}, 'FC': {'value': 70}, '4x10GE': {'value': 71}, '10x10GE': {'value': 72}, '3x40GE': {'value': 73}, '4x25GE': {'value': 74}, '25GE': {'value': 75}, 'ATM': {'value': 11}, 'XGigabitEthernet': {'value': 91}, 'ServiceIf': {'value': 90}, 'Virtual-ODUk': {'value': 94}, 'FlexE': {'value': 95}, 'FlexE-200GE': {'value': 96}, '50|100GE': {'value': 101}, '50GE': {'value': 102}, 'FlexE-50G': {'value': 103}, 'FlexE-100G': {'value': 104}, 'FlexE-50|100G': {'value': 105}, 'PW-VE': {'value': 88}, 'Virtual-Serial': {'value': 107}, '400GE': {'value': 108}, 'VX-Tunnel': {'value': 89}, 'HPGE': {'value': 114}, 'Virtual-if': {'value': 116}, 'Cellular': {'value': 117}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='port-type', is_config=False)


  def _get_chassis_range(self):
    """
    Getter method for chassis_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/chassis_range (string)

    YANG Description: The range of chassis.
    """
    return self.__chassis_range
      
  def _set_chassis_range(self, v, load=False):
    """
    Setter method for chassis_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/chassis_range (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chassis_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chassis_range() directly.

    YANG Description: The range of chassis.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="chassis-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chassis_range must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="chassis-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__chassis_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chassis_range(self):
    self.__chassis_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="chassis-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_slot_range(self):
    """
    Getter method for slot_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/slot_range (string)

    YANG Description: The range of slot.
    """
    return self.__slot_range
      
  def _set_slot_range(self, v, load=False):
    """
    Setter method for slot_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/slot_range (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slot_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slot_range() directly.

    YANG Description: The range of slot.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="slot-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slot_range must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="slot-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__slot_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slot_range(self):
    self.__slot_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="slot-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_card_range(self):
    """
    Getter method for card_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/card_range (string)

    YANG Description: The range of card.
    """
    return self.__card_range
      
  def _set_card_range(self, v, load=False):
    """
    Setter method for card_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/card_range (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_card_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_card_range() directly.

    YANG Description: The range of card.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="card-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """card_range must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="card-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__card_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_card_range(self):
    self.__card_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="card-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_port_range(self):
    """
    Getter method for port_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/port_range (string)

    YANG Description: The range of port.
    """
    return self.__port_range
      
  def _set_port_range(self, v, load=False):
    """
    Setter method for port_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range/port_range (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_range() directly.

    YANG Description: The range of port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="port-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port_range must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="port-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__port_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port_range(self):
    self.__port_range = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..63']}), is_leaf=True, yang_name="port-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)

  type = __builtin__.property(_get_type)
  chassis_range = __builtin__.property(_get_chassis_range)
  slot_range = __builtin__.property(_get_slot_range)
  card_range = __builtin__.property(_get_card_range)
  port_range = __builtin__.property(_get_port_range)


  _pyangbind_elements = OrderedDict([('type', type), ('chassis_range', chassis_range), ('slot_range', slot_range), ('card_range', card_range), ('port_range', port_range), ])


class yc_static_dimension_ranges_huawei_ifm__ifm_static_dimension_ranges(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/static-dimension-ranges. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of interface dimensionality.
  """
  __slots__ = ('_path_helper', '_extmethods', '__static_dimension_range',)

  _yang_name = 'static-dimension-ranges'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__static_dimension_range = YANGDynClass(base=YANGListType("type",yc_static_dimension_range_huawei_ifm__ifm_static_dimension_ranges_static_dimension_range, yang_name="static-dimension-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="static-dimension-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'static-dimension-ranges']

  def _get_static_dimension_range(self):
    """
    Getter method for static_dimension_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range (list)

    YANG Description: Statistics of Interface dimensionality.
    """
    return self.__static_dimension_range
      
  def _set_static_dimension_range(self, v, load=False):
    """
    Setter method for static_dimension_range, mapped from YANG variable /ifm/static_dimension_ranges/static_dimension_range (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_dimension_range is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_dimension_range() directly.

    YANG Description: Statistics of Interface dimensionality.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type",yc_static_dimension_range_huawei_ifm__ifm_static_dimension_ranges_static_dimension_range, yang_name="static-dimension-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="static-dimension-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_dimension_range must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type",yc_static_dimension_range_huawei_ifm__ifm_static_dimension_ranges_static_dimension_range, yang_name="static-dimension-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="static-dimension-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)""",
        })

    self.__static_dimension_range = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_dimension_range(self):
    self.__static_dimension_range = YANGDynClass(base=YANGListType("type",yc_static_dimension_range_huawei_ifm__ifm_static_dimension_ranges_static_dimension_range, yang_name="static-dimension-range", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="static-dimension-range", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)

  static_dimension_range = __builtin__.property(_get_static_dimension_range) # type: yc_static_dimension_range_huawei_ifm__ifm_static_dimension_ranges_static_dimension_range


  _pyangbind_elements = OrderedDict([('static_dimension_range', static_dimension_range), ])


class yc_ipv4_interface_count_huawei_ifm__ifm_ipv4_interface_count(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/ipv4-interface-count. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of interfaces supporting IPv4 address configuration.
  """
  __slots__ = ('_path_helper', '_extmethods', '__physical_up_count','__physical_down_count','__protocol_up_count','__protocol_down_count',)

  _yang_name = 'ipv4-interface-count'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__physical_up_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__physical_down_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__protocol_up_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__protocol_down_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'ipv4-interface-count']

  def _get_physical_up_count(self):
    """
    Getter method for physical_up_count, mapped from YANG variable /ifm/ipv4_interface_count/physical_up_count (uint32)

    YANG Description: Number of IPv4 interfaces that are in the physical up state.
    """
    return self.__physical_up_count
      
  def _set_physical_up_count(self, v, load=False):
    """
    Setter method for physical_up_count, mapped from YANG variable /ifm/ipv4_interface_count/physical_up_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_up_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_up_count() directly.

    YANG Description: Number of IPv4 interfaces that are in the physical up state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_up_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__physical_up_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_up_count(self):
    self.__physical_up_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_physical_down_count(self):
    """
    Getter method for physical_down_count, mapped from YANG variable /ifm/ipv4_interface_count/physical_down_count (uint32)

    YANG Description: Number of IPv4 interfaces that are in the physical down state.
    """
    return self.__physical_down_count
      
  def _set_physical_down_count(self, v, load=False):
    """
    Setter method for physical_down_count, mapped from YANG variable /ifm/ipv4_interface_count/physical_down_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_down_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_down_count() directly.

    YANG Description: Number of IPv4 interfaces that are in the physical down state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physical_down_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__physical_down_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physical_down_count(self):
    self.__physical_down_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="physical-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_protocol_up_count(self):
    """
    Getter method for protocol_up_count, mapped from YANG variable /ifm/ipv4_interface_count/protocol_up_count (uint32)

    YANG Description: Number of IPv4 interfaces that are in the protocol up state.
    """
    return self.__protocol_up_count
      
  def _set_protocol_up_count(self, v, load=False):
    """
    Setter method for protocol_up_count, mapped from YANG variable /ifm/ipv4_interface_count/protocol_up_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_up_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_up_count() directly.

    YANG Description: Number of IPv4 interfaces that are in the protocol up state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_up_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__protocol_up_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_up_count(self):
    self.__protocol_up_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-up-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_protocol_down_count(self):
    """
    Getter method for protocol_down_count, mapped from YANG variable /ifm/ipv4_interface_count/protocol_down_count (uint32)

    YANG Description: Number of IPv4 interfaces that are in the protocol down state.
    """
    return self.__protocol_down_count
      
  def _set_protocol_down_count(self, v, load=False):
    """
    Setter method for protocol_down_count, mapped from YANG variable /ifm/ipv4_interface_count/protocol_down_count (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_down_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_down_count() directly.

    YANG Description: Number of IPv4 interfaces that are in the protocol down state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_down_count must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__protocol_down_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_down_count(self):
    self.__protocol_down_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="protocol-down-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)

  physical_up_count = __builtin__.property(_get_physical_up_count)
  physical_down_count = __builtin__.property(_get_physical_down_count)
  protocol_up_count = __builtin__.property(_get_protocol_up_count)
  protocol_down_count = __builtin__.property(_get_protocol_down_count)


  _pyangbind_elements = OrderedDict([('physical_up_count', physical_up_count), ('physical_down_count', physical_down_count), ('protocol_up_count', protocol_up_count), ('protocol_down_count', protocol_down_count), ])


class yc_remote_statistics_state_huawei_ifm__ifm_remote_interfaces_remote_interface_remote_statistics_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/remote-interfaces/remote-interface/remote-statistics-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of remote interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__last_cleared_time','__in_bit_rate','__in_packet_rate','__in_peak_bit_rate','__in_peak_bit_rate_record_time','__out_bit_rate','__out_packet_rate','__out_peak_bit_rate','__out_peak_bit_rate_record_time','__in_use_rate','__out_use_rate',)

  _yang_name = 'remote-statistics-state'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__last_cleared_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="last-cleared-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)
    self.__in_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__in_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__in_peak_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__in_peak_bit_rate_record_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="in-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)
    self.__out_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__out_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__out_peak_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    self.__out_peak_bit_rate_record_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="out-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)
    self.__in_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    self.__out_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'remote-interfaces', 'remote-interface', 'remote-statistics-state']

  def _get_last_cleared_time(self):
    """
    Getter method for last_cleared_time, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/last_cleared_time (pub-type:time)

    YANG Description: Last time when statistics about remote interfaces were cleared.
    """
    return self.__last_cleared_time
      
  def _set_last_cleared_time(self, v, load=False):
    """
    Setter method for last_cleared_time, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/last_cleared_time (pub-type:time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_last_cleared_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_last_cleared_time() directly.

    YANG Description: Last time when statistics about remote interfaces were cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="last-cleared-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """last_cleared_time must be of a type compatible with pub-type:time""",
          'defined-type': "pub-type:time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="last-cleared-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)""",
        })

    self.__last_cleared_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_last_cleared_time(self):
    self.__last_cleared_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="last-cleared-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)


  def _get_in_bit_rate(self):
    """
    Getter method for in_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_bit_rate (uint64)

    YANG Description: Rate at which bits are received.
    """
    return self.__in_bit_rate
      
  def _set_in_bit_rate(self, v, load=False):
    """
    Setter method for in_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_bit_rate() directly.

    YANG Description: Rate at which bits are received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__in_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_bit_rate(self):
    self.__in_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_in_packet_rate(self):
    """
    Getter method for in_packet_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_packet_rate (uint64)

    YANG Description: Rate at which packets are received.
    """
    return self.__in_packet_rate
      
  def _set_in_packet_rate(self, v, load=False):
    """
    Setter method for in_packet_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_packet_rate() directly.

    YANG Description: Rate at which packets are received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__in_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_packet_rate(self):
    self.__in_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_in_peak_bit_rate(self):
    """
    Getter method for in_peak_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_peak_bit_rate (uint64)

    YANG Description: Peak rate at which bits are received.
    """
    return self.__in_peak_bit_rate
      
  def _set_in_peak_bit_rate(self, v, load=False):
    """
    Setter method for in_peak_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_peak_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_peak_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_peak_bit_rate() directly.

    YANG Description: Peak rate at which bits are received.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_peak_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__in_peak_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_peak_bit_rate(self):
    self.__in_peak_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="in-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_in_peak_bit_rate_record_time(self):
    """
    Getter method for in_peak_bit_rate_record_time, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_peak_bit_rate_record_time (pub-type:time)

    YANG Description: Time when the peak bit receive rate is reached.
    """
    return self.__in_peak_bit_rate_record_time
      
  def _set_in_peak_bit_rate_record_time(self, v, load=False):
    """
    Setter method for in_peak_bit_rate_record_time, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_peak_bit_rate_record_time (pub-type:time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_peak_bit_rate_record_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_peak_bit_rate_record_time() directly.

    YANG Description: Time when the peak bit receive rate is reached.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="in-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_peak_bit_rate_record_time must be of a type compatible with pub-type:time""",
          'defined-type': "pub-type:time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="in-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)""",
        })

    self.__in_peak_bit_rate_record_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_peak_bit_rate_record_time(self):
    self.__in_peak_bit_rate_record_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="in-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)


  def _get_out_bit_rate(self):
    """
    Getter method for out_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_bit_rate (uint64)

    YANG Description: Rate at which bits are sent.
    """
    return self.__out_bit_rate
      
  def _set_out_bit_rate(self, v, load=False):
    """
    Setter method for out_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_bit_rate() directly.

    YANG Description: Rate at which bits are sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__out_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_bit_rate(self):
    self.__out_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_out_packet_rate(self):
    """
    Getter method for out_packet_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_packet_rate (uint64)

    YANG Description: Rate at which packets are sent.
    """
    return self.__out_packet_rate
      
  def _set_out_packet_rate(self, v, load=False):
    """
    Setter method for out_packet_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_packet_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_packet_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_packet_rate() directly.

    YANG Description: Rate at which packets are sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_packet_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__out_packet_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_packet_rate(self):
    self.__out_packet_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-packet-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_out_peak_bit_rate(self):
    """
    Getter method for out_peak_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_peak_bit_rate (uint64)

    YANG Description: Peak rate at which bits are sent.
    """
    return self.__out_peak_bit_rate
      
  def _set_out_peak_bit_rate(self, v, load=False):
    """
    Setter method for out_peak_bit_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_peak_bit_rate (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_peak_bit_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_peak_bit_rate() directly.

    YANG Description: Peak rate at which bits are sent.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_peak_bit_rate must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)""",
        })

    self.__out_peak_bit_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_peak_bit_rate(self):
    self.__out_peak_bit_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="out-peak-bit-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint64', is_config=False)


  def _get_out_peak_bit_rate_record_time(self):
    """
    Getter method for out_peak_bit_rate_record_time, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_peak_bit_rate_record_time (pub-type:time)

    YANG Description: Time when the peak bit send rate is reached.
    """
    return self.__out_peak_bit_rate_record_time
      
  def _set_out_peak_bit_rate_record_time(self, v, load=False):
    """
    Setter method for out_peak_bit_rate_record_time, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_peak_bit_rate_record_time (pub-type:time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_peak_bit_rate_record_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_peak_bit_rate_record_time() directly.

    YANG Description: Time when the peak bit send rate is reached.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="out-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_peak_bit_rate_record_time must be of a type compatible with pub-type:time""",
          'defined-type': "pub-type:time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="out-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)""",
        })

    self.__out_peak_bit_rate_record_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_peak_bit_rate_record_time(self):
    self.__out_peak_bit_rate_record_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{1,2}:\\d{1,2}:\\d{1,2}'}), is_leaf=True, yang_name="out-peak-bit-rate-record-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:time', is_config=False)


  def _get_in_use_rate(self):
    """
    Getter method for in_use_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_use_rate (string)

    YANG Description: Received bandwidth usage.
    """
    return self.__in_use_rate
      
  def _set_in_use_rate(self, v, load=False):
    """
    Setter method for in_use_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/in_use_rate (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_in_use_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_in_use_rate() directly.

    YANG Description: Received bandwidth usage.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """in_use_rate must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__in_use_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_in_use_rate(self):
    self.__in_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="in-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)


  def _get_out_use_rate(self):
    """
    Getter method for out_use_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_use_rate (string)

    YANG Description: Sent bandwidth usage.
    """
    return self.__out_use_rate
      
  def _set_out_use_rate(self, v, load=False):
    """
    Setter method for out_use_rate, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state/out_use_rate (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_out_use_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_out_use_rate() directly.

    YANG Description: Sent bandwidth usage.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """out_use_rate must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)""",
        })

    self.__out_use_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_out_use_rate(self):
    self.__out_use_rate = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..50']}), is_leaf=True, yang_name="out-use-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='string', is_config=False)

  last_cleared_time = __builtin__.property(_get_last_cleared_time)
  in_bit_rate = __builtin__.property(_get_in_bit_rate)
  in_packet_rate = __builtin__.property(_get_in_packet_rate)
  in_peak_bit_rate = __builtin__.property(_get_in_peak_bit_rate)
  in_peak_bit_rate_record_time = __builtin__.property(_get_in_peak_bit_rate_record_time)
  out_bit_rate = __builtin__.property(_get_out_bit_rate)
  out_packet_rate = __builtin__.property(_get_out_packet_rate)
  out_peak_bit_rate = __builtin__.property(_get_out_peak_bit_rate)
  out_peak_bit_rate_record_time = __builtin__.property(_get_out_peak_bit_rate_record_time)
  in_use_rate = __builtin__.property(_get_in_use_rate)
  out_use_rate = __builtin__.property(_get_out_use_rate)


  _pyangbind_elements = OrderedDict([('last_cleared_time', last_cleared_time), ('in_bit_rate', in_bit_rate), ('in_packet_rate', in_packet_rate), ('in_peak_bit_rate', in_peak_bit_rate), ('in_peak_bit_rate_record_time', in_peak_bit_rate_record_time), ('out_bit_rate', out_bit_rate), ('out_packet_rate', out_packet_rate), ('out_peak_bit_rate', out_peak_bit_rate), ('out_peak_bit_rate_record_time', out_peak_bit_rate_record_time), ('in_use_rate', in_use_rate), ('out_use_rate', out_use_rate), ])


class yc_remote_interface_huawei_ifm__ifm_remote_interfaces_remote_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/remote-interfaces/remote-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of remote interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__index','__remote_statistics_state',)

  _yang_name = 'remote-interface'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    self.__remote_statistics_state = YANGDynClass(base=yc_remote_statistics_state_huawei_ifm__ifm_remote_interfaces_remote_interface_remote_statistics_state, is_container='container', yang_name="remote-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'remote-interfaces', 'remote-interface']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ifm/remote_interfaces/remote_interface/name (pub-type:if-name)

    YANG Description: Name of a remote interface.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ifm/remote_interfaces/remote_interface/name (pub-type:if-name)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of a remote interface.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with pub-type:if-name""",
          'defined-type': "pub-type:if-name",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..63']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='pub-type:if-name', is_config=False)


  def _get_index(self):
    """
    Getter method for index, mapped from YANG variable /ifm/remote_interfaces/remote_interface/index (uint32)

    YANG Description: Index of a remote interface.
    """
    return self.__index
      
  def _set_index(self, v, load=False):
    """
    Setter method for index, mapped from YANG variable /ifm/remote_interfaces/remote_interface/index (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_index is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_index() directly.

    YANG Description: Index of a remote interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """index must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)""",
        })

    self.__index = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_index(self):
    self.__index = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="index", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='uint32', is_config=False)


  def _get_remote_statistics_state(self):
    """
    Getter method for remote_statistics_state, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state (container)

    YANG Description: Statistics of remote interfaces.
    """
    return self.__remote_statistics_state
      
  def _set_remote_statistics_state(self, v, load=False):
    """
    Setter method for remote_statistics_state, mapped from YANG variable /ifm/remote_interfaces/remote_interface/remote_statistics_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_statistics_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_statistics_state() directly.

    YANG Description: Statistics of remote interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_remote_statistics_state_huawei_ifm__ifm_remote_interfaces_remote_interface_remote_statistics_state, is_container='container', yang_name="remote-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_statistics_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_remote_statistics_state_huawei_ifm__ifm_remote_interfaces_remote_interface_remote_statistics_state, is_container='container', yang_name="remote-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=False)""",
        })

    self.__remote_statistics_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_statistics_state(self):
    self.__remote_statistics_state = YANGDynClass(base=yc_remote_statistics_state_huawei_ifm__ifm_remote_interfaces_remote_interface_remote_statistics_state, is_container='container', yang_name="remote-statistics-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=False)

  name = __builtin__.property(_get_name)
  index = __builtin__.property(_get_index)
  remote_statistics_state = __builtin__.property(_get_remote_statistics_state) # type: yc_remote_statistics_state_huawei_ifm__ifm_remote_interfaces_remote_interface_remote_statistics_state


  _pyangbind_elements = OrderedDict([('name', name), ('index', index), ('remote_statistics_state', remote_statistics_state), ])


class yc_remote_interfaces_huawei_ifm__ifm_remote_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm/remote-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of statistics of remote interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__remote_interface',)

  _yang_name = 'remote-interfaces'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__remote_interface = YANGDynClass(base=YANGListType("name",yc_remote_interface_huawei_ifm__ifm_remote_interfaces_remote_interface, yang_name="remote-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="remote-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm', 'remote-interfaces']

  def _get_remote_interface(self):
    """
    Getter method for remote_interface, mapped from YANG variable /ifm/remote_interfaces/remote_interface (list)

    YANG Description: Statistics of remote interfaces.
    """
    return self.__remote_interface
      
  def _set_remote_interface(self, v, load=False):
    """
    Setter method for remote_interface, mapped from YANG variable /ifm/remote_interfaces/remote_interface (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_interface() directly.

    YANG Description: Statistics of remote interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_remote_interface_huawei_ifm__ifm_remote_interfaces_remote_interface, yang_name="remote-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="remote-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_interface must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_remote_interface_huawei_ifm__ifm_remote_interfaces_remote_interface, yang_name="remote-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="remote-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)""",
        })

    self.__remote_interface = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_interface(self):
    self.__remote_interface = YANGDynClass(base=YANGListType("name",yc_remote_interface_huawei_ifm__ifm_remote_interfaces_remote_interface, yang_name="remote-interface", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="remote-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='list', is_config=False)

  remote_interface = __builtin__.property(_get_remote_interface) # type: yc_remote_interface_huawei_ifm__ifm_remote_interfaces_remote_interface


  _pyangbind_elements = OrderedDict([('remote_interface', remote_interface), ])


class yc_ifm_huawei_ifm__ifm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /ifm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Common interface management. It includes the public configuration of interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__global_','__damp','__auto_recovery_times','__interfaces','__static_dimension_ranges','__ipv4_interface_count','__remote_interfaces',)

  _yang_name = 'ifm'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__global_ = YANGDynClass(base=yc_global__huawei_ifm__ifm_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__damp = YANGDynClass(base=yc_damp_huawei_ifm__ifm_damp, is_container='container', yang_name="damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__auto_recovery_times = YANGDynClass(base=yc_auto_recovery_times_huawei_ifm__ifm_auto_recovery_times, is_container='container', yang_name="auto-recovery-times", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__interfaces = YANGDynClass(base=yc_interfaces_huawei_ifm__ifm_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__static_dimension_ranges = YANGDynClass(base=yc_static_dimension_ranges_huawei_ifm__ifm_static_dimension_ranges, is_container='container', yang_name="static-dimension-ranges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__ipv4_interface_count = YANGDynClass(base=yc_ipv4_interface_count_huawei_ifm__ifm_ipv4_interface_count, is_container='container', yang_name="ipv4-interface-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    self.__remote_interfaces = YANGDynClass(base=yc_remote_interfaces_huawei_ifm__ifm_remote_interfaces, is_container='container', yang_name="remote-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ifm']

  def _get_global_(self):
    """
    Getter method for global_, mapped from YANG variable /ifm/global (container)

    YANG Description: Configure globally configured attributes.
    """
    return self.__global_
      
  def _set_global_(self, v, load=False):
    """
    Setter method for global_, mapped from YANG variable /ifm/global (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_() directly.

    YANG Description: Configure globally configured attributes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_global__huawei_ifm__ifm_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_ must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_global__huawei_ifm__ifm_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__global_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_(self):
    self.__global_ = YANGDynClass(base=yc_global__huawei_ifm__ifm_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_damp(self):
    """
    Getter method for damp, mapped from YANG variable /ifm/damp (container)

    YANG Description: Enable/disable suppression on interfaces' physical status flappings.
    """
    return self.__damp
      
  def _set_damp(self, v, load=False):
    """
    Setter method for damp, mapped from YANG variable /ifm/damp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_damp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_damp() directly.

    YANG Description: Enable/disable suppression on interfaces' physical status flappings.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_damp_huawei_ifm__ifm_damp, is_container='container', yang_name="damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """damp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_damp_huawei_ifm__ifm_damp, is_container='container', yang_name="damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__damp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_damp(self):
    self.__damp = YANGDynClass(base=yc_damp_huawei_ifm__ifm_damp, is_container='container', yang_name="damp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_auto_recovery_times(self):
    """
    Getter method for auto_recovery_times, mapped from YANG variable /ifm/auto_recovery_times (container)

    YANG Description: List of automatic recovery time configuration.
    """
    return self.__auto_recovery_times
      
  def _set_auto_recovery_times(self, v, load=False):
    """
    Setter method for auto_recovery_times, mapped from YANG variable /ifm/auto_recovery_times (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_recovery_times is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_recovery_times() directly.

    YANG Description: List of automatic recovery time configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_auto_recovery_times_huawei_ifm__ifm_auto_recovery_times, is_container='container', yang_name="auto-recovery-times", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auto_recovery_times must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_auto_recovery_times_huawei_ifm__ifm_auto_recovery_times, is_container='container', yang_name="auto-recovery-times", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__auto_recovery_times = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auto_recovery_times(self):
    self.__auto_recovery_times = YANGDynClass(base=yc_auto_recovery_times_huawei_ifm__ifm_auto_recovery_times, is_container='container', yang_name="auto-recovery-times", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /ifm/interfaces (container)

    YANG Description: List of configuring information on an interface.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /ifm/interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: List of configuring information on an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_interfaces_huawei_ifm__ifm_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_interfaces_huawei_ifm__ifm_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=yc_interfaces_huawei_ifm__ifm_interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_static_dimension_ranges(self):
    """
    Getter method for static_dimension_ranges, mapped from YANG variable /ifm/static_dimension_ranges (container)

    YANG Description: List of interface dimensionality.
    """
    return self.__static_dimension_ranges
      
  def _set_static_dimension_ranges(self, v, load=False):
    """
    Setter method for static_dimension_ranges, mapped from YANG variable /ifm/static_dimension_ranges (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_dimension_ranges is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_dimension_ranges() directly.

    YANG Description: List of interface dimensionality.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_static_dimension_ranges_huawei_ifm__ifm_static_dimension_ranges, is_container='container', yang_name="static-dimension-ranges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_dimension_ranges must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_static_dimension_ranges_huawei_ifm__ifm_static_dimension_ranges, is_container='container', yang_name="static-dimension-ranges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__static_dimension_ranges = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_dimension_ranges(self):
    self.__static_dimension_ranges = YANGDynClass(base=yc_static_dimension_ranges_huawei_ifm__ifm_static_dimension_ranges, is_container='container', yang_name="static-dimension-ranges", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_ipv4_interface_count(self):
    """
    Getter method for ipv4_interface_count, mapped from YANG variable /ifm/ipv4_interface_count (container)

    YANG Description: Statistics of interfaces supporting IPv4 address configuration.
    """
    return self.__ipv4_interface_count
      
  def _set_ipv4_interface_count(self, v, load=False):
    """
    Setter method for ipv4_interface_count, mapped from YANG variable /ifm/ipv4_interface_count (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv4_interface_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv4_interface_count() directly.

    YANG Description: Statistics of interfaces supporting IPv4 address configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipv4_interface_count_huawei_ifm__ifm_ipv4_interface_count, is_container='container', yang_name="ipv4-interface-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipv4_interface_count must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipv4_interface_count_huawei_ifm__ifm_ipv4_interface_count, is_container='container', yang_name="ipv4-interface-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__ipv4_interface_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipv4_interface_count(self):
    self.__ipv4_interface_count = YANGDynClass(base=yc_ipv4_interface_count_huawei_ifm__ifm_ipv4_interface_count, is_container='container', yang_name="ipv4-interface-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)


  def _get_remote_interfaces(self):
    """
    Getter method for remote_interfaces, mapped from YANG variable /ifm/remote_interfaces (container)

    YANG Description: List of statistics of remote interfaces.
    """
    return self.__remote_interfaces
      
  def _set_remote_interfaces(self, v, load=False):
    """
    Setter method for remote_interfaces, mapped from YANG variable /ifm/remote_interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_interfaces() directly.

    YANG Description: List of statistics of remote interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_remote_interfaces_huawei_ifm__ifm_remote_interfaces, is_container='container', yang_name="remote-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_remote_interfaces_huawei_ifm__ifm_remote_interfaces, is_container='container', yang_name="remote-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__remote_interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_interfaces(self):
    self.__remote_interfaces = YANGDynClass(base=yc_remote_interfaces_huawei_ifm__ifm_remote_interfaces, is_container='container', yang_name="remote-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

  global_ = __builtin__.property(_get_global_, _set_global_) # type: yc_global__huawei_ifm__ifm_global
  damp = __builtin__.property(_get_damp, _set_damp) # type: yc_damp_huawei_ifm__ifm_damp
  auto_recovery_times = __builtin__.property(_get_auto_recovery_times, _set_auto_recovery_times) # type: yc_auto_recovery_times_huawei_ifm__ifm_auto_recovery_times
  interfaces = __builtin__.property(_get_interfaces, _set_interfaces) # type: yc_interfaces_huawei_ifm__ifm_interfaces
  static_dimension_ranges = __builtin__.property(_get_static_dimension_ranges, _set_static_dimension_ranges) # type: yc_static_dimension_ranges_huawei_ifm__ifm_static_dimension_ranges
  ipv4_interface_count = __builtin__.property(_get_ipv4_interface_count, _set_ipv4_interface_count) # type: yc_ipv4_interface_count_huawei_ifm__ifm_ipv4_interface_count
  remote_interfaces = __builtin__.property(_get_remote_interfaces, _set_remote_interfaces) # type: yc_remote_interfaces_huawei_ifm__ifm_remote_interfaces


  _pyangbind_elements = OrderedDict([('global_', global_), ('damp', damp), ('auto_recovery_times', auto_recovery_times), ('interfaces', interfaces), ('static_dimension_ranges', static_dimension_ranges), ('ipv4_interface_count', ipv4_interface_count), ('remote_interfaces', remote_interfaces), ])


class huawei_ifm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ifm - based on the path /huawei-ifm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Common interface management, which includes the public configuration of interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ifm',)

  _yang_name = 'huawei-ifm'
  _yang_namespace = 'urn:huawei:yang:huawei-ifm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ifm = YANGDynClass(base=yc_ifm_huawei_ifm__ifm, is_container='container', yang_name="ifm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ifm(self):
    """
    Getter method for ifm, mapped from YANG variable /ifm (container)

    YANG Description: Common interface management. It includes the public configuration of interfaces.
    """
    return self.__ifm
      
  def _set_ifm(self, v, load=False):
    """
    Setter method for ifm, mapped from YANG variable /ifm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ifm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ifm() directly.

    YANG Description: Common interface management. It includes the public configuration of interfaces.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ifm_huawei_ifm__ifm, is_container='container', yang_name="ifm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ifm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ifm_huawei_ifm__ifm, is_container='container', yang_name="ifm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)""",
        })

    self.__ifm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ifm(self):
    self.__ifm = YANGDynClass(base=yc_ifm_huawei_ifm__ifm, is_container='container', yang_name="ifm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-ifm', defining_module='huawei-ifm', yang_type='container', is_config=True)

  ifm = __builtin__.property(_get_ifm, _set_ifm) # type: yc_ifm_huawei_ifm__ifm


  _pyangbind_elements = OrderedDict([('ifm', ifm), ])


class huawei_ip(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-ip - based on the path /huawei-ip. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of YANG definitions for
configuring IP implementations.
Copyright (C) 2019 Huawei Technologies Co., Ltd. All rights reserved.
  """
  _pyangbind_elements = {}

  

class yc_global__huawei_network_instance__network_instance_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure the global layer 3 virtual private network (L3VPN).
  """
  __slots__ = ('_path_helper', '_extmethods', '__cfg_router_id','__as_notation_plain','__route_distinguisher_auto_ip',)

  _yang_name = 'global'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cfg_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="cfg-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)
    self.__as_notation_plain = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="as-notation-plain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='boolean', is_config=True)
    self.__route_distinguisher_auto_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="route-distinguisher-auto-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'global']

  def _get_cfg_router_id(self):
    """
    Getter method for cfg_router_id, mapped from YANG variable /network_instance/global/cfg_router_id (inet:ipv4-address-no-zone)

    YANG Description: The router id of router manager.
    """
    return self.__cfg_router_id
      
  def _set_cfg_router_id(self, v, load=False):
    """
    Setter method for cfg_router_id, mapped from YANG variable /network_instance/global/cfg_router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cfg_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cfg_router_id() directly.

    YANG Description: The router id of router manager.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="cfg-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cfg_router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="cfg-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__cfg_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cfg_router_id(self):
    self.__cfg_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="cfg-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)


  def _get_as_notation_plain(self):
    """
    Getter method for as_notation_plain, mapped from YANG variable /network_instance/global/as_notation_plain (boolean)

    YANG Description: Enable/disable setting the display format of the BGP 4 byte as to be unformatted integer type.
    """
    return self.__as_notation_plain
      
  def _set_as_notation_plain(self, v, load=False):
    """
    Setter method for as_notation_plain, mapped from YANG variable /network_instance/global/as_notation_plain (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_as_notation_plain is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_as_notation_plain() directly.

    YANG Description: Enable/disable setting the display format of the BGP 4 byte as to be unformatted integer type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="as-notation-plain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """as_notation_plain must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="as-notation-plain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__as_notation_plain = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_as_notation_plain(self):
    self.__as_notation_plain = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="as-notation-plain", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='boolean', is_config=True)


  def _get_route_distinguisher_auto_ip(self):
    """
    Getter method for route_distinguisher_auto_ip, mapped from YANG variable /network_instance/global/route_distinguisher_auto_ip (inet:ipv4-address-no-zone)

    YANG Description: Configure IP address to automatic route-distinguisher.
    """
    return self.__route_distinguisher_auto_ip
      
  def _set_route_distinguisher_auto_ip(self, v, load=False):
    """
    Setter method for route_distinguisher_auto_ip, mapped from YANG variable /network_instance/global/route_distinguisher_auto_ip (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_distinguisher_auto_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_distinguisher_auto_ip() directly.

    YANG Description: Configure IP address to automatic route-distinguisher.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="route-distinguisher-auto-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_distinguisher_auto_ip must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="route-distinguisher-auto-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)""",
        })

    self.__route_distinguisher_auto_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_distinguisher_auto_ip(self):
    self.__route_distinguisher_auto_ip = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="route-distinguisher-auto-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=True)

  cfg_router_id = __builtin__.property(_get_cfg_router_id, _set_cfg_router_id)
  as_notation_plain = __builtin__.property(_get_as_notation_plain, _set_as_notation_plain)
  route_distinguisher_auto_ip = __builtin__.property(_get_route_distinguisher_auto_ip, _set_route_distinguisher_auto_ip)


  _pyangbind_elements = OrderedDict([('cfg_router_id', cfg_router_id), ('as_notation_plain', as_notation_plain), ('route_distinguisher_auto_ip', route_distinguisher_auto_ip), ])


class yc_parameter_huawei_network_instance__network_instance_instances_instance_parameter(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure L3VPN instances information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__identifier',)

  _yang_name = 'parameter'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__identifier = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[1-9a-f][0-9a-f]{0,5}:[1-9a-f][0-9a-f]{0,7}|0:[1-9a-f][0-9a-f]{0,7}|[1-9a-f][0-9a-f]{0,5}:0', 'length': ['3..15']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'parameter']

  def _get_identifier(self):
    """
    Getter method for identifier, mapped from YANG variable /network_instance/instances/instance/parameter/identifier (string)

    YANG Description: Configures a globally unique identifier for a VPN instance. The format of a VPN identifier are follows:HEX<0-ffffffff>:HEX<0-ffffffff>, but not support 0:0.
    """
    return self.__identifier
      
  def _set_identifier(self, v, load=False):
    """
    Setter method for identifier, mapped from YANG variable /network_instance/instances/instance/parameter/identifier (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_identifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_identifier() directly.

    YANG Description: Configures a globally unique identifier for a VPN instance. The format of a VPN identifier are follows:HEX<0-ffffffff>:HEX<0-ffffffff>, but not support 0:0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[1-9a-f][0-9a-f]{0,5}:[1-9a-f][0-9a-f]{0,7}|0:[1-9a-f][0-9a-f]{0,7}|[1-9a-f][0-9a-f]{0,5}:0', 'length': ['3..15']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """identifier must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[1-9a-f][0-9a-f]{0,5}:[1-9a-f][0-9a-f]{0,7}|0:[1-9a-f][0-9a-f]{0,7}|[1-9a-f][0-9a-f]{0,5}:0', 'length': ['3..15']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)""",
        })

    self.__identifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_identifier(self):
    self.__identifier = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[1-9a-f][0-9a-f]{0,5}:[1-9a-f][0-9a-f]{0,7}|0:[1-9a-f][0-9a-f]{0,7}|[1-9a-f][0-9a-f]{0,5}:0', 'length': ['3..15']}), is_leaf=True, yang_name="identifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)

  identifier = __builtin__.property(_get_identifier, _set_identifier)


  _pyangbind_elements = OrderedDict([('identifier', identifier), ])


class yc_vpn_target_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets_vpn_target(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs/af/vpn-targets/vpn-target. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure RT (VPN Target) s to control route advertisement
between network nodes. Before sending a VPN route to a PE,
the local PE adds an Export RT to the route. After receiving
a route from another PE, the local PE determines whether the
route will be added to the VPN instance based on the local
Import RT and the Export RT that is added to the VPN route.
  """
  __slots__ = ('_path_helper', '_extmethods', '__value','__type',)

  _yang_name = 'vpn-target'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'export-extcommunity': {'value': 2}, 'import-extcommunity': {'value': 3}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-target-type', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs', 'af', 'vpn-targets', 'vpn-target']

  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets/vpn_target/value (string)

    YANG Description: The formats of a VPN target value are as follows:
(1) 16-bit AS number : 32-bit user-defined number,
    for example, 1:3. An AS number ranges from 0
    to 65535, and a user-defined number ranges from
    0 to 4294967295. The AS number and user-defined
    number cannot be both 0s. This means that the
    VPN Target value cannot be 0:0.
(2) 32-bit IP address: 16-bit user-defined number,
    for example: 192.168.122.15:1.The IP address
    ranges from 0.0.0.0 to 255.255.255.255, and
    the user-defined number ranges from 0 to 65535.
(3) 32-bit AS number :16-bit user-defined number,
    for example, 10.11:3. An AS number ranges from
    0.0 to 65535.65535 or 0 to 4294967295, and a
    user-defined number ranges from 0 to 65535.
    The AS number and user-defined number cannot
    be both 0s. This means that the VPN Target
    value cannot be 0.0:0.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets/vpn_target/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: The formats of a VPN target value are as follows:
(1) 16-bit AS number : 32-bit user-defined number,
    for example, 1:3. An AS number ranges from 0
    to 65535, and a user-defined number ranges from
    0 to 4294967295. The AS number and user-defined
    number cannot be both 0s. This means that the
    VPN Target value cannot be 0:0.
(2) 32-bit IP address: 16-bit user-defined number,
    for example: 192.168.122.15:1.The IP address
    ranges from 0.0.0.0 to 255.255.255.255, and
    the user-defined number ranges from 0 to 65535.
(3) 32-bit AS number :16-bit user-defined number,
    for example, 10.11:3. An AS number ranges from
    0.0 to 65535.65535 or 0 to 4294967295, and a
    user-defined number ranges from 0 to 65535.
    The AS number and user-defined number cannot
    be both 0s. This means that the VPN Target
    value cannot be 0.0:0.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets/vpn_target/type (vpn-target-type)

    YANG Description: RT types are as follows:
export-extcommunity: Specifies the value of the
  extended community attribute of the route from
  an outbound interface to the destination VPN.
import-extcommunity: Receives routes that carry
  the specified extended community attribute value.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets/vpn_target/type (vpn-target-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: RT types are as follows:
export-extcommunity: Specifies the value of the
  extended community attribute of the route from
  an outbound interface to the destination VPN.
import-extcommunity: Receives routes that carry
  the specified extended community attribute value.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'export-extcommunity': {'value': 2}, 'import-extcommunity': {'value': 3}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-target-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with vpn-target-type""",
          'defined-type': "huawei-l3vpn:vpn-target-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'export-extcommunity': {'value': 2}, 'import-extcommunity': {'value': 3}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-target-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'export-extcommunity': {'value': 2}, 'import-extcommunity': {'value': 3}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-target-type', is_config=True)

  value = __builtin__.property(_get_value, _set_value)
  type = __builtin__.property(_get_type, _set_type)


  _pyangbind_elements = OrderedDict([('value', value), ('type', type), ])


class yc_vpn_targets_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs/af/vpn-targets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of RTs. The number of RTs in the group ranges from 1 to 8.
  """
  __slots__ = ('_path_helper', '_extmethods', '__vpn_target',)

  _yang_name = 'vpn-targets'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__vpn_target = YANGDynClass(base=YANGListType("value type",yc_vpn_target_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='value type', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs', 'af', 'vpn-targets']

  def _get_vpn_target(self):
    """
    Getter method for vpn_target, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets/vpn_target (list)

    YANG Description: Configure RT (VPN Target) s to control route advertisement
between network nodes. Before sending a VPN route to a PE,
the local PE adds an Export RT to the route. After receiving
a route from another PE, the local PE determines whether the
route will be added to the VPN instance based on the local
Import RT and the Export RT that is added to the VPN route.
    """
    return self.__vpn_target
      
  def _set_vpn_target(self, v, load=False):
    """
    Setter method for vpn_target, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets/vpn_target (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_target is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_target() directly.

    YANG Description: Configure RT (VPN Target) s to control route advertisement
between network nodes. Before sending a VPN route to a PE,
the local PE adds an Export RT to the route. After receiving
a route from another PE, the local PE determines whether the
route will be added to the VPN instance based on the local
Import RT and the Export RT that is added to the VPN route.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("value type",yc_vpn_target_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='value type', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_target must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("value type",yc_vpn_target_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='value type', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)""",
        })

    self.__vpn_target = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_target(self):
    self.__vpn_target = YANGDynClass(base=YANGListType("value type",yc_vpn_target_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets_vpn_target, yang_name="vpn-target", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='value type', extensions=None), is_container='list', yang_name="vpn-target", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)

  vpn_target = __builtin__.property(_get_vpn_target, _set_vpn_target) # type: yc_vpn_target_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets_vpn_target


  _pyangbind_elements = OrderedDict([('vpn_target', vpn_target), ])


class yc_state_huawei_network_instance__network_instance_instances_instance_afs_af_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs/af/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of address families of the VPN instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__create_time','__up_time','__label','__status',)

  _yang_name = 'state'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__create_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="create-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='yang:date-and-time', is_config=False)
    self.__up_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='pub-type:time-tick', is_config=False)
    self.__label = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-status-type', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs', 'af', 'state']

  def _get_create_time(self):
    """
    Getter method for create_time, mapped from YANG variable /network_instance/instances/instance/afs/af/state/create_time (yang:date-and-time)

    YANG Description: The createtime of address families of the VPN instance.
    """
    return self.__create_time
      
  def _set_create_time(self, v, load=False):
    """
    Setter method for create_time, mapped from YANG variable /network_instance/instances/instance/afs/af/state/create_time (yang:date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_create_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_create_time() directly.

    YANG Description: The createtime of address families of the VPN instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="create-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='yang:date-and-time', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """create_time must be of a type compatible with yang:date-and-time""",
          'defined-type': "yang:date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="create-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='yang:date-and-time', is_config=False)""",
        })

    self.__create_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_create_time(self):
    self.__create_time = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="create-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='yang:date-and-time', is_config=False)


  def _get_up_time(self):
    """
    Getter method for up_time, mapped from YANG variable /network_instance/instances/instance/afs/af/state/up_time (pub-type:time-tick)

    YANG Description: The uptime of address families of the VPN instance.
    """
    return self.__up_time
      
  def _set_up_time(self, v, load=False):
    """
    Setter method for up_time, mapped from YANG variable /network_instance/instances/instance/afs/af/state/up_time (pub-type:time-tick)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_up_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_up_time() directly.

    YANG Description: The uptime of address families of the VPN instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='pub-type:time-tick', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """up_time must be of a type compatible with pub-type:time-tick""",
          'defined-type': "pub-type:time-tick",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='pub-type:time-tick', is_config=False)""",
        })

    self.__up_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_up_time(self):
    self.__up_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="up-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='pub-type:time-tick', is_config=False)


  def _get_label(self):
    """
    Getter method for label, mapped from YANG variable /network_instance/instances/instance/afs/af/state/label (uint32)

    YANG Description: The label of address families of the VPN instance.
    """
    return self.__label
      
  def _set_label(self, v, load=False):
    """
    Setter method for label, mapped from YANG variable /network_instance/instances/instance/afs/af/state/label (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label() directly.

    YANG Description: The label of address families of the VPN instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)""",
        })

    self.__label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label(self):
    self.__label = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /network_instance/instances/instance/afs/af/state/status (vpn-status-type)

    YANG Description: VPN instance status. A VPN instance is up when there
is at least one interface associated with the VRF
whose ifOperStatus is up. A VRF is down when:
a. There does not exist at least one interface whose
   ifOperStatus is up.
b. There are no interfaces associated with the VRF.
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /network_instance/instances/instance/afs/af/state/status (vpn-status-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: VPN instance status. A VPN instance is up when there
is at least one interface associated with the VRF
whose ifOperStatus is up. A VRF is down when:
a. There does not exist at least one interface whose
   ifOperStatus is up.
b. There are no interfaces associated with the VRF.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-status-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with vpn-status-type""",
          'defined-type': "huawei-l3vpn:vpn-status-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-status-type', is_config=False)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'up': {'value': 1}, 'down': {'value': 2}},), is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='vpn-status-type', is_config=False)

  create_time = __builtin__.property(_get_create_time)
  up_time = __builtin__.property(_get_up_time)
  label = __builtin__.property(_get_label)
  status = __builtin__.property(_get_status)


  _pyangbind_elements = OrderedDict([('create_time', create_time), ('up_time', up_time), ('label', label), ('status', status), ])


class yc_tunnel_info_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos_tunnel_info(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs/af/tunnel-infos/tunnel-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Statistics of tunnel informations.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__peer_ip','__id','__color','__name',)

  _yang_name = 'tunnel-info'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'invalid': {'value': 0}, 'ldp': {'value': 1}, 'bgp': {'value': 2}, 'te': {'value': 3}, 'static-lsp': {'value': 4}, 'gre': {'value': 5}, 'uni': {'value': 6}, 'tnl-group': {'value': 7}, 'sub-te': {'value': 8}, 'sub-group': {'value': 9}, '6over4': {'value': 10}, '6to4': {'value': 11}, 'mpls-local-ifnet': {'value': 12}, 'ldp6': {'value': 13}, 'nvgre': {'value': 15}, 'p2mp-ldp': {'value': 16}, 'vxlan': {'value': 23}, 'ipsec': {'value': 24}, 'p2mp-te': {'value': 32}, 'vxlan-nvo3': {'value': 39}, 'gre6': {'value': 40}, 'srbe-lsp': {'value': 41}, 'vxlan6-nvo3': {'value': 42}, 'srv6': {'value': 43}, '4over6': {'value': 44}, '6rd': {'value': 45}, 'sr-te': {'value': 47}, 'p2mp-gre': {'value': 64}, 'ldp-lsp': {'value': 255}, 'sr-te-policy': {'value': 50}, 'sr-te-policy-group': {'value': 51}, 'srv6-te-policy': {'value': 52}, 'srv6-te-policy-group': {'value': 55}, 'flex-algo-lsp': {'value': 147}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='tnlm:tunnel-type', is_config=False)
    self.__peer_ip = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peer-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='inet:ip-address-no-zone', is_config=False)
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)
    self.__color = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..256']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs', 'af', 'tunnel-infos', 'tunnel-info']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/type (tnlm:tunnel-type)

    YANG Description: Tunnel's type.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/type (tnlm:tunnel-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Tunnel's type.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'invalid': {'value': 0}, 'ldp': {'value': 1}, 'bgp': {'value': 2}, 'te': {'value': 3}, 'static-lsp': {'value': 4}, 'gre': {'value': 5}, 'uni': {'value': 6}, 'tnl-group': {'value': 7}, 'sub-te': {'value': 8}, 'sub-group': {'value': 9}, '6over4': {'value': 10}, '6to4': {'value': 11}, 'mpls-local-ifnet': {'value': 12}, 'ldp6': {'value': 13}, 'nvgre': {'value': 15}, 'p2mp-ldp': {'value': 16}, 'vxlan': {'value': 23}, 'ipsec': {'value': 24}, 'p2mp-te': {'value': 32}, 'vxlan-nvo3': {'value': 39}, 'gre6': {'value': 40}, 'srbe-lsp': {'value': 41}, 'vxlan6-nvo3': {'value': 42}, 'srv6': {'value': 43}, '4over6': {'value': 44}, '6rd': {'value': 45}, 'sr-te': {'value': 47}, 'p2mp-gre': {'value': 64}, 'ldp-lsp': {'value': 255}, 'sr-te-policy': {'value': 50}, 'sr-te-policy-group': {'value': 51}, 'srv6-te-policy': {'value': 52}, 'srv6-te-policy-group': {'value': 55}, 'flex-algo-lsp': {'value': 147}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='tnlm:tunnel-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with tnlm:tunnel-type""",
          'defined-type': "tnlm:tunnel-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'invalid': {'value': 0}, 'ldp': {'value': 1}, 'bgp': {'value': 2}, 'te': {'value': 3}, 'static-lsp': {'value': 4}, 'gre': {'value': 5}, 'uni': {'value': 6}, 'tnl-group': {'value': 7}, 'sub-te': {'value': 8}, 'sub-group': {'value': 9}, '6over4': {'value': 10}, '6to4': {'value': 11}, 'mpls-local-ifnet': {'value': 12}, 'ldp6': {'value': 13}, 'nvgre': {'value': 15}, 'p2mp-ldp': {'value': 16}, 'vxlan': {'value': 23}, 'ipsec': {'value': 24}, 'p2mp-te': {'value': 32}, 'vxlan-nvo3': {'value': 39}, 'gre6': {'value': 40}, 'srbe-lsp': {'value': 41}, 'vxlan6-nvo3': {'value': 42}, 'srv6': {'value': 43}, '4over6': {'value': 44}, '6rd': {'value': 45}, 'sr-te': {'value': 47}, 'p2mp-gre': {'value': 64}, 'ldp-lsp': {'value': 255}, 'sr-te-policy': {'value': 50}, 'sr-te-policy-group': {'value': 51}, 'srv6-te-policy': {'value': 52}, 'srv6-te-policy-group': {'value': 55}, 'flex-algo-lsp': {'value': 147}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='tnlm:tunnel-type', is_config=False)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'invalid': {'value': 0}, 'ldp': {'value': 1}, 'bgp': {'value': 2}, 'te': {'value': 3}, 'static-lsp': {'value': 4}, 'gre': {'value': 5}, 'uni': {'value': 6}, 'tnl-group': {'value': 7}, 'sub-te': {'value': 8}, 'sub-group': {'value': 9}, '6over4': {'value': 10}, '6to4': {'value': 11}, 'mpls-local-ifnet': {'value': 12}, 'ldp6': {'value': 13}, 'nvgre': {'value': 15}, 'p2mp-ldp': {'value': 16}, 'vxlan': {'value': 23}, 'ipsec': {'value': 24}, 'p2mp-te': {'value': 32}, 'vxlan-nvo3': {'value': 39}, 'gre6': {'value': 40}, 'srbe-lsp': {'value': 41}, 'vxlan6-nvo3': {'value': 42}, 'srv6': {'value': 43}, '4over6': {'value': 44}, '6rd': {'value': 45}, 'sr-te': {'value': 47}, 'p2mp-gre': {'value': 64}, 'ldp-lsp': {'value': 255}, 'sr-te-policy': {'value': 50}, 'sr-te-policy-group': {'value': 51}, 'srv6-te-policy': {'value': 52}, 'srv6-te-policy-group': {'value': 55}, 'flex-algo-lsp': {'value': 147}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='tnlm:tunnel-type', is_config=False)


  def _get_peer_ip(self):
    """
    Getter method for peer_ip, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/peer_ip (inet:ip-address-no-zone)

    YANG Description: Next Hop address through which the packet has to be sent.
    """
    return self.__peer_ip
      
  def _set_peer_ip(self, v, load=False):
    """
    Setter method for peer_ip, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/peer_ip (inet:ip-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_peer_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_peer_ip() directly.

    YANG Description: Next Hop address through which the packet has to be sent.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peer-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='inet:ip-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """peer_ip must be of a type compatible with inet:ip-address-no-zone""",
          'defined-type': "inet:ip-address-no-zone",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peer-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='inet:ip-address-no-zone', is_config=False)""",
        })

    self.__peer_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_peer_ip(self):
    self.__peer_ip = YANGDynClass(base=[RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}),RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9a-fA-F:\\.]*'}),], is_leaf=True, yang_name="peer-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='inet:ip-address-no-zone', is_config=False)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/id (uint32)

    YANG Description: Tunnel's ID.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Tunnel's ID.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)


  def _get_color(self):
    """
    Getter method for color, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/color (uint32)

    YANG Description: Color information for tunnel.
    """
    return self.__color
      
  def _set_color(self, v, load=False):
    """
    Setter method for color, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/color (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_color is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_color() directly.

    YANG Description: Color information for tunnel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """color must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)""",
        })

    self.__color = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_color(self):
    self.__color = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=False)


  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/name (string)

    YANG Description: Tunnel's name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Tunnel's name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..256']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..256']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['0..256']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)

  type = __builtin__.property(_get_type)
  peer_ip = __builtin__.property(_get_peer_ip)
  id = __builtin__.property(_get_id)
  color = __builtin__.property(_get_color)
  name = __builtin__.property(_get_name)


  _pyangbind_elements = OrderedDict([('type', type), ('peer_ip', peer_ip), ('id', id), ('color', color), ('name', name), ])


class yc_tunnel_infos_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs/af/tunnel-infos. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Tunnel Informations.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tunnel_info',)

  _yang_name = 'tunnel-infos'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tunnel_info = YANGDynClass(base=YANGListType("type peer_ip id",yc_tunnel_info_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos_tunnel_info, yang_name="tunnel-info", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type peer-ip id', extensions=None), is_container='list', yang_name="tunnel-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs', 'af', 'tunnel-infos']

  def _get_tunnel_info(self):
    """
    Getter method for tunnel_info, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info (list)

    YANG Description: Statistics of tunnel informations.
    """
    return self.__tunnel_info
      
  def _set_tunnel_info(self, v, load=False):
    """
    Setter method for tunnel_info, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos/tunnel_info (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_info() directly.

    YANG Description: Statistics of tunnel informations.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type peer_ip id",yc_tunnel_info_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos_tunnel_info, yang_name="tunnel-info", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type peer-ip id', extensions=None), is_container='list', yang_name="tunnel-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_info must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type peer_ip id",yc_tunnel_info_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos_tunnel_info, yang_name="tunnel-info", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type peer-ip id', extensions=None), is_container='list', yang_name="tunnel-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=False)""",
        })

    self.__tunnel_info = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_info(self):
    self.__tunnel_info = YANGDynClass(base=YANGListType("type peer_ip id",yc_tunnel_info_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos_tunnel_info, yang_name="tunnel-info", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type peer-ip id', extensions=None), is_container='list', yang_name="tunnel-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=False)

  tunnel_info = __builtin__.property(_get_tunnel_info) # type: yc_tunnel_info_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos_tunnel_info


  _pyangbind_elements = OrderedDict([('tunnel_info', tunnel_info), ])


class yc_af_huawei_network_instance__network_instance_instances_instance_afs_af(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs/af. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure address families of the VPN instance. A VPN instance
supports the configurations and functions of an
address family only after the address family is
configured on the instance. Neither of the address
families in the _public_ VPN instance can be deleted.
If either of a VPN instance's IPv4 and IPv6 address
families is referenced by BGP, the referenced address
family cannot be deleted. If one of the address
families is referenced by BGP, the non-referenced
address family in the VPN instance can be deleted.
If the VPN instance is referenced by BGP but its
address families are not referenced by BGP, neither
address family can be deleted.
  """
  __slots__ = ('_path_helper', '_extmethods', '__type','__route_distinguisher','__effect_route_distinguisher','__import_policy','__export_policy','__export_policy_add_ert_first','__label_mode','__static_label','__vpn_frr','__tunnel_policy','__transit_vpn','__lsp_operation','__default_color','__vpn_targets','__state','__tunnel_infos',)

  _yang_name = 'af'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-unicast': {'value': 1}, 'ipv6-unicast': {'value': 5}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='af-type', is_config=True)
    self.__route_distinguisher = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)
    self.__effect_route_distinguisher = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="effect-route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)
    self.__import_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, choice=('import-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)
    self.__export_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, choice=('export-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)
    self.__export_policy_add_ert_first = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="export-policy-add-ert-first", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    self.__label_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'per-instance': {'value': 1}, 'per-route': {'value': 0}, 'per-nexthop': {'value': 2}},), default=six.text_type("per-instance"), is_leaf=True, yang_name="label-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='label-mode-type', is_config=True)
    self.__static_label = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}), is_leaf=True, yang_name="static-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=True)
    self.__vpn_frr = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vpn-frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    self.__tunnel_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tunnel-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)
    self.__transit_vpn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="transit-vpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    self.__lsp_operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'pop': {'value': 0}, 'pop-go': {'value': 1}},), default=six.text_type("pop"), is_leaf=True, yang_name="lsp-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='lsp-operation-type', is_config=True)
    self.__default_color = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="default-color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=True)
    self.__vpn_targets = YANGDynClass(base=yc_vpn_targets_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_huawei_network_instance__network_instance_instances_instance_afs_af_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    self.__tunnel_infos = YANGDynClass(base=yc_tunnel_infos_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos, is_container='container', yang_name="tunnel-infos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs', 'af']

  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /network_instance/instances/instance/afs/af/type (af-type)

    YANG Description: Types of the VPN address families.
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /network_instance/instances/instance/afs/af/type (af-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Types of the VPN address families.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-unicast': {'value': 1}, 'ipv6-unicast': {'value': 5}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='af-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with af-type""",
          'defined-type': "huawei-l3vpn:af-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-unicast': {'value': 1}, 'ipv6-unicast': {'value': 5}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='af-type', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4-unicast': {'value': 1}, 'ipv6-unicast': {'value': 5}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='af-type', is_config=True)


  def _get_route_distinguisher(self):
    """
    Getter method for route_distinguisher, mapped from YANG variable /network_instance/instances/instance/afs/af/route_distinguisher (string)

    YANG Description: A VPN address family takes effect only after it is
configured with a RD.The object allows configuration
and deletion, it cannot be modified. The format of
an RD are as follows:
(1) 16-bit AS number :32-bit user-defined number,
    for example, 101:3. An AS number ranges from 0 to 65535,
    and a user-defined number ranges from 0 to 4294967295.
    The AS number and user-defined number cannot be both 0s.
    This means that the RD value cannot be 0:0.
(2) 32-bit IP address:16-bit user-defined number,
    for example: 192.168.122.15:1.The IP address ranges from
    0.0.0.0 to 255.255.255.255, and the user-defined number
    ranges from 0 to 65535.
(3) 32-bit AS number :16-bit user-defined number,
    for example, 10.11:3. An AS number ranges from 0.0 to
    65535.65535 or 0 to 4294967295, and a user-defined number
    ranges from 0 to 65535. The AS number and user-defined
    number cannot be both 0s. This means that the RD value
    cannot be 0.0:0. If a VPN instance's IPv4 or IPv6 address
    family to which the node belongs is referenced by BGP,
    the node cannot be deleted. If the IPv4 or IPv6 address
    family to which the node belongs is not referenced by
    BGP and the other address family is referenced by BGP,
    the node can be deleted. If the VPN instance is referenced
    by BGP but its address families are not referenced by BGP,
    the nodes in the address families cannot be deleted.
    """
    return self.__route_distinguisher
      
  def _set_route_distinguisher(self, v, load=False):
    """
    Setter method for route_distinguisher, mapped from YANG variable /network_instance/instances/instance/afs/af/route_distinguisher (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_distinguisher is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_distinguisher() directly.

    YANG Description: A VPN address family takes effect only after it is
configured with a RD.The object allows configuration
and deletion, it cannot be modified. The format of
an RD are as follows:
(1) 16-bit AS number :32-bit user-defined number,
    for example, 101:3. An AS number ranges from 0 to 65535,
    and a user-defined number ranges from 0 to 4294967295.
    The AS number and user-defined number cannot be both 0s.
    This means that the RD value cannot be 0:0.
(2) 32-bit IP address:16-bit user-defined number,
    for example: 192.168.122.15:1.The IP address ranges from
    0.0.0.0 to 255.255.255.255, and the user-defined number
    ranges from 0 to 65535.
(3) 32-bit AS number :16-bit user-defined number,
    for example, 10.11:3. An AS number ranges from 0.0 to
    65535.65535 or 0 to 4294967295, and a user-defined number
    ranges from 0 to 65535. The AS number and user-defined
    number cannot be both 0s. This means that the RD value
    cannot be 0.0:0. If a VPN instance's IPv4 or IPv6 address
    family to which the node belongs is referenced by BGP,
    the node cannot be deleted. If the IPv4 or IPv6 address
    family to which the node belongs is not referenced by
    BGP and the other address family is referenced by BGP,
    the node can be deleted. If the VPN instance is referenced
    by BGP but its address families are not referenced by BGP,
    the nodes in the address families cannot be deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_distinguisher must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)""",
        })

    self.__route_distinguisher = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_distinguisher(self):
    self.__route_distinguisher = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=True)


  def _get_effect_route_distinguisher(self):
    """
    Getter method for effect_route_distinguisher, mapped from YANG variable /network_instance/instances/instance/afs/af/effect_route_distinguisher (string)

    YANG Description: Effective route-distinguisher configuration.
    """
    return self.__effect_route_distinguisher
      
  def _set_effect_route_distinguisher(self, v, load=False):
    """
    Setter method for effect_route_distinguisher, mapped from YANG variable /network_instance/instances/instance/afs/af/effect_route_distinguisher (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_effect_route_distinguisher is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_effect_route_distinguisher() directly.

    YANG Description: Effective route-distinguisher configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="effect-route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """effect_route_distinguisher must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="effect-route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)""",
        })

    self.__effect_route_distinguisher = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_effect_route_distinguisher(self):
    self.__effect_route_distinguisher = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['3..21']}), is_leaf=True, yang_name="effect-route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='string', is_config=False)


  def _get_import_policy(self):
    """
    Getter method for import_policy, mapped from YANG variable /network_instance/instances/instance/afs/af/import_policy (leafref)

    YANG Description: Name of a route import policy. The policy is associating
the VPN instance with an inbound routing policy. If a
mode that is more accurate than the extended community
attribute mode is required for filtering import VPN
instance routes, the inbound routing policy can be
adopted. The inbound routing policy can filter imported
routes and set routing attributes for the qualified routes.
If the inbound routing policy is not configured, all routes
matching the VPN-target attribute are added to the VPN instance.
    """
    return self.__import_policy
      
  def _set_import_policy(self, v, load=False):
    """
    Setter method for import_policy, mapped from YANG variable /network_instance/instances/instance/afs/af/import_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_import_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_import_policy() directly.

    YANG Description: Name of a route import policy. The policy is associating
the VPN instance with an inbound routing policy. If a
mode that is more accurate than the extended community
attribute mode is required for filtering import VPN
instance routes, the inbound routing policy can be
adopted. The inbound routing policy can filter imported
routes and set routing attributes for the qualified routes.
If the inbound routing policy is not configured, all routes
matching the VPN-target attribute are added to the VPN instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, choice=('import-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """import_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, choice=('import-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)""",
        })

    self.__import_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_import_policy(self):
    self.__import_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="import-policy", parent=self, choice=('import-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)


  def _get_export_policy(self):
    """
    Getter method for export_policy, mapped from YANG variable /network_instance/instances/instance/afs/af/export_policy (leafref)

    YANG Description: Name of a route export policy. The policy is associating
the VPN instance with an outbound routing policy.
If a mode that is more accurate than the extended
community attribute mode is required to control
the advertisement ofVPN instance routes, the outbound
routing policy can be adopted. The outbound routing
policy can filter the routes to be advertised and set
routing attributes for the qualified routes. If the
outbound routing policy is not configured, all routes
can be advertised.
    """
    return self.__export_policy
      
  def _set_export_policy(self, v, load=False):
    """
    Setter method for export_policy, mapped from YANG variable /network_instance/instances/instance/afs/af/export_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_export_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_export_policy() directly.

    YANG Description: Name of a route export policy. The policy is associating
the VPN instance with an outbound routing policy.
If a mode that is more accurate than the extended
community attribute mode is required to control
the advertisement ofVPN instance routes, the outbound
routing policy can be adopted. The outbound routing
policy can filter the routes to be advertised and set
routing attributes for the qualified routes. If the
outbound routing policy is not configured, all routes
can be advertised.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, choice=('export-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """export_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, choice=('export-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)""",
        })

    self.__export_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_export_policy(self):
    self.__export_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="export-policy", parent=self, choice=('export-policy-type', 'rtp-ref'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)


  def _get_export_policy_add_ert_first(self):
    """
    Getter method for export_policy_add_ert_first, mapped from YANG variable /network_instance/instances/instance/afs/af/export_policy_add_ert_first (boolean)

    YANG Description: Enable/disable advertise routes to VPNv4 add ERT first.
    """
    return self.__export_policy_add_ert_first
      
  def _set_export_policy_add_ert_first(self, v, load=False):
    """
    Setter method for export_policy_add_ert_first, mapped from YANG variable /network_instance/instances/instance/afs/af/export_policy_add_ert_first (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_export_policy_add_ert_first is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_export_policy_add_ert_first() directly.

    YANG Description: Enable/disable advertise routes to VPNv4 add ERT first.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="export-policy-add-ert-first", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """export_policy_add_ert_first must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="export-policy-add-ert-first", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)""",
        })

    self.__export_policy_add_ert_first = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_export_policy_add_ert_first(self):
    self.__export_policy_add_ert_first = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="export-policy-add-ert-first", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)


  def _get_label_mode(self):
    """
    Getter method for label_mode, mapped from YANG variable /network_instance/instances/instance/afs/af/label_mode (label-mode-type)

    YANG Description: Method of distributing labels to VPN instance routes.
The way which assigns the label depends on the paf value.
If there are a large number of routes in a VPN instance,
assign a label for each instance. This allows all routes
in the instance to use one label.
    """
    return self.__label_mode
      
  def _set_label_mode(self, v, load=False):
    """
    Setter method for label_mode, mapped from YANG variable /network_instance/instances/instance/afs/af/label_mode (label-mode-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label_mode() directly.

    YANG Description: Method of distributing labels to VPN instance routes.
The way which assigns the label depends on the paf value.
If there are a large number of routes in a VPN instance,
assign a label for each instance. This allows all routes
in the instance to use one label.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'per-instance': {'value': 1}, 'per-route': {'value': 0}, 'per-nexthop': {'value': 2}},), default=six.text_type("per-instance"), is_leaf=True, yang_name="label-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='label-mode-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label_mode must be of a type compatible with label-mode-type""",
          'defined-type': "huawei-l3vpn:label-mode-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'per-instance': {'value': 1}, 'per-route': {'value': 0}, 'per-nexthop': {'value': 2}},), default=six.text_type("per-instance"), is_leaf=True, yang_name="label-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='label-mode-type', is_config=True)""",
        })

    self.__label_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label_mode(self):
    self.__label_mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'per-instance': {'value': 1}, 'per-route': {'value': 0}, 'per-nexthop': {'value': 2}},), default=six.text_type("per-instance"), is_leaf=True, yang_name="label-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='label-mode-type', is_config=True)


  def _get_static_label(self):
    """
    Getter method for static_label, mapped from YANG variable /network_instance/instances/instance/afs/af/static_label (uint32)

    YANG Description: Enable a device to assign the same static label to all routes destined for a remote PE in a VPN instance IPv4 address family.
    """
    return self.__static_label
      
  def _set_static_label(self, v, load=False):
    """
    Setter method for static_label, mapped from YANG variable /network_instance/instances/instance/afs/af/static_label (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_label() directly.

    YANG Description: Enable a device to assign the same static label to all routes destined for a remote PE in a VPN instance IPv4 address family.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}), is_leaf=True, yang_name="static-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_label must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}), is_leaf=True, yang_name="static-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=True)""",
        })

    self.__static_label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_label(self):
    self.__static_label = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['16..1048575']}), is_leaf=True, yang_name="static-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=True)


  def _get_vpn_frr(self):
    """
    Getter method for vpn_frr, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_frr (boolean)

    YANG Description: Enable/disable the VPN FRR function.
    """
    return self.__vpn_frr
      
  def _set_vpn_frr(self, v, load=False):
    """
    Setter method for vpn_frr, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_frr (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_frr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_frr() directly.

    YANG Description: Enable/disable the VPN FRR function.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vpn-frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_frr must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vpn-frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)""",
        })

    self.__vpn_frr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_frr(self):
    self.__vpn_frr = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="vpn-frr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)


  def _get_tunnel_policy(self):
    """
    Getter method for tunnel_policy, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_policy (leafref)

    YANG Description: Name of a tunnel policy. It is used to associate the VPN
instance with the specified tunnel policy. If no tunnel
policy is configured, the default tunnel policy is used.
Only LDP LSPs or static LSPs match the default tunnel policy,
and load balancing is not performed for LSPs.
    """
    return self.__tunnel_policy
      
  def _set_tunnel_policy(self, v, load=False):
    """
    Setter method for tunnel_policy, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_policy (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_policy() directly.

    YANG Description: Name of a tunnel policy. It is used to associate the VPN
instance with the specified tunnel policy. If no tunnel
policy is configured, the default tunnel policy is used.
Only LDP LSPs or static LSPs match the default tunnel policy,
and load balancing is not performed for LSPs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tunnel-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_policy must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tunnel-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)""",
        })

    self.__tunnel_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_policy(self):
    self.__tunnel_policy = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tunnel-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='leafref', is_config=True)


  def _get_transit_vpn(self):
    """
    Getter method for transit_vpn, mapped from YANG variable /network_instance/instances/instance/afs/af/transit_vpn (boolean)

    YANG Description: Enable/disable keeping the VPN instance status up.
    """
    return self.__transit_vpn
      
  def _set_transit_vpn(self, v, load=False):
    """
    Setter method for transit_vpn, mapped from YANG variable /network_instance/instances/instance/afs/af/transit_vpn (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transit_vpn is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transit_vpn() directly.

    YANG Description: Enable/disable keeping the VPN instance status up.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="transit-vpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transit_vpn must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="transit-vpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)""",
        })

    self.__transit_vpn = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transit_vpn(self):
    self.__transit_vpn = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="transit-vpn", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)


  def _get_lsp_operation(self):
    """
    Getter method for lsp_operation, mapped from YANG variable /network_instance/instances/instance/afs/af/lsp_operation (lsp-operation-type)

    YANG Description: Label Operation Mode.
    """
    return self.__lsp_operation
      
  def _set_lsp_operation(self, v, load=False):
    """
    Setter method for lsp_operation, mapped from YANG variable /network_instance/instances/instance/afs/af/lsp_operation (lsp-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lsp_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lsp_operation() directly.

    YANG Description: Label Operation Mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'pop': {'value': 0}, 'pop-go': {'value': 1}},), default=six.text_type("pop"), is_leaf=True, yang_name="lsp-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='lsp-operation-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lsp_operation must be of a type compatible with lsp-operation-type""",
          'defined-type': "huawei-l3vpn:lsp-operation-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'pop': {'value': 0}, 'pop-go': {'value': 1}},), default=six.text_type("pop"), is_leaf=True, yang_name="lsp-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='lsp-operation-type', is_config=True)""",
        })

    self.__lsp_operation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lsp_operation(self):
    self.__lsp_operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'pop': {'value': 0}, 'pop-go': {'value': 1}},), default=six.text_type("pop"), is_leaf=True, yang_name="lsp-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='lsp-operation-type', is_config=True)


  def _get_default_color(self):
    """
    Getter method for default_color, mapped from YANG variable /network_instance/instances/instance/afs/af/default_color (uint32)

    YANG Description: Set default color for nexthop iteration.
    """
    return self.__default_color
      
  def _set_default_color(self, v, load=False):
    """
    Setter method for default_color, mapped from YANG variable /network_instance/instances/instance/afs/af/default_color (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_color is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_color() directly.

    YANG Description: Set default color for nexthop iteration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="default-color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """default_color must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="default-color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=True)""",
        })

    self.__default_color = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_default_color(self):
    self.__default_color = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..4294967295']}), is_leaf=True, yang_name="default-color", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='uint32', is_config=True)


  def _get_vpn_targets(self):
    """
    Getter method for vpn_targets, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets (container)

    YANG Description: List of RTs. The number of RTs in the group ranges from 1 to 8.
    """
    return self.__vpn_targets
      
  def _set_vpn_targets(self, v, load=False):
    """
    Setter method for vpn_targets, mapped from YANG variable /network_instance/instances/instance/afs/af/vpn_targets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpn_targets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpn_targets() directly.

    YANG Description: List of RTs. The number of RTs in the group ranges from 1 to 8.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_vpn_targets_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vpn_targets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_vpn_targets_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)""",
        })

    self.__vpn_targets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vpn_targets(self):
    self.__vpn_targets = YANGDynClass(base=yc_vpn_targets_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets, is_container='container', yang_name="vpn-targets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instance/instances/instance/afs/af/state (container)

    YANG Description: Statistics of address families of the VPN instance.
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instance/instances/instance/afs/af/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Statistics of address families of the VPN instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_huawei_network_instance__network_instance_instances_instance_afs_af_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_huawei_network_instance__network_instance_instances_instance_afs_af_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_huawei_network_instance__network_instance_instances_instance_afs_af_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)


  def _get_tunnel_infos(self):
    """
    Getter method for tunnel_infos, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos (container)

    YANG Description: List of Tunnel Informations.
    """
    return self.__tunnel_infos
      
  def _set_tunnel_infos(self, v, load=False):
    """
    Setter method for tunnel_infos, mapped from YANG variable /network_instance/instances/instance/afs/af/tunnel_infos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel_infos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel_infos() directly.

    YANG Description: List of Tunnel Informations.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tunnel_infos_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos, is_container='container', yang_name="tunnel-infos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel_infos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tunnel_infos_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos, is_container='container', yang_name="tunnel-infos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)""",
        })

    self.__tunnel_infos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel_infos(self):
    self.__tunnel_infos = YANGDynClass(base=yc_tunnel_infos_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos, is_container='container', yang_name="tunnel-infos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)

  type = __builtin__.property(_get_type, _set_type)
  route_distinguisher = __builtin__.property(_get_route_distinguisher, _set_route_distinguisher)
  effect_route_distinguisher = __builtin__.property(_get_effect_route_distinguisher)
  import_policy = __builtin__.property(_get_import_policy, _set_import_policy)
  export_policy = __builtin__.property(_get_export_policy, _set_export_policy)
  export_policy_add_ert_first = __builtin__.property(_get_export_policy_add_ert_first, _set_export_policy_add_ert_first)
  label_mode = __builtin__.property(_get_label_mode, _set_label_mode)
  static_label = __builtin__.property(_get_static_label, _set_static_label)
  vpn_frr = __builtin__.property(_get_vpn_frr, _set_vpn_frr)
  tunnel_policy = __builtin__.property(_get_tunnel_policy, _set_tunnel_policy)
  transit_vpn = __builtin__.property(_get_transit_vpn, _set_transit_vpn)
  lsp_operation = __builtin__.property(_get_lsp_operation, _set_lsp_operation)
  default_color = __builtin__.property(_get_default_color, _set_default_color)
  vpn_targets = __builtin__.property(_get_vpn_targets, _set_vpn_targets) # type: yc_vpn_targets_huawei_network_instance__network_instance_instances_instance_afs_af_vpn_targets
  state = __builtin__.property(_get_state, _set_state) # type: yc_state_huawei_network_instance__network_instance_instances_instance_afs_af_state
  tunnel_infos = __builtin__.property(_get_tunnel_infos, _set_tunnel_infos) # type: yc_tunnel_infos_huawei_network_instance__network_instance_instances_instance_afs_af_tunnel_infos

  __choices__ = {'import-policy-type': {'rtp-ref': ['import_policy']}, 'export-policy-type': {'rtp-ref': ['export_policy']}}
  _pyangbind_elements = OrderedDict([('type', type), ('route_distinguisher', route_distinguisher), ('effect_route_distinguisher', effect_route_distinguisher), ('import_policy', import_policy), ('export_policy', export_policy), ('export_policy_add_ert_first', export_policy_add_ert_first), ('label_mode', label_mode), ('static_label', static_label), ('vpn_frr', vpn_frr), ('tunnel_policy', tunnel_policy), ('transit_vpn', transit_vpn), ('lsp_operation', lsp_operation), ('default_color', default_color), ('vpn_targets', vpn_targets), ('state', state), ('tunnel_infos', tunnel_infos), ])


class yc_afs_huawei_network_instance__network_instance_instances_instance_afs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance/afs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VPN address families. A VPN instance supports the
configurations and functions of an address family only
after the address family is configured on the instance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__af',)

  _yang_name = 'afs'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__af = YANGDynClass(base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance', 'afs']

  def _get_af(self):
    """
    Getter method for af, mapped from YANG variable /network_instance/instances/instance/afs/af (list)

    YANG Description: Configure address families of the VPN instance. A VPN instance
supports the configurations and functions of an
address family only after the address family is
configured on the instance. Neither of the address
families in the _public_ VPN instance can be deleted.
If either of a VPN instance's IPv4 and IPv6 address
families is referenced by BGP, the referenced address
family cannot be deleted. If one of the address
families is referenced by BGP, the non-referenced
address family in the VPN instance can be deleted.
If the VPN instance is referenced by BGP but its
address families are not referenced by BGP, neither
address family can be deleted.
    """
    return self.__af
      
  def _set_af(self, v, load=False):
    """
    Setter method for af, mapped from YANG variable /network_instance/instances/instance/afs/af (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_af is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_af() directly.

    YANG Description: Configure address families of the VPN instance. A VPN instance
supports the configurations and functions of an
address family only after the address family is
configured on the instance. Neither of the address
families in the _public_ VPN instance can be deleted.
If either of a VPN instance's IPv4 and IPv6 address
families is referenced by BGP, the referenced address
family cannot be deleted. If one of the address
families is referenced by BGP, the non-referenced
address family in the VPN instance can be deleted.
If the VPN instance is referenced by BGP but its
address families are not referenced by BGP, neither
address family can be deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """af must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)""",
        })

    self.__af = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_af(self):
    self.__af = YANGDynClass(base=YANGListType("type",yc_af_huawei_network_instance__network_instance_instances_instance_afs_af, yang_name="af", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="af", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='list', is_config=True)

  af = __builtin__.property(_get_af, _set_af) # type: yc_af_huawei_network_instance__network_instance_instances_instance_afs_af


  _pyangbind_elements = OrderedDict([('af', af), ])


class yc_instance_huawei_network_instance__network_instance_instances_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances/instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configure VPN instances. VPN instances are established to separate VPN routes from public network routes, and separate the routes of different VPNs. Multiple software features can be bound to multiple VPN instances to form a multi-instance that provides multiple features, for example, RIP multi-instance, OSPF multi-instance, IS-IS multi-instance, and BGP multi-instance. The _public_, dcn, ason, __mpp_vpn_inner__, __mpp_vpn_outer__, __mpp_vpn_inner_server__, and __LOCAL_OAM_VPN__ instances cannot be deleted.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__description','__sys_router_id','__vrf_id','__traffic_statistic_enable','__parameter','__afs',)

  _yang_name = 'instance'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)
    self.__sys_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="sys-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=False)
    self.__vrf_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vrf-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='uint32', is_config=False)
    self.__traffic_statistic_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    self.__parameter = YANGDynClass(base=yc_parameter_huawei_network_instance__network_instance_instances_instance_parameter, is_container='container', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    self.__afs = YANGDynClass(base=yc_afs_huawei_network_instance__network_instance_instances_instance_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances', 'instance']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /network_instance/instances/instance/name (string)

    YANG Description: VPN instance name. It uniquely identifies a VPN instance. The name is a string of case-sensitive characters.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /network_instance/instances/instance/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: VPN instance name. It uniquely identifies a VPN instance. The name is a string of case-sensitive characters.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'length': ['1..31']}), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /network_instance/instances/instance/description (string)

    YANG Description: The description of a VPN instance. The value is a string, spaces supported.
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /network_instance/instances/instance/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: The description of a VPN instance. The value is a string, spaces supported.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '([^?]*)', 'length': ['1..242']}), is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='string', is_config=True)


  def _get_sys_router_id(self):
    """
    Getter method for sys_router_id, mapped from YANG variable /network_instance/instances/instance/sys_router_id (inet:ipv4-address-no-zone)

    YANG Description: The router id of current use.
    """
    return self.__sys_router_id
      
  def _set_sys_router_id(self, v, load=False):
    """
    Setter method for sys_router_id, mapped from YANG variable /network_instance/instances/instance/sys_router_id (inet:ipv4-address-no-zone)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sys_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sys_router_id() directly.

    YANG Description: The router id of current use.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="sys-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sys_router_id must be of a type compatible with inet:ipv4-address-no-zone""",
          'defined-type': "inet:ipv4-address-no-zone",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="sys-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=False)""",
        })

    self.__sys_router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sys_router_id(self):
    self.__sys_router_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}), restriction_dict={'pattern': '[0-9\\.]*'}), is_leaf=True, yang_name="sys-router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='inet:ipv4-address-no-zone', is_config=False)


  def _get_vrf_id(self):
    """
    Getter method for vrf_id, mapped from YANG variable /network_instance/instances/instance/vrf_id (uint32)

    YANG Description: Vpn Instances ID.
    """
    return self.__vrf_id
      
  def _set_vrf_id(self, v, load=False):
    """
    Setter method for vrf_id, mapped from YANG variable /network_instance/instances/instance/vrf_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vrf_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vrf_id() directly.

    YANG Description: Vpn Instances ID.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vrf-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """vrf_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vrf-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__vrf_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_vrf_id(self):
    self.__vrf_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="vrf-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='uint32', is_config=False)


  def _get_traffic_statistic_enable(self):
    """
    Getter method for traffic_statistic_enable, mapped from YANG variable /network_instance/instances/instance/traffic_statistic_enable (boolean)

    YANG Description: Enable/disable L3VPN traffic statistics.
    """
    return self.__traffic_statistic_enable
      
  def _set_traffic_statistic_enable(self, v, load=False):
    """
    Setter method for traffic_statistic_enable, mapped from YANG variable /network_instance/instances/instance/traffic_statistic_enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_statistic_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_statistic_enable() directly.

    YANG Description: Enable/disable L3VPN traffic statistics.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_statistic_enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)""",
        })

    self.__traffic_statistic_enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_statistic_enable(self):
    self.__traffic_statistic_enable = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="traffic-statistic-enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='boolean', is_config=True)


  def _get_parameter(self):
    """
    Getter method for parameter, mapped from YANG variable /network_instance/instances/instance/parameter (container)

    YANG Description: Configure L3VPN instances information.
    """
    return self.__parameter
      
  def _set_parameter(self, v, load=False):
    """
    Setter method for parameter, mapped from YANG variable /network_instance/instances/instance/parameter (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Configure L3VPN instances information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_parameter_huawei_network_instance__network_instance_instances_instance_parameter, is_container='container', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parameter must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_parameter_huawei_network_instance__network_instance_instances_instance_parameter, is_container='container', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)""",
        })

    self.__parameter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parameter(self):
    self.__parameter = YANGDynClass(base=yc_parameter_huawei_network_instance__network_instance_instances_instance_parameter, is_container='container', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)


  def _get_afs(self):
    """
    Getter method for afs, mapped from YANG variable /network_instance/instances/instance/afs (container)

    YANG Description: List of VPN address families. A VPN instance supports the
configurations and functions of an address family only
after the address family is configured on the instance.
    """
    return self.__afs
      
  def _set_afs(self, v, load=False):
    """
    Setter method for afs, mapped from YANG variable /network_instance/instances/instance/afs (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_afs is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_afs() directly.

    YANG Description: List of VPN address families. A VPN instance supports the
configurations and functions of an address family only
after the address family is configured on the instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_afs_huawei_network_instance__network_instance_instances_instance_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """afs must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_afs_huawei_network_instance__network_instance_instances_instance_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)""",
        })

    self.__afs = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_afs(self):
    self.__afs = YANGDynClass(base=yc_afs_huawei_network_instance__network_instance_instances_instance_afs, is_container='container', yang_name="afs", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-l3vpn', defining_module='huawei-l3vpn', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  description = __builtin__.property(_get_description, _set_description)
  sys_router_id = __builtin__.property(_get_sys_router_id)
  vrf_id = __builtin__.property(_get_vrf_id)
  traffic_statistic_enable = __builtin__.property(_get_traffic_statistic_enable, _set_traffic_statistic_enable)
  parameter = __builtin__.property(_get_parameter, _set_parameter) # type: yc_parameter_huawei_network_instance__network_instance_instances_instance_parameter
  afs = __builtin__.property(_get_afs, _set_afs) # type: yc_afs_huawei_network_instance__network_instance_instances_instance_afs


  _pyangbind_elements = OrderedDict([('name', name), ('description', description), ('sys_router_id', sys_router_id), ('vrf_id', vrf_id), ('traffic_statistic_enable', traffic_statistic_enable), ('parameter', parameter), ('afs', afs), ])


class yc_instances_huawei_network_instance__network_instance_instances(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance/instances. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VPN instances. VPN instances are established to separate VPN routes from public network routes, and separate the routes of different VPNs. Some software features can be bound to multiple VPN instances so that multiple instances can provide a same feature. For example, RIP, OSPF, IS-IS, and BGP multiple instances.
  """
  __slots__ = ('_path_helper', '_extmethods', '__instance',)

  _yang_name = 'instances'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instance = YANGDynClass(base=YANGListType("name",yc_instance_huawei_network_instance__network_instance_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance', 'instances']

  def _get_instance(self):
    """
    Getter method for instance, mapped from YANG variable /network_instance/instances/instance (list)

    YANG Description: Configure VPN instances. VPN instances are established to separate VPN routes from public network routes, and separate the routes of different VPNs. Multiple software features can be bound to multiple VPN instances to form a multi-instance that provides multiple features, for example, RIP multi-instance, OSPF multi-instance, IS-IS multi-instance, and BGP multi-instance. The _public_, dcn, ason, __mpp_vpn_inner__, __mpp_vpn_outer__, __mpp_vpn_inner_server__, and __LOCAL_OAM_VPN__ instances cannot be deleted.
    """
    return self.__instance
      
  def _set_instance(self, v, load=False):
    """
    Setter method for instance, mapped from YANG variable /network_instance/instances/instance (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instance() directly.

    YANG Description: Configure VPN instances. VPN instances are established to separate VPN routes from public network routes, and separate the routes of different VPNs. Multiple software features can be bound to multiple VPN instances to form a multi-instance that provides multiple features, for example, RIP multi-instance, OSPF multi-instance, IS-IS multi-instance, and BGP multi-instance. The _public_, dcn, ason, __mpp_vpn_inner__, __mpp_vpn_outer__, __mpp_vpn_inner_server__, and __LOCAL_OAM_VPN__ instances cannot be deleted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_instance_huawei_network_instance__network_instance_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instance must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_instance_huawei_network_instance__network_instance_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='list', is_config=True)""",
        })

    self.__instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instance(self):
    self.__instance = YANGDynClass(base=YANGListType("name",yc_instance_huawei_network_instance__network_instance_instances_instance, yang_name="instance", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='list', is_config=True)

  instance = __builtin__.property(_get_instance, _set_instance) # type: yc_instance_huawei_network_instance__network_instance_instances_instance


  _pyangbind_elements = OrderedDict([('instance', instance), ])


class yc_network_instance_huawei_network_instance__network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Layer 3 Virtual Private Network (L3VPN). An L3VPN is a virtual private network set up over public networks by Internet Service Providers (ISPs) and Network Service Providers (NSPs).
  """
  __slots__ = ('_path_helper', '_extmethods', '__global_','__instances',)

  _yang_name = 'network-instance'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__global_ = YANGDynClass(base=yc_global__huawei_network_instance__network_instance_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)
    self.__instances = YANGDynClass(base=yc_instances_huawei_network_instance__network_instance_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instance']

  def _get_global_(self):
    """
    Getter method for global_, mapped from YANG variable /network_instance/global (container)

    YANG Description: Configure the global layer 3 virtual private network (L3VPN).
    """
    return self.__global_
      
  def _set_global_(self, v, load=False):
    """
    Setter method for global_, mapped from YANG variable /network_instance/global (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_() directly.

    YANG Description: Configure the global layer 3 virtual private network (L3VPN).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_global__huawei_network_instance__network_instance_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_ must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_global__huawei_network_instance__network_instance_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)""",
        })

    self.__global_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_(self):
    self.__global_ = YANGDynClass(base=yc_global__huawei_network_instance__network_instance_global, is_container='container', yang_name="global", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)


  def _get_instances(self):
    """
    Getter method for instances, mapped from YANG variable /network_instance/instances (container)

    YANG Description: List of VPN instances. VPN instances are established to separate VPN routes from public network routes, and separate the routes of different VPNs. Some software features can be bound to multiple VPN instances so that multiple instances can provide a same feature. For example, RIP, OSPF, IS-IS, and BGP multiple instances.
    """
    return self.__instances
      
  def _set_instances(self, v, load=False):
    """
    Setter method for instances, mapped from YANG variable /network_instance/instances (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instances() directly.

    YANG Description: List of VPN instances. VPN instances are established to separate VPN routes from public network routes, and separate the routes of different VPNs. Some software features can be bound to multiple VPN instances so that multiple instances can provide a same feature. For example, RIP, OSPF, IS-IS, and BGP multiple instances.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_instances_huawei_network_instance__network_instance_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instances must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_instances_huawei_network_instance__network_instance_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)""",
        })

    self.__instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instances(self):
    self.__instances = YANGDynClass(base=yc_instances_huawei_network_instance__network_instance_instances, is_container='container', yang_name="instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)

  global_ = __builtin__.property(_get_global_, _set_global_) # type: yc_global__huawei_network_instance__network_instance_global
  instances = __builtin__.property(_get_instances, _set_instances) # type: yc_instances_huawei_network_instance__network_instance_instances


  _pyangbind_elements = OrderedDict([('global_', global_), ('instances', instances), ])


class huawei_network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module huawei-network-instance - based on the path /huawei-network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Layer 3 Virtual Private Network (L3VPN). An L3VPN is a virtual private network set up over public networks by Internet Service Providers (ISPs) and Network Service Providers (NSPs).
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_instance',)

  _yang_name = 'huawei-network-instance'
  _yang_namespace = 'urn:huawei:yang:huawei-network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_instance = YANGDynClass(base=yc_network_instance_huawei_network_instance__network_instance, is_container='container', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_network_instance(self):
    """
    Getter method for network_instance, mapped from YANG variable /network_instance (container)

    YANG Description: Layer 3 Virtual Private Network (L3VPN). An L3VPN is a virtual private network set up over public networks by Internet Service Providers (ISPs) and Network Service Providers (NSPs).
    """
    return self.__network_instance
      
  def _set_network_instance(self, v, load=False):
    """
    Setter method for network_instance, mapped from YANG variable /network_instance (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instance() directly.

    YANG Description: Layer 3 Virtual Private Network (L3VPN). An L3VPN is a virtual private network set up over public networks by Internet Service Providers (ISPs) and Network Service Providers (NSPs).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_network_instance_huawei_network_instance__network_instance, is_container='container', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instance must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_network_instance_huawei_network_instance__network_instance, is_container='container', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)""",
        })

    self.__network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instance(self):
    self.__network_instance = YANGDynClass(base=yc_network_instance_huawei_network_instance__network_instance, is_container='container', yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:huawei:yang:huawei-network-instance', defining_module='huawei-network-instance', yang_type='container', is_config=True)

  network_instance = __builtin__.property(_get_network_instance, _set_network_instance) # type: yc_network_instance_huawei_network_instance__network_instance


  _pyangbind_elements = OrderedDict([('network_instance', network_instance), ])


